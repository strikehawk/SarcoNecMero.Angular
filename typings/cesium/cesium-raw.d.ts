// Type definitions for Cesium v1.27
// Project: https://cesiumjs.org
// Definitions by: Jackie Ng <https://github.com/jumpinjackie>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

//
// This file is automatically generated by jsdoc-typescript-plugin (https://github.com/jumpinjackie/jsdoc-typescript-plugin). 
//
// Do not edit this file unless you know what you're doing. Where possible, consult the plugin documentation for options to
// augment and customize the content of this generated file
//

declare module Cesium {
    /**
     * Cesium's internal copy of knockout.js
     */
    const knockout: any; //TODO: Should probably link to knockout d.ts 
    /**
     * Cesium's internal copy of when.js
     */
    const when: any; //TODO: If there's a typings for this, we should be linking against it

    /**
     * Type alias for a promise
     */
    type Promise<T> = PromiseLike<T>;
    
    type TypedArray = any[];
    
    type Packable = any;
    
    type Proxy = any;
    
    type Context = any;
    
    type Frustum = any;
    
    type DrawCommand = any;

    // ========== These types are not supposed to be public, but the plugin is leaking them out at the moment ========== //
    
    type BufferUsage = any;

    type VertexBuffer = any;

    type IndexBuffer = any;

    type ShaderProgram = any;

    type ShaderSource = any;

    type IauOrientationParameters = any;

    type HMDVRDevice = any;

    type Rotation = any;

    type Framebuffer = any;

    type ClearCommand = any;

    type VertexArray = any;

    type Texture = any;

    type Pass = any;

    type CubeMap = any;

    type MipmapHint = any;

    type PassState = any;

    type Tile = any;

    type TileReplacementQueue = any;
    /**
     * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
retrieved from an ArcGIS ImageServer.
     */
    class ArcGisImageServerTerrainProvider {
        /**
         * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
retrieved from an ArcGIS ImageServer.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IArcGisImageServerTerrainProviderOptions);
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
the source of the terrain.  This function should not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         */
        tilingScheme: GeographicTilingScheme;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
indicates which areas of the globe are water rather than land, so they can be rendered
as a reflective surface with animated waves.  This function should not be
called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         */
        hasWaterMask: Boolean;
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
This function should not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         */
        hasVertexNormals: Boolean;
        /**
         * Requests the geometry for a given tile.  This function should not be called before
{@link ArcGisImageServerTerrainProvider#ready} returns true.  The result includes terrain
data and indicates that all child tiles are available.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        requestTileGeometry(x: number, y: number, level: number): Promise<TerrainData>;
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.
         * @param level  (Required) The tile level for which to get the maximum geometric error.
         */
        getLevelMaximumGeometricError(level: number): number;
        /**
         * Determines whether data for a tile is available to be loaded.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        getTileDataAvailable(x: number, y: number, level: number): Boolean;
    }
    /**
     * A collection of key-value pairs that is stored as a hash for easy
lookup but also provides an array for fast iteration.
     */
    class AssociativeArray {
        /**
         * A collection of key-value pairs that is stored as a hash for easy
lookup but also provides an array for fast iteration.
         */
        constructor();
        /**
         * Gets the number of items in the collection.
         */
        length: number;
        /**
         * Gets an unordered array of all values in the collection.
This is a live array that will automatically reflect the values in the collection,
it should not be modified directly.
         */
        values: any[];
        /**
         * Determines if the provided key is in the array.
         * @param key  (Required) The key to check.
         */
        contains(key: string|Number): Boolean;
        /**
         * Associates the provided key with the provided value.  If the key already
exists, it is overwritten with the new value.
         * @param key  (Required) A unique identifier.
         * @param value  (Required) The value to associate with the provided key.
         */
        set(key: string|Number, value: any): void;
        /**
         * Retrieves the value associated with the provided key.
         * @param key  (Required) The key whose value is to be retrieved.
         */
        get(key: string|Number): any;
        /**
         * Removes a key-value pair from the collection.
         * @param key  (Required) The key to be removed.
         */
        remove(key: string|Number): Boolean;
        /**
         * Clears the collection.
         */
        removeAll(): void;
    }
    /**
     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
     */
    class AxisAlignedBoundingBox {
        /**
         * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
         * @param minimum  (Optional) The minimum point along the x, y, and z axes.
         * @param maximum  (Optional) The maximum point along the x, y, and z axes.
         * @param center  (Optional) The center of the box; automatically computed if not supplied.
         */
        constructor(minimum?: Cartesian3, maximum?: Cartesian3, center?: Cartesian3);
        /**
         * The minimum point defining the bounding box.
         */
        minimum: Cartesian3;
        /**
         * The maximum point defining the bounding box.
         */
        maximum: Cartesian3;
        /**
         * The center point of the bounding box.
         */
        center: Cartesian3;
        /**
         * Computes an instance of an AxisAlignedBoundingBox. The box is determined by
finding the points spaced the farthest apart on the x, y, and z axes.
         * @param positions  (Required) List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromPoints(positions: Cartesian3[], result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
        /**
         * Duplicates a AxisAlignedBoundingBox instance.
         * @param box  (Required) The bounding box to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(box: AxisAlignedBoundingBox, result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
        /**
         * Compares the provided AxisAlignedBoundingBox componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first AxisAlignedBoundingBox.
         * @param right  (Optional) The second AxisAlignedBoundingBox.
         */
        static equals(left?: AxisAlignedBoundingBox, right?: AxisAlignedBoundingBox): Boolean;
        /**
         * Determines which side of a plane a box is located.
         * @param box  (Required) The bounding box to test.
         * @param plane  (Required) The plane to test against.
         */
        static intersectPlane(box: AxisAlignedBoundingBox, plane: Plane): number;
        /**
         * Duplicates this AxisAlignedBoundingBox instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
        /**
         * Determines which side of a plane this box is located.
         * @param plane  (Required) The plane to test against.
         */
        intersectPlane(plane: Plane): number;
        /**
         * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side AxisAlignedBoundingBox.
         */
        equals(right?: AxisAlignedBoundingBox): Boolean;
    }
    /**
     * A bounding rectangle given by a corner, width and height.
     */
    class BoundingRectangle {
        /**
         * A bounding rectangle given by a corner, width and height.
         * @param x  (Optional) The x coordinate of the rectangle.
         * @param y  (Optional) The y coordinate of the rectangle.
         * @param width  (Optional) The width of the rectangle.
         * @param height  (Optional) The height of the rectangle.
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * The x coordinate of the rectangle.
         */
        x: number;
        /**
         * The y coordinate of the rectangle.
         */
        y: number;
        /**
         * The width of the rectangle.
         */
        width: number;
        /**
         * The height of the rectangle.
         */
        height: number;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: BoundingRectangle, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: BoundingRectangle): BoundingRectangle;
        /**
         * Computes a bounding rectangle enclosing the list of 2D points.
The rectangle is oriented with the corner at the bottom left.
         * @param positions  (Required) List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromPoints(positions: Cartesian2[], result?: BoundingRectangle): BoundingRectangle;
        /**
         * Computes a bounding rectangle from an rectangle.
         * @param rectangle  (Required) The valid rectangle used to create a bounding rectangle.
         * @param projection  (Optional) The projection used to project the rectangle into 2D.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRectangle(rectangle: Rectangle, projection?: any, result?: BoundingRectangle): BoundingRectangle;
        /**
         * Duplicates a BoundingRectangle instance.
         * @param rectangle  (Required) The bounding rectangle to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(rectangle: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;
        /**
         * Computes a bounding rectangle that is the union of the left and right bounding rectangles.
         * @param left  (Required) A rectangle to enclose in bounding rectangle.
         * @param right  (Required) A rectangle to enclose in a bounding rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static union(left: BoundingRectangle, right: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;
        /**
         * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.
         * @param rectangle  (Required) A rectangle to expand.
         * @param point  (Required) A point to enclose in a bounding rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static expand(rectangle: BoundingRectangle, point: Cartesian2, result?: BoundingRectangle): BoundingRectangle;
        /**
         * Determines if two rectangles intersect.
         * @param left  (Required) A rectangle to check for intersection.
         * @param right  (Required) The other rectangle to check for intersection.
         */
        static intersect(left: BoundingRectangle, right: BoundingRectangle): number;
        /**
         * Compares the provided BoundingRectangles componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first BoundingRectangle.
         * @param right  (Optional) The second BoundingRectangle.
         */
        static equals(left?: BoundingRectangle, right?: BoundingRectangle): Boolean;
        /**
         * Duplicates this BoundingRectangle instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: BoundingRectangle): BoundingRectangle;
        /**
         * Determines if this rectangle intersects with another.
         * @param right  (Required) A rectangle to check for intersection.
         */
        intersect(right: BoundingRectangle): number;
        /**
         * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side BoundingRectangle.
         */
        equals(right?: BoundingRectangle): Boolean;
    }
    /**
     * A bounding sphere with a center and a radius.
     */
    class BoundingSphere {
        /**
         * A bounding sphere with a center and a radius.
         * @param center  (Optional) The center of the bounding sphere.
         * @param radius  (Optional) The radius of the bounding sphere.
         */
        constructor(center?: Cartesian3, radius?: number);
        /**
         * The center point of the sphere.
         */
        center: Cartesian3;
        /**
         * The radius of the sphere.
         */
        radius: number;
        /**
         * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
The bounding sphere is computed by running two algorithms, a naive algorithm and
Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.
         * @param positions  (Required) An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromPoints(positions: Cartesian3[], result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere from an rectangle projected in 2D.
         * @param rectangle  (Required) The rectangle around which to create a bounding sphere.
         * @param projection  (Optional) The projection used to project the rectangle into 2D.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRectangle2D(rectangle: Rectangle, projection?: any, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere from an rectangle projected in 2D.  The bounding sphere accounts for the
object's minimum and maximum heights over the rectangle.
         * @param rectangle  (Required) The rectangle around which to create a bounding sphere.
         * @param projection  (Optional) The projection used to project the rectangle into 2D.
         * @param minimumHeight  (Optional) The minimum height over the rectangle.
         * @param maximumHeight  (Optional) The maximum height over the rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRectangleWithHeights2D(rectangle: Rectangle, projection?: any, minimumHeight?: number, maximumHeight?: number, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere from an rectangle in 3D. The bounding sphere is created using a subsample of points
on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.
         * @param rectangle  (Required) The valid rectangle used to create a bounding sphere.
         * @param ellipsoid  (Optional) The ellipsoid used to determine positions of the rectangle.
         * @param surfaceHeight  (Optional) The height above the surface of the ellipsoid.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRectangle3D(rectangle: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are
stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two
algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
ensure a tight fit.
         * @param positions  (Required) An array of points that the bounding sphere will enclose.  Each point
       is formed from three elements in the array in the order X, Y, Z.
         * @param center  (Optional) The position to which the positions are relative, which need not be the
       origin of the coordinate system.  This is useful when the positions are to be used for
       relative-to-center (RTC) rendering.
         * @param stride  (Optional) The number of array elements per vertex.  It must be at least 3, but it may
       be higher.  Regardless of the value of this parameter, the X coordinate of the first position
       is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index
       2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If
       the stride is 5, however, two array elements are skipped and the next position begins at array
       index 5.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromVertices(positions: number[], center?: Cartesian3, stride?: number, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a tight-fitting bounding sphere enclosing a list of {@link EncodedCartesian3}s, where the points are
stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two
algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
ensure a tight fit.
         * @param positionsHigh  (Required) An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point
       is formed from three elements in the array in the order X, Y, Z.
         * @param positionsLow  (Required) An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point
       is formed from three elements in the array in the order X, Y, Z.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromEncodedCartesianVertices(positionsHigh: number[], positionsLow: number[], result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
tighly and fully encompases the box.
         * @param corner  (Optional) The minimum height over the rectangle.
         * @param oppositeCorner  (Optional) The maximum height over the rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCornerPoints(corner?: Cartesian3, oppositeCorner?: Cartesian3, result?: BoundingSphere): BoundingSphere;
        /**
         * Creates a bounding sphere encompassing an ellipsoid.
         * @param ellipsoid  (Required) The ellipsoid around which to create a bounding sphere.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromEllipsoid(ellipsoid: Ellipsoid, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.
         * @param boundingSpheres  (Required) The array of bounding spheres.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromBoundingSpheres(boundingSpheres: BoundingSphere[], result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.
         * @param orientedBoundingBox  (Required) The oriented bounding box.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromOrientedBoundingBox(orientedBoundingBox: OrientedBoundingBox, result?: BoundingSphere): BoundingSphere;
        /**
         * Duplicates a BoundingSphere instance.
         * @param sphere  (Required) The bounding sphere to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(sphere: BoundingSphere, result?: BoundingSphere): BoundingSphere;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: BoundingSphere, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere that contains both the left and right bounding spheres.
         * @param left  (Required) A sphere to enclose in a bounding sphere.
         * @param right  (Required) A sphere to enclose in a bounding sphere.
         * @param result  (Optional) The object onto which to store the result.
         */
        static union(left: BoundingSphere, right: BoundingSphere, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.
         * @param sphere  (Required) A sphere to expand.
         * @param point  (Required) A point to enclose in a bounding sphere.
         * @param result  (Optional) The object onto which to store the result.
         */
        static expand(sphere: BoundingSphere, point: Cartesian3, result?: BoundingSphere): BoundingSphere;
        /**
         * Determines which side of a plane a sphere is located.
         * @param sphere  (Required) The bounding sphere to test.
         * @param plane  (Required) The plane to test against.
         */
        static intersectPlane(sphere: BoundingSphere, plane: Plane): number;
        /**
         * Applies a 4x4 affine transformation matrix to a bounding sphere.
         * @param sphere  (Required) The bounding sphere to apply the transformation to.
         * @param transform  (Required) The transformation matrix to apply to the bounding sphere.
         * @param result  (Optional) The object onto which to store the result.
         */
        static transform(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;
        /**
         * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
         * @param sphere  (Required) The sphere.
         * @param cartesian  (Required) The point
         */
        static distanceSquaredTo(sphere: BoundingSphere, cartesian: Cartesian3): number;
        /**
         * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale
The transformation matrix is not verified to have a uniform scale of 1.
This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.
         * @param sphere  (Required) The bounding sphere to apply the transformation to.
         * @param transform  (Required) The transformation matrix to apply to the bounding sphere.
         * @param result  (Optional) The object onto which to store the result.
         */
        static transformWithoutScale(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;
        /**
         * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
plus/minus the radius of the bounding sphere.
<br>
If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
closest and farthest planes from position that intersect the bounding sphere.
         * @param sphere  (Required) The bounding sphere to calculate the distance to.
         * @param position  (Required) The position to calculate the distance from.
         * @param direction  (Required) The direction from position.
         * @param result  (Optional) A Interval to store the nearest and farthest distances.
         */
        static computePlaneDistances(sphere: BoundingSphere, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
        /**
         * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.
         * @param sphere  (Required) The bounding sphere to transform to 2D.
         * @param projection  (Optional) The projection to 2D.
         * @param result  (Optional) The object onto which to store the result.
         */
        static projectTo2D(sphere: BoundingSphere, projection?: any, result?: BoundingSphere): BoundingSphere;
        /**
         * Determines whether or not a sphere is hidden from view by the occluder.
         * @param sphere  (Required) The bounding sphere surrounding the occludee object.
         * @param occluder  (Required) The occluder.
         */
        static isOccluded(sphere: BoundingSphere, occluder: Occluder): Boolean;
        /**
         * Compares the provided BoundingSphere componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first BoundingSphere.
         * @param right  (Optional) The second BoundingSphere.
         */
        static equals(left?: BoundingSphere, right?: BoundingSphere): Boolean;
        /**
         * Determines which side of a plane the sphere is located.
         * @param plane  (Required) The plane to test against.
         */
        intersectPlane(plane: Plane): number;
        /**
         * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
         * @param cartesian  (Required) The point
         */
        distanceSquaredTo(cartesian: Cartesian3): number;
        /**
         * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
plus/minus the radius of the bounding sphere.
<br>
If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
closest and farthest planes from position that intersect the bounding sphere.
         * @param position  (Required) The position to calculate the distance from.
         * @param direction  (Required) The direction from position.
         * @param result  (Optional) A Interval to store the nearest and farthest distances.
         */
        computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
        /**
         * Determines whether or not a sphere is hidden from view by the occluder.
         * @param occluder  (Required) The occluder.
         */
        isOccluded(occluder: Occluder): Boolean;
        /**
         * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side BoundingSphere.
         */
        equals(right?: BoundingSphere): Boolean;
        /**
         * Duplicates this BoundingSphere instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: BoundingSphere): BoundingSphere;
    }
    /**
     * Describes a cube centered at the origin.
     */
    class BoxGeometry {
        /**
         * Describes a cube centered at the origin.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IBoxGeometryOptions);
        /**
         * Creates a cube centered at the origin given its dimensions.
         * @param options  (Required) Object with the following properties:
         */
        static fromDimensions(options: BoxGeometry.IBoxGeometryFromDimensionsOptions): BoxGeometry;
        /**
         * Creates a cube from the dimensions of an AxisAlignedBoundingBox.
         * @param boundingBox  (Required) A description of the AxisAlignedBoundingBox.
         */
        static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxGeometry;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: BoxGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: BoxGeometry): BoxGeometry;
        /**
         * Computes the geometric representation of a box, including its vertices, indices, and a bounding sphere.
         * @param boxGeometry  (Required) A description of the box.
         */
        static createGeometry(boxGeometry: BoxGeometry): Geometry;
    }
    /**
     * A description of the outline of a cube centered at the origin.
     */
    class BoxOutlineGeometry {
        /**
         * A description of the outline of a cube centered at the origin.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IBoxOutlineGeometryOptions);
        /**
         * Creates an outline of a cube centered at the origin given its dimensions.
         * @param options  (Required) Object with the following properties:
         */
        static fromDimensions(options: BoxOutlineGeometry.IBoxOutlineGeometryFromDimensionsOptions): BoxOutlineGeometry;
        /**
         * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.
         * @param boundingBox  (Required) A description of the AxisAlignedBoundingBox.
         */
        static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxOutlineGeometry;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: BoxOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: BoxOutlineGeometry): BoxOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.
         * @param boxGeometry  (Required) A description of the box outline.
         */
        static createGeometry(boxGeometry: BoxOutlineGeometry): Geometry;
    }
    /**
     * A 2D Cartesian point.
     */
    class Cartesian2 {
        /**
         * A 2D Cartesian point.
         * @param x  (Optional) The X component.
         * @param y  (Optional) The Y component.
         */
        constructor(x?: number, y?: number);
        /**
         * The X component.
         */
        x: number;
        /**
         * The Y component.
         */
        y: number;
        /**
         * Creates a Cartesian2 instance from x and y coordinates.
         * @param x  (Required) The x coordinate.
         * @param y  (Required) The y coordinate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromElements(x: number, y: number, result?: Cartesian2): Cartesian2;
        /**
         * Duplicates a Cartesian2 instance.
         * @param cartesian  (Required) The Cartesian to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(cartesian: Cartesian2, result?: Cartesian2): Cartesian2;
        /**
         * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
x and y properties of the Cartesian3 and drops z.
         * @param cartesian  (Required) The Cartesian3 instance to create a Cartesian2 instance from.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian3(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
        /**
         * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
x and y properties of the Cartesian4 and drops z and w.
         * @param cartesian  (Required) The Cartesian4 instance to create a Cartesian2 instance from.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian4(cartesian: Cartesian4, result?: Cartesian2): Cartesian2;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Cartesian2, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
        /**
         * Flattens an array of Cartesian2s into and array of components.
         * @param array  (Required) The array of cartesians to pack.
         * @param result  (Required) The array onto which to store the result.
         */
        static packArray(array: Cartesian2[], result: number[]): number[];
        /**
         * Unpacks an array of cartesian components into and array of Cartesian2s.
         * @param array  (Required) The array of components to unpack.
         * @param result  (Required) The array onto which to store the result.
         */
        static unpackArray(array: number[], result: Cartesian2[]): Cartesian2[];
        /**
         * Creates a Cartesian2 from two consecutive elements in an array.
         * @param array  (Required) The array whose two consecutive elements correspond to the x and y components, respectively.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to the x component.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static maximumComponent(cartesian: Cartesian2): number;
        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static minimumComponent(cartesian: Cartesian2): number;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static minimumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static maximumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the provided Cartesian's squared magnitude.
         * @param cartesian  (Required) The Cartesian instance whose squared magnitude is to be computed.
         */
        static magnitudeSquared(cartesian: Cartesian2): number;
        /**
         * Computes the Cartesian's magnitude (length).
         * @param cartesian  (Required) The Cartesian instance whose magnitude is to be computed.
         */
        static magnitude(cartesian: Cartesian2): number;
        /**
         * Computes the distance between two points.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distance(left: Cartesian2, right: Cartesian2): number;
        /**
         * Computes the squared distance between two points.  Comparing squared distances
using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distanceSquared(left: Cartesian2, right: Cartesian2): number;
        /**
         * Computes the normalized form of the supplied Cartesian.
         * @param cartesian  (Required) The Cartesian to be normalized.
         * @param result  (Required) The object onto which to store the result.
         */
        static normalize(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the dot (scalar) product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         */
        static dot(left: Cartesian2, right: Cartesian2): number;
        /**
         * Computes the componentwise product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the componentwise sum of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the componentwise difference of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be scaled.
         * @param scalar  (Required) The scalar to multiply with.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be divided.
         * @param scalar  (Required) The scalar to divide by.
         * @param result  (Required) The object onto which to store the result.
         */
        static divideByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
        /**
         * Negates the provided Cartesian.
         * @param cartesian  (Required) The Cartesian to be negated.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the absolute value of the provided Cartesian.
         * @param cartesian  (Required) The Cartesian whose absolute value is to be computed.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static lerp(start: Cartesian2, end: Cartesian2, t: number, result: Cartesian2): Cartesian2;
        /**
         * Returns the angle, in radians, between the provided Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         */
        static angleBetween(left: Cartesian2, right: Cartesian2): number;
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         * @param cartesian  (Required) The Cartesian on which to find the most orthogonal axis.
         * @param result  (Required) The object onto which to store the result.
         */
        static mostOrthogonalAxis(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         */
        static equals(left?: Cartesian2, right?: Cartesian2): Boolean;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        static equalsEpsilon(left?: Cartesian2, right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Duplicates this Cartesian2 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Cartesian2): Cartesian2;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         */
        equals(right?: Cartesian2): Boolean;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        equalsEpsilon(right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Creates a string representing this Cartesian in the format '(x, y)'.
         */
        toString(): string;
    }
    /**
     * A 3D Cartesian point.
     */
    class Cartesian3 {
        /**
         * A 3D Cartesian point.
         * @param x  (Optional) The X component.
         * @param y  (Optional) The Y component.
         * @param z  (Optional) The Z component.
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * The X component.
         */
        x: number;
        /**
         * The Y component.
         */
        y: number;
        /**
         * The Z component.
         */
        z: number;
        /**
         * Converts the provided Spherical into Cartesian3 coordinates.
         * @param spherical  (Required) The Spherical to be converted to Cartesian3.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromSpherical(spherical: Spherical, result?: Cartesian3): Cartesian3;
        /**
         * Creates a Cartesian3 instance from x, y and z coordinates.
         * @param x  (Required) The x coordinate.
         * @param y  (Required) The y coordinate.
         * @param z  (Required) The z coordinate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromElements(x: number, y: number, z: number, result?: Cartesian3): Cartesian3;
        /**
         * Duplicates a Cartesian3 instance.
         * @param cartesian  (Required) The Cartesian to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
x, y, and z properties of the Cartesian4 and drops w.
         * @param cartesian  (Required) The Cartesian4 instance to create a Cartesian3 instance from.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian4(cartesian: Cartesian4, result?: Cartesian3): Cartesian3;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Cartesian3, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
        /**
         * Flattens an array of Cartesian3s into an array of components.
         * @param array  (Required) The array of cartesians to pack.
         * @param result  (Required) The array onto which to store the result.
         */
        static packArray(array: Cartesian3[], result: number[]): number[];
        /**
         * Unpacks an array of cartesian components into an array of Cartesian3s.
         * @param array  (Required) The array of components to unpack.
         * @param result  (Required) The array onto which to store the result.
         */
        static unpackArray(array: number[], result: Cartesian3[]): Cartesian3[];
        /**
         * Creates a Cartesian3 from three consecutive elements in an array.
         * @param array  (Required) The array whose three consecutive elements correspond to the x, y, and z components, respectively.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to the x component.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static maximumComponent(cartesian: Cartesian3): number;
        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static minimumComponent(cartesian: Cartesian3): number;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static minimumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static maximumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the provided Cartesian's squared magnitude.
         * @param cartesian  (Required) The Cartesian instance whose squared magnitude is to be computed.
         */
        static magnitudeSquared(cartesian: Cartesian3): number;
        /**
         * Computes the Cartesian's magnitude (length).
         * @param cartesian  (Required) The Cartesian instance whose magnitude is to be computed.
         */
        static magnitude(cartesian: Cartesian3): number;
        /**
         * Computes the distance between two points.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distance(left: Cartesian3, right: Cartesian3): number;
        /**
         * Computes the squared distance between two points.  Comparing squared distances
using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distanceSquared(left: Cartesian3, right: Cartesian3): number;
        /**
         * Computes the normalized form of the supplied Cartesian.
         * @param cartesian  (Required) The Cartesian to be normalized.
         * @param result  (Required) The object onto which to store the result.
         */
        static normalize(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the dot (scalar) product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         */
        static dot(left: Cartesian3, right: Cartesian3): number;
        /**
         * Computes the componentwise product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the componentwise sum of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the componentwise difference of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be scaled.
         * @param scalar  (Required) The scalar to multiply with.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be divided.
         * @param scalar  (Required) The scalar to divide by.
         * @param result  (Required) The object onto which to store the result.
         */
        static divideByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
        /**
         * Negates the provided Cartesian.
         * @param cartesian  (Required) The Cartesian to be negated.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the absolute value of the provided Cartesian.
         * @param cartesian  (Required) The Cartesian whose absolute value is to be computed.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static lerp(start: Cartesian3, end: Cartesian3, t: number, result: Cartesian3): Cartesian3;
        /**
         * Returns the angle, in radians, between the provided Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         */
        static angleBetween(left: Cartesian3, right: Cartesian3): number;
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         * @param cartesian  (Required) The Cartesian on which to find the most orthogonal axis.
         * @param result  (Required) The object onto which to store the result.
         */
        static mostOrthogonalAxis(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         */
        static equals(left?: Cartesian3, right?: Cartesian3): Boolean;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        static equalsEpsilon(left?: Cartesian3, right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Computes the cross (outer) product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static cross(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Returns a Cartesian3 position from longitude and latitude values given in degrees.
         * @param longitude  (Required) The longitude, in degrees
         * @param latitude  (Required) The latitude, in degrees
         * @param height  (Optional) The height, in meters, above the ellipsoid.
         * @param ellipsoid  (Optional) The ellipsoid on which the position lies.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromDegrees(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
        /**
         * Returns a Cartesian3 position from longitude and latitude values given in radians.
         * @param longitude  (Required) The longitude, in radians
         * @param latitude  (Required) The latitude, in radians
         * @param height  (Optional) The height, in meters, above the ellipsoid.
         * @param ellipsoid  (Optional) The ellipsoid on which the position lies.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRadians(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
        /**
         * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
         * @param coordinates  (Required) A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
         * @param ellipsoid  (Optional) The ellipsoid on which the coordinates lie.
         * @param result  (Optional) An array of Cartesian3 objects to store the result.
         */
        static fromDegreesArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
        /**
         * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
         * @param coordinates  (Required) A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
         * @param ellipsoid  (Optional) The ellipsoid on which the coordinates lie.
         * @param result  (Optional) An array of Cartesian3 objects to store the result.
         */
        static fromRadiansArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
        /**
         * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
         * @param coordinates  (Required) A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
         * @param ellipsoid  (Optional) The ellipsoid on which the position lies.
         * @param result  (Optional) An array of Cartesian3 objects to store the result.
         */
        static fromDegreesArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
        /**
         * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
         * @param coordinates  (Required) A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
         * @param ellipsoid  (Optional) The ellipsoid on which the position lies.
         * @param result  (Optional) An array of Cartesian3 objects to store the result.
         */
        static fromRadiansArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
        /**
         * Duplicates this Cartesian3 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Cartesian3): Cartesian3;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         */
        equals(right?: Cartesian3): Boolean;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        equalsEpsilon(right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Creates a string representing this Cartesian in the format '(x, y, z)'.
         */
        toString(): string;
    }
    /**
     * A 4D Cartesian point.
     */
    class Cartesian4 {
        /**
         * A 4D Cartesian point.
         * @param x  (Optional) The X component.
         * @param y  (Optional) The Y component.
         * @param z  (Optional) The Z component.
         * @param w  (Optional) The W component.
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * The X component.
         */
        x: number;
        /**
         * The Y component.
         */
        y: number;
        /**
         * The Z component.
         */
        z: number;
        /**
         * The W component.
         */
        w: number;
        /**
         * Creates a Cartesian4 instance from x, y, z and w coordinates.
         * @param x  (Required) The x coordinate.
         * @param y  (Required) The y coordinate.
         * @param z  (Required) The z coordinate.
         * @param w  (Required) The w coordinate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromElements(x: number, y: number, z: number, w: number, result?: Cartesian4): Cartesian4;
        /**
         * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
         * @param color  (Required) The source color.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromColor(color: number, result?: Cartesian4): Cartesian4;
        /**
         * Duplicates a Cartesian4 instance.
         * @param cartesian  (Required) The Cartesian to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Cartesian4, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
        /**
         * Flattens an array of Cartesian4s into and array of components.
         * @param array  (Required) The array of cartesians to pack.
         * @param result  (Required) The array onto which to store the result.
         */
        static packArray(array: Cartesian4[], result: number[]): number[];
        /**
         * Unpacks an array of cartesian components into and array of Cartesian4s.
         * @param array  (Required) The array of components to unpack.
         * @param result  (Required) The array onto which to store the result.
         */
        static unpackArray(array: number[], result: Cartesian4[]): Cartesian4[];
        /**
         * Creates a Cartesian4 from four consecutive elements in an array.
         * @param array  (Required) The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to the x component.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static maximumComponent(cartesian: Cartesian4): number;
        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         * @param cartesian  (Required) The cartesian to use.
         */
        static minimumComponent(cartesian: Cartesian4): number;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static minimumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         * @param first  (Required) A cartesian to compare.
         * @param second  (Required) A cartesian to compare.
         * @param result  (Required) The object into which to store the result.
         */
        static maximumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the provided Cartesian's squared magnitude.
         * @param cartesian  (Required) The Cartesian instance whose squared magnitude is to be computed.
         */
        static magnitudeSquared(cartesian: Cartesian4): number;
        /**
         * Computes the Cartesian's magnitude (length).
         * @param cartesian  (Required) The Cartesian instance whose magnitude is to be computed.
         */
        static magnitude(cartesian: Cartesian4): number;
        /**
         * Computes the 4-space distance between two points.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distance(left: Cartesian4, right: Cartesian4): number;
        /**
         * Computes the squared distance between two points.  Comparing squared distances
using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
         * @param left  (Required) The first point to compute the distance from.
         * @param right  (Required) The second point to compute the distance to.
         */
        static distanceSquared(left: Cartesian4, right: Cartesian4): number;
        /**
         * Computes the normalized form of the supplied Cartesian.
         * @param cartesian  (Required) The Cartesian to be normalized.
         * @param result  (Required) The object onto which to store the result.
         */
        static normalize(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the dot (scalar) product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         */
        static dot(left: Cartesian4, right: Cartesian4): number;
        /**
         * Computes the componentwise product of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the componentwise sum of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the componentwise difference of two Cartesians.
         * @param left  (Required) The first Cartesian.
         * @param right  (Required) The second Cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be scaled.
         * @param scalar  (Required) The scalar to multiply with.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         * @param cartesian  (Required) The Cartesian to be divided.
         * @param scalar  (Required) The scalar to divide by.
         * @param result  (Required) The object onto which to store the result.
         */
        static divideByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
        /**
         * Negates the provided Cartesian.
         * @param cartesian  (Required) The Cartesian to be negated.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the absolute value of the provided Cartesian.
         * @param cartesian  (Required) The Cartesian whose absolute value is to be computed.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static lerp(start: Cartesian4, end: Cartesian4, t: number, result: Cartesian4): Cartesian4;
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         * @param cartesian  (Required) The Cartesian on which to find the most orthogonal axis.
         * @param result  (Required) The object onto which to store the result.
         */
        static mostOrthogonalAxis(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         */
        static equals(left?: Cartesian4, right?: Cartesian4): Boolean;
        /**
         * Compares the provided Cartesians componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param left  (Optional) The first Cartesian.
         * @param right  (Optional) The second Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        static equalsEpsilon(left?: Cartesian4, right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Duplicates this Cartesian4 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Cartesian4): Cartesian4;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         */
        equals(right?: Cartesian4): Boolean;
        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side Cartesian.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        equalsEpsilon(right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Creates a string representing this Cartesian in the format '(x, y)'.
         */
        toString(): string;
    }
    /**
     * A position defined by longitude, latitude, and height.
     */
    class Cartographic {
        /**
         * A position defined by longitude, latitude, and height.
         * @param longitude  (Optional) The longitude, in radians.
         * @param latitude  (Optional) The latitude, in radians.
         * @param height  (Optional) The height, in meters, above the ellipsoid.
         */
        constructor(longitude?: number, latitude?: number, height?: number);
        /**
         * The longitude, in radians.
         */
        longitude: number;
        /**
         * The latitude, in radians.
         */
        latitude: number;
        /**
         * The height, in meters, above the ellipsoid.
         */
        height: number;
        /**
         * Creates a new Cartographic instance from longitude and latitude
specified in radians.
         * @param longitude  (Required) The longitude, in radians.
         * @param latitude  (Required) The latitude, in radians.
         * @param height  (Optional) The height, in meters, above the ellipsoid.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
        /**
         * Creates a new Cartographic instance from longitude and latitude
specified in degrees.  The values in the resulting object will
be in radians.
         * @param longitude  (Required) The longitude, in degrees.
         * @param latitude  (Required) The latitude, in degrees.
         * @param height  (Optional) The height, in meters, above the ellipsoid.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromDegrees(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
        /**
         * Creates a new Cartographic instance from a Cartesian position. The values in the
resulting object will be in radians.
         * @param cartesian  (Required) The Cartesian position to convert to cartographic representation.
         * @param ellipsoid  (Optional) The ellipsoid on which the position lies.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian(cartesian: Cartesian3, ellipsoid?: Ellipsoid, result?: Cartographic): Cartographic;
        /**
         * Duplicates a Cartographic instance.
         * @param cartographic  (Required) The cartographic to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(cartographic: Cartographic, result?: Cartographic): Cartographic;
        /**
         * Compares the provided cartographics componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first cartographic.
         * @param right  (Optional) The second cartographic.
         */
        static equals(left?: Cartographic, right?: Cartographic): Boolean;
        /**
         * Compares the provided cartographics componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param left  (Optional) The first cartographic.
         * @param right  (Optional) The second cartographic.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        static equalsEpsilon(left?: Cartographic, right?: Cartographic, epsilon?: number): Boolean;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Cartographic): Cartographic;
        /**
         * Compares the provided against this cartographic componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The second cartographic.
         */
        equals(right?: Cartographic): Boolean;
        /**
         * Compares the provided against this cartographic componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The second cartographic.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(right?: Cartographic, epsilon?: number): Boolean;
        /**
         * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
         */
        toString(): string;
    }
    /**
     * A Catmull-Rom spline is a cubic spline where the tangent at control points,
except the first and last, are computed using the previous and next control points.
Catmull-Rom splines are in the class C<sup>1</sup>.
     */
    class CatmullRomSpline {
        /**
         * A Catmull-Rom spline is a cubic spline where the tangent at control points,
except the first and last, are computed using the previous and next control points.
Catmull-Rom splines are in the class C<sup>1</sup>.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICatmullRomSplineOptions);
        /**
         * An array of times for the control points.
         */
        times: number[];
        /**
         * An array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
        /**
         * The tangent at the first control point.
         */
        firstTangent: Cartesian3;
        /**
         * The tangent at the last control point.
         */
        lastTangent: Cartesian3;
        /**
         * Finds an index <code>i</code> in <code>times</code> such that the parameter
<code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
         * @param time  (Required) The time.
         */
        findTimeInterval(time: number): number;
        /**
         * Evaluates the curve at a given time.
         * @param time  (Required) The time at which to evaluate the curve.
         * @param result  (Optional) The object onto which to store the result.
         */
        evaluate(time: number, result?: Cartesian3): Cartesian3;
    }
    /**
     * A {@link TerrainProvider} that access terrain data in a Cesium terrain format.
The format is described on the
{@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Cesium-Terrain-Server|Cesium wiki}.
     */
    class CesiumTerrainProvider {
        /**
         * A {@link TerrainProvider} that access terrain data in a Cesium terrain format.
The format is described on the
{@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Cesium-Terrain-Server|Cesium wiki}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICesiumTerrainProviderOptions);
        /**
         * Requests the geometry for a given tile.  This function should not be called before
{@link CesiumTerrainProvider#ready} returns true.  The result must include terrain data and
may optionally include a water mask and an indication of which child tiles are available.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         * @param throttleRequests  (Optional) True if the number of simultaneous requests should be limited,
                 or false if the request should be initiated regardless of the number of requests
                 already in progress.
         */
        requestTileGeometry(x: number, y: number, level: number, throttleRequests?: Boolean): Promise<TerrainData>;
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
the source of the terrain.  This function should not be called before {@link CesiumTerrainProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link CesiumTerrainProvider#ready} returns true.
         */
        tilingScheme: GeographicTilingScheme;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
indicates which areas of the globe are water rather than land, so they can be rendered
as a reflective surface with animated waves.  This function should not be
called before {@link CesiumTerrainProvider#ready} returns true.
         */
        hasWaterMask: Boolean;
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
This function should not be called before {@link CesiumTerrainProvider#ready} returns true.
         */
        hasVertexNormals: Boolean;
        /**
         * Boolean flag that indicates if the client should request vertex normals from the server.
Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and
if the server provides vertex normals.
         */
        requestVertexNormals: Boolean;
        /**
         * Boolean flag that indicates if the client should request a watermask from the server.
Watermask data is appended to the standard tile mesh data only if the client requests the watermask and
if the server provides a watermask.
         */
        requestWaterMask: Boolean;
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.
         * @param level  (Required) The tile level for which to get the maximum geometric error.
         */
        getLevelMaximumGeometricError(level: number): number;
        /**
         * Determines whether data for a tile is available to be loaded.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        getTileDataAvailable(x: number, y: number, level: number): Boolean;
    }
    /**
     * A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     */
    class CircleGeometry {
        /**
         * A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICircleGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CircleGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CircleGeometry): CircleGeometry;
        /**
         * Computes the geometric representation of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param circleGeometry  (Required) A description of the circle.
         */
        static createGeometry(circleGeometry: CircleGeometry): Geometry;
    }
    /**
     * A description of the outline of a circle on the ellipsoid.
     */
    class CircleOutlineGeometry {
        /**
         * A description of the outline of a circle on the ellipsoid.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICircleOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CircleOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CircleOutlineGeometry): CircleOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param circleGeometry  (Required) A description of the circle.
         */
        static createGeometry(circleGeometry: CircleOutlineGeometry): Geometry;
    }
    /**
     * A simple clock for keeping track of simulated time.
     */
    class Clock {
        /**
         * A simple clock for keeping track of simulated time.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IClockOptions);
        /**
         * The start time of the clock.
         */
        startTime: JulianDate;
        /**
         * The stop time of the clock.
         */
        stopTime: JulianDate;
        /**
         * Determines how the clock should behave when
{@link Clock#startTime} or {@link Clock#stopTime}
is reached.
         */
        clockRange: number;
        /**
         * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered,
for example.  The clock will only advance time when both
{@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
         */
        canAnimate: Boolean;
        /**
         * An {@link Event} that is fired whenever {@link Clock#tick} is called.
         */
        onTick: Event;
        /**
         * The current time.
Changing this property will change
{@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
{@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
         */
        currentTime: JulianDate;
        /**
         * Gets or sets how much time advances when {@link Clock#tick} is called. Negative values allow for advancing backwards.
If {@link Clock#clockStep} is set to {@link ClockStep.TICK_DEPENDENT}, this is the number of seconds to advance.
If {@link Clock#clockStep} is set to {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}, this value is multiplied by the
elapsed system time since the last call to {@link Clock#tick}.
Changing this property will change
{@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
{@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
         */
        multiplier: number;
        /**
         * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
Changing this property to {@link ClockStep.SYSTEM_CLOCK} will set
{@link Clock#multiplier} to 1.0, {@link Clock#shouldAnimate} to true, and
{@link Clock#currentTime} to the current system clock time.
         */
        clockStep: number;
        /**
         * Indicates whether {@link Clock#tick} should attempt to advance time.
The clock will only advance time when both
{@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
Changing this property will change
{@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
{@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
         */
        shouldAnimate: Boolean;
        /**
         * Advances the clock from the current time based on the current configuration options.
tick should be called every frame, regardless of whether animation is taking place
or not.  To control animation, use the {@link Clock#shouldAnimate} property.
         */
        tick(): JulianDate;
    }
    /**
     * A color, specified using red, green, blue, and alpha values,
which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     */
    class Color {
        /**
         * A color, specified using red, green, blue, and alpha values,
which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
         * @param red  (Optional) The red component.
         * @param green  (Optional) The green component.
         * @param blue  (Optional) The blue component.
         * @param alpha  (Optional) The alpha component.
         */
        constructor(red?: number, green?: number, blue?: number, alpha?: number);
        /**
         * The red component.
         */
        red: number;
        /**
         * The green component.
         */
        green: number;
        /**
         * The blue component.
         */
        blue: number;
        /**
         * The alpha component.
         */
        alpha: number;
        /**
         * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
         * @param cartesian  (Required) The source cartesian.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian4(cartesian: Cartesian4, result?: number): number;
        /**
         * Creates a new Color specified using red, green, blue, and alpha values
that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
         * @param red  (Optional) The red component.
         * @param green  (Optional) The green component.
         * @param blue  (Optional) The blue component.
         * @param alpha  (Optional) The alpha component.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromBytes(red?: number, green?: number, blue?: number, alpha?: number, result?: number): number;
        /**
         * Creates a new Color that has the same red, green, and blue components
of the specified color, but with the specified alpha value.
         * @param color  (Required) The base color
         * @param alpha  (Required) The new alpha component.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromAlpha(color: number, alpha: number, result?: number): number;
        /**
         * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
of the system.
         * @param rgba  (Required) A single numeric unsigned 32-bit RGBA value.
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        static fromRgba(rgba: number, result?: number): number;
        /**
         * Creates a Color instance from hue, saturation, and lightness.
         * @param hue  (Optional) The hue angle 0...1
         * @param saturation  (Optional) The saturation value 0...1
         * @param lightness  (Optional) The lightness value 0...1
         * @param alpha  (Optional) The alpha component 0...1
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        static fromHsl(hue?: number, saturation?: number, lightness?: number, alpha?: number, result?: number): number;
        /**
         * Creates a random color using the provided options. For reproducible random colors, you should
call {@link CesiumMath#setRandomNumberSeed} once at the beginning of your application.
         * @param options  (Optional) Object with the following properties:
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        static fromRandom(options?: Color.IColorFromRandomOptions, result?: number): number;
        /**
         * Creates a Color instance from a CSS color value.
         * @param color  (Required) The CSS color value in #rgb, #rrggbb, rgb(), rgba(), hsl(), or hsla() format.
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        static fromCssColorString(color: string, result?: number): number;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: number, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: number): number;
        /**
         * Converts a 'byte' color component in the range of 0 to 255 into
a 'float' color component in the range of 0 to 1.0.
         * @param number  (Required) The number to be converted.
         */
        static byteToFloat(number: number): number;
        /**
         * Converts a 'float' color component in the range of 0 to 1.0 into
a 'byte' color component in the range of 0 to 255.
         * @param number  (Required) The number to be converted.
         */
        static floatToByte(number: number): number;
        /**
         * Duplicates a Color.
         * @param color  (Required) The Color to duplicate.
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        static clone(color: number, result?: number): number;
        /**
         * Returns true if the first Color equals the second color.
         * @param left  (Required) The first Color to compare for equality.
         * @param right  (Required) The second Color to compare for equality.
         */
        static equals(left: number, right: number): Boolean;
        /**
         * Returns a duplicate of a Color instance.
         * @param result  (Optional) The object to store the result in, if undefined a new instance will be created.
         */
        clone(result?: number): number;
        /**
         * Returns true if this Color equals other.
         * @param other  (Required) The Color to compare for equality.
         */
        equals(other: number): Boolean;
        /**
         * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
         * @param other  (Required) The Color to compare for equality.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(other: number, epsilon?: number): Boolean;
        /**
         * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
         */
        toString(): string;
        /**
         * Creates a string containing the CSS color value for this color.
         */
        toCssColorString(): string;
        /**
         * Converts this color to an array of red, green, blue, and alpha values
that are in the range of 0 to 255.
         * @param result  (Optional) The array to store the result in, if undefined a new instance will be created.
         */
        toBytes(result?: number[]): number[];
        /**
         * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
of the system.
         */
        toRgba(): number;
        /**
         * Brightens this color by the provided magnitude.
         * @param magnitude  (Required) A positive number indicating the amount to brighten.
         * @param result  (Required) The object onto which to store the result.
         */
        brighten(magnitude: number, result: number): number;
        /**
         * Darkens this color by the provided magnitude.
         * @param magnitude  (Required) A positive number indicating the amount to darken.
         * @param result  (Required) The object onto which to store the result.
         */
        darken(magnitude: number, result: number): number;
        /**
         * Creates a new Color that has the same red, green, and blue components
as this Color, but with the specified alpha value.
         * @param alpha  (Required) The new alpha component.
         * @param result  (Optional) The object onto which to store the result.
         */
        withAlpha(alpha: number, result?: number): number;
        /**
         * Computes the componentwise sum of two Colors.
         * @param left  (Required) The first Color.
         * @param right  (Required) The second Color.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: number, right: number, result: number): number;
        /**
         * Computes the componentwise difference of two Colors.
         * @param left  (Required) The first Color.
         * @param right  (Required) The second Color.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: number, right: number, result: number): number;
        /**
         * Computes the componentwise product of two Colors.
         * @param left  (Required) The first Color.
         * @param right  (Required) The second Color.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiply(left: number, right: number, result: number): number;
        /**
         * Computes the componentwise quotient of two Colors.
         * @param left  (Required) The first Color.
         * @param right  (Required) The second Color.
         * @param result  (Required) The object onto which to store the result.
         */
        static divide(left: number, right: number, result: number): number;
        /**
         * Computes the componentwise modulus of two Colors.
         * @param left  (Required) The first Color.
         * @param right  (Required) The second Color.
         * @param result  (Required) The object onto which to store the result.
         */
        static mod(left: number, right: number, result: number): number;
        /**
         * Multiplies the provided Color componentwise by the provided scalar.
         * @param color  (Required) The Color to be scaled.
         * @param scalar  (Required) The scalar to multiply with.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(color: number, scalar: number, result: number): number;
        /**
         * Divides the provided Color componentwise by the provided scalar.
         * @param color  (Required) The Color to be divided.
         * @param scalar  (Required) The scalar to divide with.
         * @param result  (Required) The object onto which to store the result.
         */
        static divideByScalar(color: number, scalar: number, result: number): number;
    }
    /**
     * Value and type information for per-instance geometry color.
     */
    class ColorGeometryInstanceAttribute {
        /**
         * Value and type information for per-instance geometry color.
         * @param red  (Optional) The red component.
         * @param green  (Optional) The green component.
         * @param blue  (Optional) The blue component.
         * @param alpha  (Optional) The alpha component.
         */
        constructor(red?: number, green?: number, blue?: number, alpha?: number);
        /**
         * The values for the attributes stored in a typed array.
         */
        value: Uint8Array;
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
{@link ColorGeometryInstanceAttribute#value}.
         */
        componentDatatype: number;
        /**
         * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
         */
        componentsPerAttribute: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
indicate that the components should be mapped to the range [0, 1] (unsigned)
or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         */
        normalize: Boolean;
        /**
         * Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.
         * @param color  (Required) The color.
         */
        static fromColor(color: number): ColorGeometryInstanceAttribute;
        /**
         * Converts a color to a typed array that can be used to assign a color attribute.
         * @param color  (Required) The color.
         * @param result  (Optional) The array to store the result in, if undefined a new instance will be created.
         */
        static toValue(color: number, result?: Uint8Array): Uint8Array;
        /**
         * Compares the provided ColorGeometryInstanceAttributes and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first ColorGeometryInstanceAttribute.
         * @param right  (Optional) The second ColorGeometryInstanceAttribute.
         */
        static equals(left?: ColorGeometryInstanceAttribute, right?: ColorGeometryInstanceAttribute): Boolean;
    }
    /**
     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     */
    class CorridorGeometry {
        /**
         * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICorridorGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CorridorGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CorridorGeometry): CorridorGeometry;
        /**
         * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
         * @param corridorGeometry  (Required) A description of the corridor.
         */
        static createGeometry(corridorGeometry: CorridorGeometry): Geometry;
    }
    /**
     * A description of a corridor outline.
     */
    class CorridorOutlineGeometry {
        /**
         * A description of a corridor outline.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICorridorOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CorridorOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CorridorOutlineGeometry): CorridorOutlineGeometry;
        /**
         * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
         * @param corridorOutlineGeometry  (Required) A description of the corridor.
         */
        static createGeometry(corridorOutlineGeometry: CorridorOutlineGeometry): Geometry;
    }
    /**
     * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.
     */
    class Credit {
        /**
         * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.
         * @param text  (Optional) The text to be displayed on the screen if no imageUrl is specified.
         * @param imageUrl  (Optional) The source location for an image
         * @param link  (Optional) A URL location for which the credit will be hyperlinked
         */
        constructor(text?: string, imageUrl?: string, link?: string);
        /**
         * The credit text
         */
        text: string;
        /**
         * The source location for the image.
         */
        imageUrl: string;
        /**
         * A URL location for the credit hyperlink
         */
        link: string;
        /**
         * Returns true if the credit has an imageUrl
         */
        hasImage(): Boolean;
        /**
         * Returns true if the credit has a link
         */
        hasLink(): Boolean;
        /**
         * Returns true if the credits are equal
         * @param left  (Required) The first credit
         * @param right  (Required) The second credit
         */
        static equals(left: Credit, right: Credit): Boolean;
        /**
         * Returns true if the credits are equal
         * @param credits  (Required) The credit to compare to.
         */
        equals(credits: Credit): Boolean;
    }
    /**
     * A description of a cylinder.
     */
    class CylinderGeometry {
        /**
         * A description of a cylinder.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICylinderGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CylinderGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CylinderGeometry): CylinderGeometry;
        /**
         * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
         * @param cylinderGeometry  (Required) A description of the cylinder.
         */
        static createGeometry(cylinderGeometry: CylinderGeometry): Geometry;
    }
    /**
     * A description of the outline of a cylinder.
     */
    class CylinderOutlineGeometry {
        /**
         * A description of the outline of a cylinder.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ICylinderOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: CylinderOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: CylinderOutlineGeometry): CylinderOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.
         * @param cylinderGeometry  (Required) A description of the cylinder outline.
         */
        static createGeometry(cylinderGeometry: CylinderOutlineGeometry): Geometry;
    }
    /**
     * A simple proxy that appends the desired resource as the sole query parameter
to the given proxy URL.
     */
    class DefaultProxy {
        /**
         * A simple proxy that appends the desired resource as the sole query parameter
to the given proxy URL.
         * @param proxy  (Required) The proxy URL that will be used to requests all resources.
         */
        constructor(proxy: string);
        /**
         * Get the final URL to use to request a given resource.
         * @param resource  (Required) The resource to request.
         */
        getURL(resource: string): string;
    }
    /**
     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
argument out of range, etc.  This exception should only be thrown during development;
it usually indicates a bug in the calling code.  This exception should never be
caught; instead the calling code should strive not to generate it.
<br /><br />
On the other hand, a {@link RuntimeError} indicates an exception that may
be thrown at runtime, e.g., out of memory, that the calling code should be prepared
to catch.
     */
    class DeveloperError extends Error {
        /**
         * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
argument out of range, etc.  This exception should only be thrown during development;
it usually indicates a bug in the calling code.  This exception should never be
caught; instead the calling code should strive not to generate it.
<br /><br />
On the other hand, a {@link RuntimeError} indicates an exception that may
be thrown at runtime, e.g., out of memory, that the calling code should be prepared
to catch.
         * @param message  (Optional) The error message for this exception.
         */
        constructor(message?: string);
        /**
         * 'DeveloperError' indicating that this exception was thrown due to a developer error.
         */
        name: string;
        /**
         * The explanation for why this exception was thrown.
         */
        message: string;
        /**
         * The stack trace of this exception, if available.
         */
        stack: string;
    }
    /**
     * Determines visibility based on the distance to the camera.
     */
    class DistanceDisplayCondition {
        /**
         * Determines visibility based on the distance to the camera.
         * @param near  (Optional) The smallest distance in the interval where the object is visible.
         * @param far  (Optional) The largest distance in the interval where the object is visible.
         */
        constructor(near?: number, far?: number);
        /**
         * The smallest distance in the interval where the object is visible.
         */
        near: number;
        /**
         * The largest distance in the interval where the object is visible.
         */
        far: number;
        /**
         * Determines if two distance display conditions are equal.
         * @param left  (Required) A distance display condition.
         * @param right  (Required) Another distance display condition.
         */
        static equals(left: DistanceDisplayCondition, right: DistanceDisplayCondition): Boolean;
        /**
         * Duplicates a distance display condition instance.
         * @param value  (Optional) The distance display condition to duplicate.
         * @param result  (Optional) The result onto which to store the result.
         */
        static clone(value?: DistanceDisplayCondition, result?: DistanceDisplayCondition): DistanceDisplayCondition;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The result onto which to store the result.
         */
        clone(result?: DistanceDisplayCondition): DistanceDisplayCondition;
        /**
         * Determines if this distance display condition is equal to another.
         * @param other  (Required) Another distance display condition.
         */
        equals(other: DistanceDisplayCondition): Boolean;
    }
    /**
     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
     */
    class DistanceDisplayConditionGeometryInstanceAttribute {
        /**
         * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
         * @param near  (Optional) The near distance.
         * @param far  (Optional) The far distance.
         */
        constructor(near?: number, far?: number);
        /**
         * The values for the attributes stored in a typed array.
         */
        value: Float32Array;
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
{@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
         */
        componentDatatype: number;
        /**
         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
         */
        componentsPerAttribute: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
indicate that the components should be mapped to the range [0, 1] (unsigned)
or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         */
        normalize: Boolean;
        /**
         * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.
         * @param distanceDisplayCondition  (Required) The distance display condition.
         */
        static fromDistanceDisplayCondition(distanceDisplayCondition: DistanceDisplayCondition): DistanceDisplayConditionGeometryInstanceAttribute;
        /**
         * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.
         * @param distanceDisplayCondition  (Required) The distance display condition value.
         * @param result  (Optional) The array to store the result in, if undefined a new instance will be created.
         */
        static toValue(distanceDisplayCondition: DistanceDisplayCondition, result?: Float32Array): Float32Array;
    }
    /**
     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     */
    class EllipseGeometry {
        /**
         * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IEllipseGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: EllipseGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: EllipseGeometry): EllipseGeometry;
        /**
         * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param ellipseGeometry  (Required) A description of the ellipse.
         */
        static createGeometry(ellipseGeometry: EllipseGeometry): Geometry;
    }
    /**
     * A description of the outline of an ellipse on an ellipsoid.
     */
    class EllipseOutlineGeometry {
        /**
         * A description of the outline of an ellipse on an ellipsoid.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IEllipseOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: EllipseOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: EllipseOutlineGeometry): EllipseOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param ellipseGeometry  (Required) A description of the ellipse.
         */
        static createGeometry(ellipseGeometry: EllipseOutlineGeometry): Geometry;
    }
    /**
     * A quadratic surface defined in Cartesian coordinates by the equation
<code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
by Cesium to represent the shape of planetary bodies.

Rather than constructing this object directly, one of the provided
constants is normally used.
     */
    class Ellipsoid {
        /**
         * A quadratic surface defined in Cartesian coordinates by the equation
<code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
by Cesium to represent the shape of planetary bodies.

Rather than constructing this object directly, one of the provided
constants is normally used.
         * @param x  (Optional) The radius in the x direction.
         * @param y  (Optional) The radius in the y direction.
         * @param z  (Optional) The radius in the z direction.
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * Gets the radii of the ellipsoid.
         */
        radii: Cartesian3;
        /**
         * Gets the squared radii of the ellipsoid.
         */
        radiiSquared: Cartesian3;
        /**
         * Gets the radii of the ellipsoid raise to the fourth power.
         */
        radiiToTheFourth: Cartesian3;
        /**
         * Gets one over the radii of the ellipsoid.
         */
        oneOverRadii: Cartesian3;
        /**
         * Gets one over the squared radii of the ellipsoid.
         */
        oneOverRadiiSquared: Cartesian3;
        /**
         * Gets the minimum radius of the ellipsoid.
         */
        minimumRadius: number;
        /**
         * Gets the maximum radius of the ellipsoid.
         */
        maximumRadius: number;
        /**
         * Duplicates an Ellipsoid instance.
         * @param ellipsoid  (Required) The ellipsoid to duplicate.
         * @param result  (Optional) The object onto which to store the result, or undefined if a new
                   instance should be created.
         */
        static clone(ellipsoid: Ellipsoid, result?: Ellipsoid): Ellipsoid;
        /**
         * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
         * @param radii  (Optional) The ellipsoid's radius in the x, y, and z directions.
         */
        static fromCartesian3(radii?: Cartesian3): Ellipsoid;
        /**
         * Duplicates an Ellipsoid instance.
         * @param result  (Optional) The object onto which to store the result, or undefined if a new
                   instance should be created.
         */
        clone(result?: Ellipsoid): Ellipsoid;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Ellipsoid, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Ellipsoid): Ellipsoid;
        /**
         * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
         * @param cartesian  (Required) The Cartesian for which to to determine the geocentric normal.
         * @param result  (Optional) The object onto which to store the result.
         */
        geocentricSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
         * @param cartographic  (Required) The cartographic position for which to to determine the geodetic normal.
         * @param result  (Optional) The object onto which to store the result.
         */
        geodeticSurfaceNormalCartographic(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
        /**
         * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
         * @param cartesian  (Required) The Cartesian position for which to to determine the surface normal.
         * @param result  (Optional) The object onto which to store the result.
         */
        geodeticSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Converts the provided cartographic to Cartesian representation.
         * @param cartographic  (Required) The cartographic position.
         * @param result  (Optional) The object onto which to store the result.
         */
        cartographicToCartesian(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
        /**
         * Converts the provided array of cartographics to an array of Cartesians.
         * @param cartographics  (Required) An array of cartographic positions.
         * @param result  (Optional) The object onto which to store the result.
         */
        cartographicArrayToCartesianArray(cartographics: Cartographic[], result?: Cartesian3[]): Cartesian3[];
        /**
         * Converts the provided cartesian to cartographic representation.
The cartesian is undefined at the center of the ellipsoid.
         * @param cartesian  (Required) The Cartesian position to convert to cartographic representation.
         * @param result  (Optional) The object onto which to store the result.
         */
        cartesianToCartographic(cartesian: Cartesian3, result?: Cartographic): Cartographic;
        /**
         * Converts the provided array of cartesians to an array of cartographics.
         * @param cartesians  (Required) An array of Cartesian positions.
         * @param result  (Optional) The object onto which to store the result.
         */
        cartesianArrayToCartographicArray(cartesians: Cartesian3[], result?: Cartographic[]): Cartographic[];
        /**
         * Scales the provided Cartesian position along the geodetic surface normal
so that it is on the surface of this ellipsoid.  If the position is
at the center of the ellipsoid, this function returns undefined.
         * @param cartesian  (Required) The Cartesian position to scale.
         * @param result  (Optional) The object onto which to store the result.
         */
        scaleToGeodeticSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Scales the provided Cartesian position along the geocentric surface normal
so that it is on the surface of this ellipsoid.
         * @param cartesian  (Required) The Cartesian position to scale.
         * @param result  (Optional) The object onto which to store the result.
         */
        scaleToGeocentricSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
its components by the result of {@link Ellipsoid#oneOverRadii}.
         * @param position  (Required) The position to transform.
         * @param result  (Optional) The position to which to copy the result, or undefined to create and
       return a new instance.
         */
        transformPositionToScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
its components by the result of {@link Ellipsoid#radii}.
         * @param position  (Required) The position to transform.
         * @param result  (Optional) The position to which to copy the result, or undefined to create and
       return a new instance.
         */
        transformPositionFromScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The other Ellipsoid.
         */
        equals(right?: Ellipsoid): Boolean;
        /**
         * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
         */
        toString(): string;
    }
    /**
     * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
     */
    class EllipsoidGeodesic {
        /**
         * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
         * @param start  (Optional) The initial planetodetic point on the path.
         * @param end  (Optional) The final planetodetic point on the path.
         * @param ellipsoid  (Optional) The ellipsoid on which the geodesic lies.
         */
        constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);
        /**
         * Gets the ellipsoid.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the surface distance between the start and end point
         */
        surfaceDistance: number;
        /**
         * Gets the initial planetodetic point on the path.
         */
        start: Cartographic;
        /**
         * Gets the final planetodetic point on the path.
         */
        end: Cartographic;
        /**
         * Gets the heading at the initial point.
         */
        startHeading: number;
        /**
         * Gets the heading at the final point.
         */
        endHeading: number;
        /**
         * Sets the start and end points of the geodesic
         * @param start  (Required) The initial planetodetic point on the path.
         * @param end  (Required) The final planetodetic point on the path.
         */
        setEndPoints(start: Cartographic, end: Cartographic): void;
        /**
         * Provides the location of a point at the indicated portion along the geodesic.
         * @param fraction  (Required) The portion of the distance between the initial and final points.
         */
        interpolateUsingFraction(fraction: number): Cartographic;
        /**
         * Provides the location of a point at the indicated distance along the geodesic.
         * @param distance  (Required) The distance from the inital point to the point of interest along the geodesic
         */
        interpolateUsingSurfaceDistance(distance: number): Cartographic;
    }
    /**
     * A description of an ellipsoid centered at the origin.
     */
    class EllipsoidGeometry {
        /**
         * A description of an ellipsoid centered at the origin.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipsoidGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: EllipsoidGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: EllipsoidGeometry): EllipsoidGeometry;
        /**
         * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param ellipsoidGeometry  (Required) A description of the ellipsoid.
         */
        static createGeometry(ellipsoidGeometry: EllipsoidGeometry): Geometry;
    }
    /**
     * A description of the outline of an ellipsoid centered at the origin.
     */
    class EllipsoidOutlineGeometry {
        /**
         * A description of the outline of an ellipsoid centered at the origin.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipsoidOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: EllipsoidOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: EllipsoidOutlineGeometry): EllipsoidOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.
         * @param ellipsoidGeometry  (Required) A description of the ellipsoid outline.
         */
        static createGeometry(ellipsoidGeometry: EllipsoidOutlineGeometry): Geometry;
    }
    /**
     * A plane tangent to the provided ellipsoid at the provided origin.
If origin is not on the surface of the ellipsoid, it's surface projection will be used.
If origin is at the center of the ellipsoid, an exception will be thrown.
     */
    class EllipsoidTangentPlane {
        /**
         * A plane tangent to the provided ellipsoid at the provided origin.
If origin is not on the surface of the ellipsoid, it's surface projection will be used.
If origin is at the center of the ellipsoid, an exception will be thrown.
         * @param origin  (Required) The point on the surface of the ellipsoid where the tangent plane touches.
         * @param ellipsoid  (Optional) The ellipsoid to use.
         */
        constructor(origin: Cartesian3, ellipsoid?: Ellipsoid);
        /**
         * Gets the ellipsoid.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the origin.
         */
        origin: Cartesian3;
        /**
         * Gets the plane which is tangent to the ellipsoid.
         */
        plane: Plane;
        /**
         * Gets the local X-axis (east) of the tangent plane.
         */
        xAxis: Cartesian3;
        /**
         * Gets the local Y-axis (north) of the tangent plane.
         */
        yAxis: Cartesian3;
        /**
         * Creates a new instance from the provided ellipsoid and the center
point of the provided Cartesians.
         * @param ellipsoid  (Required) The ellipsoid to use.
         * @param cartesians  (Required) The list of positions surrounding the center point.
         */
        static fromPoints(ellipsoid: Ellipsoid, cartesians: Cartesian3): void;
        /**
         * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.
         * @param cartesian  (Required) The point to project.
         * @param result  (Optional) The object onto which to store the result.
         */
        projectPointOntoPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
        /**
         * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.
The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.
         * @param cartesians  (Required) The array of points to project.
         * @param result  (Optional) The array of Cartesian2 instances onto which to store results.
         */
        projectPointsOntoPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
        /**
         * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.
         * @param cartesian  (Required) The point to project.
         * @param result  (Optional) The object onto which to store the result.
         */
        projectPointToNearestOnPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
        /**
         * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.
         * @param cartesians  (Required) The array of points to project.
         * @param result  (Optional) The array of Cartesian2 instances onto which to store results.
         */
        projectPointsToNearestOnPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
        /**
         * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
         * @param cartesians  (Required) The array of points to project.
         * @param result  (Optional) The array of Cartesian3 instances onto which to store results.
         */
        projectPointsOntoEllipsoid(cartesians: Cartesian2[], result?: Cartesian3[]): Cartesian3[];
    }
    /**
     * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
surface.
     */
    class EllipsoidTerrainProvider {
        /**
         * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
surface.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipsoidTerrainProviderOptions);
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
the source of the terrain.  This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link EllipsoidTerrainProvider#ready} returns true.
         */
        tilingScheme: GeographicTilingScheme;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
indicates which areas of the globe are water rather than land, so they can be rendered
as a reflective surface with animated waves.  This function should not be
called before {@link EllipsoidTerrainProvider#ready} returns true.
         */
        hasWaterMask: Boolean;
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
         */
        hasVertexNormals: Boolean;
        /**
         * Requests the geometry for a given tile.  This function should not be called before
{@link TerrainProvider#ready} returns true.  The result includes terrain
data and indicates that all child tiles are available.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         * @param throttleRequests  (Optional) True if the number of simultaneous requests should be limited,
                 or false if the request should be initiated regardless of the number of requests
                 already in progress.
         */
        requestTileGeometry(x: number, y: number, level: number, throttleRequests?: Boolean): Promise<TerrainData>;
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.
         * @param level  (Required) The tile level for which to get the maximum geometric error.
         */
        getLevelMaximumGeometricError(level: number): number;
        /**
         * Determines whether data for a tile is available to be loaded.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        getTileDataAvailable(x: number, y: number, level: number): Boolean;
    }
    /**
     * A generic utility class for managing subscribers for a particular event.
This class is usually instantiated inside of a container class and
exposed as a property for others to subscribe to.
     */
    class Event {
        /**
         * A generic utility class for managing subscribers for a particular event.
This class is usually instantiated inside of a container class and
exposed as a property for others to subscribe to.
         */
        constructor();
        /**
         * The number of listeners currently subscribed to the event.
         */
        numberOfListeners: number;
        /**
         * Registers a callback function to be executed whenever the event is raised.
An optional scope can be provided to serve as the <code>this</code> pointer
in which the function will execute.
         * @param listener  (Required) The function to be executed when the event is raised.
         * @param scope  (Optional) An optional object scope to serve as the <code>this</code>
       pointer in which the listener function will execute.
         */
        addEventListener(listener: Function, scope?: any): Event.RemoveCallback;
        /**
         * Unregisters a previously registered callback.
         * @param listener  (Required) The function to be unregistered.
         * @param scope  (Optional) The scope that was originally passed to addEventListener.
         */
        removeEventListener(listener: Function, scope?: any): Boolean;
        /**
         * Raises the event by calling each registered listener with all supplied arguments.
         * @param arg1  (Required) This method takes any number of parameters and passes them through to the listener functions.
         */
        raiseEvent(arg1: any): void;
    }
    /**
     * A convenience object that simplifies the common pattern of attaching event listeners
to several events, then removing all those listeners at once later, for example, in
a destroy method.
     */
    class EventHelper {
        /**
         * A convenience object that simplifies the common pattern of attaching event listeners
to several events, then removing all those listeners at once later, for example, in
a destroy method.
         */
        constructor();
        /**
         * Adds a listener to an event, and records the registration to be cleaned up later.
         * @param event  (Required) The event to attach to.
         * @param listener  (Required) The function to be executed when the event is raised.
         * @param scope  (Optional) An optional object scope to serve as the <code>this</code>
       pointer in which the listener function will execute.
         */
        add(event: Event, listener: Function, scope?: any): EventHelper.RemoveCallback;
        /**
         * Unregisters all previously added listeners.
         */
        removeAll(): void;
    }
    /**
     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
them by the {@link Ellipsoid#maximumRadius}.  This projection
is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
is also known as EPSG:4326.
     */
    class GeographicProjection {
        /**
         * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
them by the {@link Ellipsoid#maximumRadius}.  This projection
is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
is also known as EPSG:4326.
         * @param ellipsoid  (Optional) The ellipsoid.
         */
        constructor(ellipsoid?: Ellipsoid);
        /**
         * Gets the {@link Ellipsoid}.
         */
        ellipsoid: Ellipsoid;
        /**
         * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
ellipsoid.  Z is the unmodified height.
         * @param cartographic  (Required) The coordinates to project.
         * @param result  (Optional) An instance into which to copy the result.  If this parameter is
       undefined, a new instance is created and returned.
         */
        project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
        /**
         * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
         * @param cartesian  (Required) The Cartesian position to unproject with height (z) in meters.
         * @param result  (Optional) An instance into which to copy the result.  If this parameter is
       undefined, a new instance is created and returned.
         */
        unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
    }
    /**
     * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
longitude and latitude are directly mapped to X and Y.  This projection is commonly
known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
     */
    class GeographicTilingScheme {
        /**
         * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
longitude and latitude are directly mapped to X and Y.  This projection is commonly
known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IGeographicTilingSchemeOptions);
        /**
         * Gets the ellipsoid that is tiled by this tiling scheme.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the rectangle, in radians, covered by this tiling scheme.
         */
        rectangle: Rectangle;
        /**
         * Gets the map projection used by this tiling scheme.
         */
        projection: MapProjection;
        /**
         * Gets the total number of tiles in the X direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfXTilesAtLevel(level: number): number;
        /**
         * Gets the total number of tiles in the Y direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfYTilesAtLevel(level: number): number;
        /**
         * Transforms an rectangle specified in geodetic radians to the native coordinate system
of this tiling scheme.
         * @param rectangle  (Required) The rectangle to transform.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Converts tile x, y coordinates and level to an rectangle expressed in the native coordinates
of the tiling scheme.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Calculates the tile x, y coordinates of the tile containing
a given cartographic position.
         * @param position  (Required) The position.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
    }
    /**
     * A geometry representation with attributes forming vertices and optional index data
defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
be created from many heterogeneous - in many cases - geometries for performance.
<p>
Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
</p>
     */
    class Geometry {
        /**
         * A geometry representation with attributes forming vertices and optional index data
defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
be created from many heterogeneous - in many cases - geometries for performance.
<p>
Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
</p>
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGeometryOptions);
        /**
         * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a
{@link GeometryAttribute} containing the attribute's data.
<p>
Attributes are always stored non-interleaved in a Geometry.
</p>
<p>
There are reserved attribute names with well-known semantics.  The following attributes
are created by a Geometry (depending on the provided {@link VertexFormat}.
<ul>
   <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>
   <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>
   <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>
   <li><code>binormal</code> - Binormal (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#binormal}.</li>
   <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>
</ul>
</p>
<p>
The following attribute names are generally not created by a Geometry, but are added
to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare
the geometry for rendering.
<ul>
   <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>
   <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>
</ul>
</p>
         */
        attributes: GeometryAttributes;
        /**
         * Optional index data that - along with {@link Geometry#primitiveType} -
determines the primitives in the geometry.
         */
        indices: any[];
        /**
         * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},
but can varying based on the specific geometry.
         */
        primitiveType: number;
        /**
         * An optional bounding sphere that fully encloses the geometry.  This is
commonly used for culling.
         */
        boundingSphere: BoundingSphere;
        /**
         * Computes the number of vertices in a geometry.  The runtime is linear with
respect to the number of attributes in a vertex, not the number of vertices.
         * @param geometry  (Required) The geometry.
         */
        static computeNumberOfVertices(geometry: Geometry): number;
    }
    /**
     * Values and type information for geometry attributes.  A {@link Geometry}
generally contains one or more attributes.  All attributes together form
the geometry's vertices.
     */
    class GeometryAttribute {
        /**
         * Values and type information for geometry attributes.  A {@link Geometry}
generally contains one or more attributes.  All attributes together form
the geometry's vertices.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IGeometryAttributeOptions);
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
{@link GeometryAttribute#values}.
         */
        componentDatatype: number;
        /**
         * A number between 1 and 4 that defines the number of components in an attributes.
For example, a position attribute with x, y, and z components would have 3 as
shown in the code example.
         */
        componentsPerAttribute: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
indicate that the components should be mapped to the range [0, 1] (unsigned)
or [-1, 1] (signed) when they are accessed as floating-point for rendering.
<p>
This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
</p>
         */
        normalize: Boolean;
        /**
         * The values for the attributes stored in a typed array.  In the code example,
every three elements in <code>values</code> defines one attributes since
<code>componentsPerAttribute</code> is 3.
         */
        values: TypedArray;
    }
    /**
     * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a
{@link GeometryAttribute} containing the attribute's data.
<p>
Attributes are always stored non-interleaved in a Geometry.
</p>
     */
    class GeometryAttributes {
        /**
         * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a
{@link GeometryAttribute} containing the attribute's data.
<p>
Attributes are always stored non-interleaved in a Geometry.
</p>
         */
        constructor();
        /**
         * The 3D position attribute.
<p>
64-bit floating-point (for precision).  3 components per attribute.
</p>
         */
        position: GeometryAttribute;
        /**
         * The normal attribute (normalized), which is commonly used for lighting.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        normal: GeometryAttribute;
        /**
         * The 2D texture coordinate attribute.
<p>
32-bit floating-point.  2 components per attribute
</p>
         */
        st: GeometryAttribute;
        /**
         * The binormal attribute (normalized), which is used for tangent-space effects like bump mapping.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        binormal: GeometryAttribute;
        /**
         * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        tangent: GeometryAttribute;
        /**
         * The color attribute.
<p>
8-bit unsigned integer. 4 components per attribute.
</p>
         */
        color: GeometryAttribute;
    }
    /**
     * Geometry instancing allows one {@link Geometry} object to be positions in several
different locations and colored uniquely.  For example, one {@link BoxGeometry} can
be instanced several times, each with a different <code>modelMatrix</code> to change
its position, rotation, and scale.
     */
    class GeometryInstance {
        /**
         * Geometry instancing allows one {@link Geometry} object to be positions in several
different locations and colored uniquely.  For example, one {@link BoxGeometry} can
be instanced several times, each with a different <code>modelMatrix</code> to change
its position, rotation, and scale.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGeometryInstanceOptions);
        /**
         * The geometry being instanced.
         */
        geometry: Geometry;
        /**
         * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.
When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * User-defined object returned when the instance is picked or used to get/set per-instance attributes.
         */
        id: any;
        /**
         * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.
{@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.
         */
        attributes: any;
    }
    /**
     * Values and type information for per-instance geometry attributes.
     */
    class GeometryInstanceAttribute {
        /**
         * Values and type information for per-instance geometry attributes.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGeometryInstanceAttributeOptions);
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
{@link GeometryInstanceAttribute#value}.
         */
        componentDatatype: number;
        /**
         * A number between 1 and 4 that defines the number of components in an attributes.
For example, a position attribute with x, y, and z components would have 3 as
shown in the code example.
         */
        componentsPerAttribute: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
indicate that the components should be mapped to the range [0, 1] (unsigned)
or [-1, 1] (signed) when they are accessed as floating-point for rendering.
<p>
This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
</p>
         */
        normalize: Boolean;
        /**
         * The values for the attributes stored in a typed array.  In the code example,
every three elements in <code>values</code> defines one attributes since
<code>componentsPerAttribute</code> is 3.
         */
        value: number[];
    }
    /**
     * Represents a Gregorian date in a more precise format than the JavaScript Date object.
In addition to submillisecond precision, this object can also represent leap seconds.
     */
    class GregorianDate {
        /**
         * Represents a Gregorian date in a more precise format than the JavaScript Date object.
In addition to submillisecond precision, this object can also represent leap seconds.
         */
        constructor();
        /**
         * Gets or sets the year as a whole number.
         */
        year: number;
        /**
         * Gets or sets the month as a whole number with range [1, 12].
         */
        month: number;
        /**
         * Gets or sets the day of the month as a whole number starting at 1.
         */
        day: number;
        /**
         * Gets or sets the hour as a whole number with range [0, 23].
         */
        hour: number;
        /**
         * Gets or sets the minute of the hour as a whole number with range [0, 59].
         */
        minute: number;
        /**
         * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
         */
        second: number;
        /**
         * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
         */
        millisecond: number;
        /**
         * Gets or sets whether this time is during a leap second.
         */
        isLeapSecond: Boolean;
    }
    /**
     * Defines a heading angle, pitch angle, and range in a local frame.
Heading is the rotation from the local north direction where a positive angle is increasing eastward.
Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
angles are below the plane. Range is the distance from the center of the frame.
     */
    class HeadingPitchRange {
        /**
         * Defines a heading angle, pitch angle, and range in a local frame.
Heading is the rotation from the local north direction where a positive angle is increasing eastward.
Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
angles are below the plane. Range is the distance from the center of the frame.
         * @param heading  (Optional) The heading angle in radians.
         * @param pitch  (Optional) The pitch angle in radians.
         * @param range  (Optional) The distance from the center in meters.
         */
        constructor(heading?: number, pitch?: number, range?: number);
        /**
         * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
         */
        heading: number;
        /**
         * Pitch is the rotation from the local xy-plane. Positive pitch angles
are above the plane. Negative pitch angles are below the plane.
         */
        pitch: number;
        /**
         * Range is the distance from the center of the local frame.
         */
        range: number;
        /**
         * Duplicates a HeadingPitchRange instance.
         * @param hpr  (Required) The HeadingPitchRange to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(hpr: HeadingPitchRange, result?: HeadingPitchRange): HeadingPitchRange;
    }
    /**
     * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
the positive x axis.
     */
    class HeadingPitchRoll {
        /**
         * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
the positive x axis.
         * @param heading  (Optional) The heading component in radians.
         * @param pitch  (Optional) The pitch component in radians.
         * @param roll  (Optional) The roll component in radians.
         */
        constructor(heading?: number, pitch?: number, roll?: number);
        /**
         * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
         * @param quaternion  (Required) The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
         * @param result  (Optional) The object in which to store the result. If not provided, a new instance is created and returned.
         */
        static fromQuaternion(quaternion: Quaternion, result?: Quaternion): HeadingPitchRoll;
        /**
         * Returns a new HeadingPitchRoll instance from angles given in degrees.
         * @param heading  (Required) the heading in degrees
         * @param pitch  (Required) the pitch in degrees
         * @param roll  (Required) the heading in degrees
         * @param result  (Optional) The object in which to store the result. If not provided, a new instance is created and returned.
         */
        static fromDegrees(heading: number, pitch: number, roll: number, result?: HeadingPitchRoll): HeadingPitchRoll;
        /**
         * Duplicates a HeadingPitchRoll instance.
         * @param headingPitchRoll  (Required) The HeadingPitchRoll to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(headingPitchRoll: HeadingPitchRoll, result?: HeadingPitchRoll): HeadingPitchRoll;
        /**
         * Compares the provided HeadingPitchRolls componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first HeadingPitchRoll.
         * @param right  (Optional) The second HeadingPitchRoll.
         */
        static equals(left?: HeadingPitchRoll, right?: HeadingPitchRoll): Boolean;
        /**
         * Compares the provided HeadingPitchRolls componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param left  (Optional) The first HeadingPitchRoll.
         * @param right  (Optional) The second HeadingPitchRoll.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        static equalsEpsilon(left?: HeadingPitchRoll, right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Duplicates this HeadingPitchRoll instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: HeadingPitchRoll): HeadingPitchRoll;
        /**
         * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side HeadingPitchRoll.
         */
        equals(right?: HeadingPitchRoll): Boolean;
        /**
         * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
<code>true</code> if they pass an absolute or relative tolerance test,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side HeadingPitchRoll.
         * @param relativeEpsilon  (Optional) The relative epsilon tolerance to use for equality testing.
         * @param absoluteEpsilon  (Optional) The absolute epsilon tolerance to use for equality testing.
         */
        equalsEpsilon(right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): Boolean;
        /**
         * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
         */
        toString(): string;
    }
    /**
     * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap
is a rectangular array of heights in row-major order from south to north and west to east.
     */
    class HeightmapTerrainData {
        /**
         * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap
is a rectangular array of heights in row-major order from south to north and west to east.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IHeightmapTerrainDataOptions);
        /**
         * The water mask included in this terrain data, if any.  A water mask is a rectangular
Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
         */
        waterMask: Uint8Array|HTMLImageElement|HTMLCanvasElement;
        /**
         * Computes the terrain height at a specified longitude and latitude.
         * @param rectangle  (Required) The rectangle covered by this terrain data.
         * @param longitude  (Required) The longitude in radians.
         * @param latitude  (Required) The latitude in radians.
         */
        interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
        /**
         * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
height samples in this instance, interpolated if necessary.
         * @param tilingScheme  (Required) The tiling scheme of this terrain data.
         * @param thisX  (Required) The X coordinate of this tile in the tiling scheme.
         * @param thisY  (Required) The Y coordinate of this tile in the tiling scheme.
         * @param thisLevel  (Required) The level of this tile in the tiling scheme.
         * @param descendantX  (Required) The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantY  (Required) The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantLevel  (Required) The level within the tiling scheme of the descendant tile for which we are upsampling.
         */
        upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<HeightmapTerrainData>;
        /**
         * Determines if a given child tile is available, based on the
{@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
to be one of the four children of this tile.  If non-child tile coordinates are
given, the availability of the southeast child tile is returned.
         * @param thisX  (Required) The tile X coordinate of this (the parent) tile.
         * @param thisY  (Required) The tile Y coordinate of this (the parent) tile.
         * @param childX  (Required) The tile X coordinate of the child tile to check for availability.
         * @param childY  (Required) The tile Y coordinate of the child tile to check for availability.
         */
        isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): Boolean;
        /**
         * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
terrain data.  If this value is false, the data was obtained from some other source, such
as by downloading it from a remote server.  This method should return true for instances
returned from a call to {@link HeightmapTerrainData#upsample}.
         */
        wasCreatedByUpsampling(): Boolean;
    }
    /**
     * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times
must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming
tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and
<code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,
respectively.
     */
    class HermiteSpline {
        /**
         * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times
must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming
tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and
<code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,
respectively.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IHermiteSplineOptions);
        /**
         * An array of times for the control points.
         */
        times: number[];
        /**
         * An array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
        /**
         * An array of {@link Cartesian3} incoming tangents at each control point.
         */
        inTangents: Cartesian3[];
        /**
         * An array of {@link Cartesian3} outgoing tangents at each control point.
         */
        outTangents: Cartesian3[];
        /**
         * Creates a spline where the tangents at each control point are the same.
The curves are guaranteed to be at least in the class C<sup>1</sup>.
         * @param options  (Required) Object with the following properties:
         */
        static createC1(options: HermiteSpline.IHermiteSplineCreateC1Options): HermiteSpline;
        /**
         * Creates a natural cubic spline. The tangents at the control points are generated
to create a curve in the class C<sup>2</sup>.
         * @param options  (Required) Object with the following properties:
         */
        static createNaturalCubic(options: HermiteSpline.IHermiteSplineCreateNaturalCubicOptions): HermiteSpline|LinearSpline;
        /**
         * Creates a clamped cubic spline. The tangents at the interior control points are generated
to create a curve in the class C<sup>2</sup>.
         * @param options  (Required) Object with the following properties:
         */
        static createClampedCubic(options: HermiteSpline.IHermiteSplineCreateClampedCubicOptions): HermiteSpline|LinearSpline;
        /**
         * Finds an index <code>i</code> in <code>times</code> such that the parameter
<code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
         * @param time  (Required) The time.
         */
        findTimeInterval(time: number): number;
        /**
         * Evaluates the curve at a given time.
         * @param time  (Required) The time at which to evaluate the curve.
         * @param result  (Optional) The object onto which to store the result.
         */
        evaluate(time: number, result?: Cartesian3): Cartesian3;
    }
    /**
     * Represents the closed interval [start, stop].
     */
    class Interval {
        /**
         * Represents the closed interval [start, stop].
         * @param start  (Optional) The beginning of the interval.
         * @param stop  (Optional) The end of the interval.
         */
        constructor(start?: number, stop?: number);
        /**
         * The beginning of the interval.
         */
        start: number;
        /**
         * The end of the interval.
         */
        stop: number;
    }
    /**
     * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
For increased precision, this class stores the whole number part of the date and the seconds
part of the date in separate components.  In order to be safe for arithmetic and represent
leap seconds, the date is always stored in the International Atomic Time standard
{@link TimeStandard.TAI}.
     */
    class JulianDate {
        /**
         * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
For increased precision, this class stores the whole number part of the date and the seconds
part of the date in separate components.  In order to be safe for arithmetic and represent
leap seconds, the date is always stored in the International Atomic Time standard
{@link TimeStandard.TAI}.
         * @param julianDayNumber  (Optional) The Julian Day number representing the number of whole days.  Fractional days will also be handled correctly.
         * @param secondsOfDay  (Optional) The number of seconds into the current Julian Day number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
         * @param timeStandard  (Optional) The time standard in which the first two parameters are defined.
         */
        constructor(julianDayNumber?: number, secondsOfDay?: number, timeStandard?: number);
        /**
         * Gets or sets the number of whole days.
         */
        dayNumber: number;
        /**
         * Gets or sets the number of seconds into the current day.
         */
        secondsOfDay: number;
        /**
         * Creates a new instance from a JavaScript Date.
         * @param date  (Required) A JavaScript Date.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static fromDate(date: Date, result?: JulianDate): JulianDate;
        /**
         * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
         * @param iso8601String  (Required) An ISO 8601 date.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static fromIso8601(iso8601String: string, result?: JulianDate): JulianDate;
        /**
         * Creates a new instance that represents the current system time.
This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static now(result?: JulianDate): JulianDate;
        /**
         * Creates a {@link GregorianDate} from the provided instance.
         * @param julianDate  (Required) The date to be converted.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static toGregorianDate(julianDate: JulianDate, result?: GregorianDate): GregorianDate;
        /**
         * Creates a JavaScript Date from the provided instance.
Since JavaScript dates are only accurate to the nearest millisecond and
cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
If the provided JulianDate is during a leap second, the previous second is used.
         * @param julianDate  (Required) The date to be converted.
         */
        static toDate(julianDate: JulianDate): Date;
        /**
         * Creates an ISO8601 representation of the provided date.
         * @param julianDate  (Required) The date to be converted.
         * @param precision  (Optional) The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
         */
        static toIso8601(julianDate: JulianDate, precision?: number): string;
        /**
         * Duplicates a JulianDate instance.
         * @param julianDate  (Required) The date to duplicate.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static clone(julianDate: JulianDate, result?: JulianDate): JulianDate;
        /**
         * Compares two instances.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static compare(left: JulianDate, right: JulianDate): number;
        /**
         * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first instance.
         * @param right  (Optional) The second instance.
         */
        static equals(left?: JulianDate, right?: JulianDate): Boolean;
        /**
         * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
each other.  That is, in order for the dates to be considered equal (and for
this function to return <code>true</code>), the absolute value of the difference between them, in
seconds, must be less than <code>epsilon</code>.
         * @param left  (Optional) The first instance.
         * @param right  (Optional) The second instance.
         * @param epsilon  (Optional) The maximum number of seconds that should separate the two instances.
         */
        static equalsEpsilon(left?: JulianDate, right?: JulianDate, epsilon?: number): Boolean;
        /**
         * Computes the total number of whole and fractional days represented by the provided instance.
         * @param julianDate  (Required) The date.
         */
        static totalDays(julianDate: JulianDate): number;
        /**
         * Computes the difference in seconds between the provided instance.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static secondsDifference(left: JulianDate, right: JulianDate): number;
        /**
         * Computes the difference in days between the provided instance.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static daysDifference(left: JulianDate, right: JulianDate): number;
        /**
         * Computes the number of seconds the provided instance is ahead of UTC.
         * @param julianDate  (Required) The date.
         */
        static computeTaiMinusUtc(julianDate: JulianDate): number;
        /**
         * Adds the provided number of seconds to the provided date instance.
         * @param julianDate  (Required) The date.
         * @param seconds  (Required) The number of seconds to add or subtract.
         * @param result  (Required) An existing instance to use for the result.
         */
        static addSeconds(julianDate: JulianDate, seconds: number, result: JulianDate): JulianDate;
        /**
         * Adds the provided number of minutes to the provided date instance.
         * @param julianDate  (Required) The date.
         * @param minutes  (Required) The number of minutes to add or subtract.
         * @param result  (Required) An existing instance to use for the result.
         */
        static addMinutes(julianDate: JulianDate, minutes: number, result: JulianDate): JulianDate;
        /**
         * Adds the provided number of hours to the provided date instance.
         * @param julianDate  (Required) The date.
         * @param hours  (Required) The number of hours to add or subtract.
         * @param result  (Required) An existing instance to use for the result.
         */
        static addHours(julianDate: JulianDate, hours: number, result: JulianDate): JulianDate;
        /**
         * Adds the provided number of days to the provided date instance.
         * @param julianDate  (Required) The date.
         * @param days  (Required) The number of days to add or subtract.
         * @param result  (Required) An existing instance to use for the result.
         */
        static addDays(julianDate: JulianDate, days: number, result: JulianDate): JulianDate;
        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static lessThan(left: JulianDate, right: JulianDate): Boolean;
        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static lessThanOrEquals(left: JulianDate, right: JulianDate): Boolean;
        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static greaterThan(left: JulianDate, right: JulianDate): Boolean;
        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
         * @param left  (Required) The first instance.
         * @param right  (Required) The second instance.
         */
        static greaterThanOrEquals(left: JulianDate, right: JulianDate): Boolean;
        /**
         * Duplicates this instance.
         * @param result  (Optional) An existing instance to use for the result.
         */
        clone(result?: JulianDate): JulianDate;
        /**
         * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The second instance.
         */
        equals(right?: JulianDate): Boolean;
        /**
         * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
each other.  That is, in order for the dates to be considered equal (and for
this function to return <code>true</code>), the absolute value of the difference between them, in
seconds, must be less than <code>epsilon</code>.
         * @param right  (Optional) The second instance.
         * @param epsilon  (Optional) The maximum number of seconds that should separate the two instances.
         */
        equalsEpsilon(right?: JulianDate, epsilon?: number): Boolean;
        /**
         * Creates a string representing this date in ISO8601 format.
         */
        toString(): string;
        /**
         * Gets or sets the list of leap seconds used throughout Cesium.
         */
        leapSeconds: LeapSecond[];
    }
    /**
     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
     */
    class LeapSecond {
        /**
         * Describes a single leap second, which is constructed from a {@link JulianDate} and a
numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
         * @param date  (Optional) A Julian date representing the time of the leap second.
         * @param offset  (Optional) The cumulative number of seconds that TAI is ahead of UTC at the provided date.
         */
        constructor(date?: JulianDate, offset?: number);
        /**
         * Gets or sets the date at which this leap second occurs.
         */
        julianDate: JulianDate;
        /**
         * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
of this leap second.
         */
        offset: number;
    }
    /**
     * A spline that uses piecewise linear interpolation to create a curve.
     */
    class LinearSpline {
        /**
         * A spline that uses piecewise linear interpolation to create a curve.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ILinearSplineOptions);
        /**
         * An array of times for the control points.
         */
        times: number[];
        /**
         * An array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
        /**
         * Finds an index <code>i</code> in <code>times</code> such that the parameter
<code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
         * @param time  (Required) The time.
         */
        findTimeInterval(time: number): number;
        /**
         * Evaluates the curve at a given time.
         * @param time  (Required) The time at which to evaluate the curve.
         * @param result  (Optional) The object onto which to store the result.
         */
        evaluate(time: number, result?: Cartesian3): Cartesian3;
    }
    /**
     * Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a
flat map like Cesium's 2D and Columbus View modes.
     */
    class MapProjection {
        /**
         * Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a
flat map like Cesium's 2D and Columbus View modes.
         */
        constructor();
        /**
         * Gets the {@link Ellipsoid}.
         */
        ellipsoid: Ellipsoid;
        /**
         * Projects {@link Cartographic} coordinates, in radians, to projection-specific map coordinates, in meters.
         * @param cartographic  (Required) The coordinates to project.
         * @param result  (Optional) An instance into which to copy the result.  If this parameter is
       undefined, a new instance is created and returned.
         */
        project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
        /**
         * Unprojects projection-specific map {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
coordinates, in radians.
         * @param cartesian  (Required) The Cartesian position to unproject with height (z) in meters.
         * @param result  (Optional) An instance into which to copy the result.  If this parameter is
       undefined, a new instance is created and returned.
         */
        unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
    }
    /**
     * A 2x2 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
     */
    class Matrix2 {
        /**
         * A 2x2 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
         * @param column0Row0  (Optional) The value for column 0, row 0.
         * @param column1Row0  (Optional) The value for column 1, row 0.
         * @param column0Row1  (Optional) The value for column 0, row 1.
         * @param column1Row1  (Optional) The value for column 1, row 1.
         */
        constructor(column0Row0?: number, column1Row0?: number, column0Row1?: number, column1Row1?: number);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Matrix2, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
        /**
         * Duplicates a Matrix2 instance.
         * @param matrix  (Required) The matrix to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(matrix: Matrix2, result?: Matrix2): Matrix2;
        /**
         * Creates a Matrix2 from 4 consecutive elements in an array.
         * @param array  (Required) The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to first column first row position in the matrix.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
        /**
         * Creates a Matrix2 instance from a column-major order array.
         * @param values  (Required) The column-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromColumnMajorArray(values: number[], result?: Matrix2): Matrix2;
        /**
         * Creates a Matrix2 instance from a row-major order array.
The resulting matrix will be in column-major order.
         * @param values  (Required) The row-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRowMajorArray(values: number[], result?: Matrix2): Matrix2;
        /**
         * Computes a Matrix2 instance representing a non-uniform scale.
         * @param scale  (Required) The x and y scale factors.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromScale(scale: Cartesian2, result?: Matrix2): Matrix2;
        /**
         * Computes a Matrix2 instance representing a uniform scale.
         * @param scale  (Required) The uniform scale factor.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromUniformScale(scale: number, result?: Matrix2): Matrix2;
        /**
         * Creates a rotation matrix.
         * @param angle  (Required) The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRotation(angle: number, result?: Matrix2): Matrix2;
        /**
         * Creates an Array from the provided Matrix2 instance.
The array will be in column-major order.
         * @param matrix  (Required) The matrix to use..
         * @param result  (Optional) The Array onto which to store the result.
         */
        static toArray(matrix: Matrix2, result?: number[]): number[];
        /**
         * Computes the array index of the element at the provided row and column.
         * @param row  (Required) The zero-based index of the row.
         * @param column  (Required) The zero-based index of the column.
         */
        static getElementIndex(row: number, column: number): number;
        /**
         * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getColumn(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
        /**
         * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified column.
         * @param result  (Required) The object onto which to store the result.
         */
        static setColumn(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Cartesian2): Matrix2;
        /**
         * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getRow(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
        /**
         * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified row.
         * @param result  (Required) The object onto which to store the result.
         */
        static setRow(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Matrix2): Matrix2;
        /**
         * Extracts the non-uniform scale assuming the matrix is an affine transformation.
         * @param matrix  (Required) The matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static getScale(matrix: Matrix2, result: Cartesian2): Cartesian2;
        /**
         * Computes the maximum scale assuming the matrix is an affine transformation.
The maximum scale is the maximum length of the column vectors.
         * @param matrix  (Required) The matrix.
         */
        static getMaximumScale(matrix: Matrix2): number;
        /**
         * Computes the product of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiply(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
        /**
         * Computes the sum of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
        /**
         * Computes the difference of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
        /**
         * Computes the product of a matrix and a column vector.
         * @param matrix  (Required) The matrix.
         * @param cartesian  (Required) The column.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByVector(matrix: Matrix2, cartesian: Cartesian2, result: Cartesian2): Cartesian2;
        /**
         * Computes the product of a matrix and a scalar.
         * @param matrix  (Required) The matrix.
         * @param scalar  (Required) The number to multiply by.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(matrix: Matrix2, scalar: number, result: Matrix2): Matrix2;
        /**
         * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
         * @param matrix  (Required) The matrix on the left-hand side.
         * @param scale  (Required) The non-uniform scale on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScale(matrix: Matrix2, scale: Cartesian2, result: Matrix2): Matrix2;
        /**
         * Creates a negated copy of the provided matrix.
         * @param matrix  (Required) The matrix to negate.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(matrix: Matrix2, result: Matrix2): Matrix2;
        /**
         * Computes the transpose of the provided matrix.
         * @param matrix  (Required) The matrix to transpose.
         * @param result  (Required) The object onto which to store the result.
         */
        static transpose(matrix: Matrix2, result: Matrix2): Matrix2;
        /**
         * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
         * @param matrix  (Required) The matrix with signed elements.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(matrix: Matrix2, result: Matrix2): Matrix2;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         */
        static equals(left?: Matrix2, right?: Matrix2): Boolean;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        static equalsEpsilon(left?: Matrix2, right?: Matrix2, epsilon?: number): Boolean;
        /**
         * Gets the number of items in the collection.
         */
        length: number;
        /**
         * Duplicates the provided Matrix2 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Matrix2): Matrix2;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         */
        equals(right?: Matrix2): Boolean;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(right?: Matrix2, epsilon?: number): Boolean;
        /**
         * Creates a string representing this Matrix with each row being
on a separate line and in the format '(column0, column1)'.
         */
        toString(): string;
    }
    /**
     * A 3x3 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
     */
    class Matrix3 {
        /**
         * A 3x3 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
         * @param column0Row0  (Optional) The value for column 0, row 0.
         * @param column1Row0  (Optional) The value for column 1, row 0.
         * @param column2Row0  (Optional) The value for column 2, row 0.
         * @param column0Row1  (Optional) The value for column 0, row 1.
         * @param column1Row1  (Optional) The value for column 1, row 1.
         * @param column2Row1  (Optional) The value for column 2, row 1.
         * @param column0Row2  (Optional) The value for column 0, row 2.
         * @param column1Row2  (Optional) The value for column 1, row 2.
         * @param column2Row2  (Optional) The value for column 2, row 2.
         */
        constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Matrix3, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
        /**
         * Duplicates a Matrix3 instance.
         * @param matrix  (Required) The matrix to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(matrix: Matrix3, result?: Matrix3): Matrix3;
        /**
         * Creates a Matrix3 from 9 consecutive elements in an array.
         * @param array  (Required) The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to first column first row position in the matrix.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
        /**
         * Creates a Matrix3 instance from a column-major order array.
         * @param values  (Required) The column-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromColumnMajorArray(values: number[], result?: Matrix3): Matrix3;
        /**
         * Creates a Matrix3 instance from a row-major order array.
The resulting matrix will be in column-major order.
         * @param values  (Required) The row-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRowMajorArray(values: number[], result?: Matrix3): Matrix3;
        /**
         * Computes a 3x3 rotation matrix from the provided quaternion.
         * @param quaternion  (Required) the quaternion to use.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromQuaternion(quaternion: Quaternion, result?: Matrix3): Matrix3;
        /**
         * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
         * @param headingPitchRoll  (Required) the headingPitchRoll to use.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Matrix3): Matrix3;
        /**
         * Computes a Matrix3 instance representing a non-uniform scale.
         * @param scale  (Required) The x, y, and z scale factors.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromScale(scale: Cartesian3, result?: Matrix3): Matrix3;
        /**
         * Computes a Matrix3 instance representing a uniform scale.
         * @param scale  (Required) The uniform scale factor.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromUniformScale(scale: number, result?: Matrix3): Matrix3;
        /**
         * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
         * @param the  (Required) vector on the left hand side of the cross product operation.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromCrossProduct(the: Cartesian3, result?: Matrix3): Matrix3;
        /**
         * Creates a rotation matrix around the x-axis.
         * @param angle  (Required) The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRotationX(angle: number, result?: Matrix3): Matrix3;
        /**
         * Creates a rotation matrix around the y-axis.
         * @param angle  (Required) The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRotationY(angle: number, result?: Matrix3): Matrix3;
        /**
         * Creates a rotation matrix around the z-axis.
         * @param angle  (Required) The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRotationZ(angle: number, result?: Matrix3): Matrix3;
        /**
         * Creates an Array from the provided Matrix3 instance.
The array will be in column-major order.
         * @param matrix  (Required) The matrix to use..
         * @param result  (Optional) The Array onto which to store the result.
         */
        static toArray(matrix: Matrix3, result?: number[]): number[];
        /**
         * Computes the array index of the element at the provided row and column.
         * @param row  (Required) The zero-based index of the row.
         * @param column  (Required) The zero-based index of the column.
         */
        static getElementIndex(row: number, column: number): number;
        /**
         * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getColumn(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
        /**
         * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified column.
         * @param result  (Required) The object onto which to store the result.
         */
        static setColumn(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
        /**
         * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getRow(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
        /**
         * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified row.
         * @param result  (Required) The object onto which to store the result.
         */
        static setRow(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
        /**
         * Extracts the non-uniform scale assuming the matrix is an affine transformation.
         * @param matrix  (Required) The matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static getScale(matrix: Matrix3, result: Cartesian3): Cartesian3;
        /**
         * Computes the maximum scale assuming the matrix is an affine transformation.
The maximum scale is the maximum length of the column vectors.
         * @param matrix  (Required) The matrix.
         */
        static getMaximumScale(matrix: Matrix3): number;
        /**
         * Computes the product of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiply(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the sum of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the difference of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the product of a matrix and a column vector.
         * @param matrix  (Required) The matrix.
         * @param cartesian  (Required) The column.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByVector(matrix: Matrix3, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the product of a matrix and a scalar.
         * @param matrix  (Required) The matrix.
         * @param scalar  (Required) The number to multiply by.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(matrix: Matrix3, scalar: number, result: Matrix3): Matrix3;
        /**
         * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
         * @param matrix  (Required) The matrix on the left-hand side.
         * @param scale  (Required) The non-uniform scale on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScale(matrix: Matrix3, scale: Cartesian3, result: Matrix3): Matrix3;
        /**
         * Creates a negated copy of the provided matrix.
         * @param matrix  (Required) The matrix to negate.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(matrix: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the transpose of the provided matrix.
         * @param matrix  (Required) The matrix to transpose.
         * @param result  (Required) The object onto which to store the result.
         */
        static transpose(matrix: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the eigenvectors and eigenvalues of a symmetric matrix.
<p>
Returns a diagonal matrix and unitary matrix such that:
<code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
</p>
<p>
The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
of the unitary matrix are the corresponding eigenvectors.
</p>
         * @param matrix  (Required) The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
         * @param result  (Optional) An object with unitary and diagonal properties which are matrices onto which to store the result.
         */
        static computeEigenDecomposition(matrix: Matrix3, result?: any): any;
        /**
         * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
         * @param matrix  (Required) The matrix with signed elements.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(matrix: Matrix3, result: Matrix3): Matrix3;
        /**
         * Computes the determinant of the provided matrix.
         * @param matrix  (Required) The matrix to use.
         */
        static determinant(matrix: Matrix3): number;
        /**
         * Computes the inverse of the provided matrix.
         * @param matrix  (Required) The matrix to invert.
         * @param result  (Required) The object onto which to store the result.
         */
        static inverse(matrix: Matrix3, result: Matrix3): Matrix3;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         */
        static equals(left?: Matrix3, right?: Matrix3): Boolean;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        static equalsEpsilon(left?: Matrix3, right?: Matrix3, epsilon?: number): Boolean;
        /**
         * Gets the number of items in the collection.
         */
        length: number;
        /**
         * Duplicates the provided Matrix3 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Matrix3): Matrix3;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         */
        equals(right?: Matrix3): Boolean;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(right?: Matrix3, epsilon?: number): Boolean;
        /**
         * Creates a string representing this Matrix with each row being
on a separate line and in the format '(column0, column1, column2)'.
         */
        toString(): string;
    }
    /**
     * A 4x4 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
     */
    class Matrix4 {
        /**
         * A 4x4 matrix, indexable as a column-major order array.
Constructor parameters are in row-major order for code readability.
         * @param column0Row0  (Optional) The value for column 0, row 0.
         * @param column1Row0  (Optional) The value for column 1, row 0.
         * @param column2Row0  (Optional) The value for column 2, row 0.
         * @param column3Row0  (Optional) The value for column 3, row 0.
         * @param column0Row1  (Optional) The value for column 0, row 1.
         * @param column1Row1  (Optional) The value for column 1, row 1.
         * @param column2Row1  (Optional) The value for column 2, row 1.
         * @param column3Row1  (Optional) The value for column 3, row 1.
         * @param column0Row2  (Optional) The value for column 0, row 2.
         * @param column1Row2  (Optional) The value for column 1, row 2.
         * @param column2Row2  (Optional) The value for column 2, row 2.
         * @param column3Row2  (Optional) The value for column 3, row 2.
         * @param column0Row3  (Optional) The value for column 0, row 3.
         * @param column1Row3  (Optional) The value for column 1, row 3.
         * @param column2Row3  (Optional) The value for column 2, row 3.
         * @param column3Row3  (Optional) The value for column 3, row 3.
         */
        constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column3Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column3Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number, column3Row2?: number, column0Row3?: number, column1Row3?: number, column2Row3?: number, column3Row3?: number);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Matrix4, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
        /**
         * Duplicates a Matrix4 instance.
         * @param matrix  (Required) The matrix to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(matrix: Matrix4, result?: Matrix4): Matrix4;
        /**
         * Creates a Matrix4 from 16 consecutive elements in an array.
         * @param array  (Required) The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
         * @param startingIndex  (Optional) The offset into the array of the first element, which corresponds to first column first row position in the matrix.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromArray(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance from a column-major order array.
         * @param values  (Required) The column-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromColumnMajorArray(values: number[], result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance from a row-major order array.
The resulting matrix will be in column-major order.
         * @param values  (Required) The row-major order array.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRowMajorArray(values: number[], result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance from a Matrix3 representing the rotation
and a Cartesian3 representing the translation.
         * @param rotation  (Required) The upper left portion of the matrix representing the rotation.
         * @param translation  (Optional) The upper right portion of the matrix representing the translation.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromRotationTranslation(rotation: Matrix3, translation?: Cartesian3, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
representation with the rotation represented as a quaternion.
         * @param translation  (Required) The translation transformation.
         * @param rotation  (Required) The rotation transformation.
         * @param scale  (Required) The non-uniform scale transformation.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromTranslationQuaternionRotationScale(translation: Cartesian3, rotation: Quaternion, scale: Cartesian3, result?: Matrix4): Matrix4;
        /**
         * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
         * @param translationRotationScale  (Required) The instance.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromTranslationRotationScale(translationRotationScale: TranslationRotationScale, result?: Matrix4): Matrix4;
        /**
         * Creates a Matrix4 instance from a Cartesian3 representing the translation.
         * @param translation  (Required) The upper right portion of the matrix representing the translation.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromTranslation(translation: Cartesian3, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing a non-uniform scale.
         * @param scale  (Required) The x, y, and z scale factors.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromScale(scale: Cartesian3, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing a uniform scale.
         * @param scale  (Required) The uniform scale factor.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromUniformScale(scale: number, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance from a Camera.
         * @param camera  (Required) The camera to use.
         * @param result  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromCamera(camera: Camera, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing a perspective transformation matrix.
         * @param fovY  (Required) The field of view along the Y axis in radians.
         * @param aspectRatio  (Required) The aspect ratio.
         * @param near  (Required) The distance to the near plane in meters.
         * @param far  (Required) The distance to the far plane in meters.
         * @param result  (Required) The object in which the result will be stored.
         */
        static computePerspectiveFieldOfView(fovY: number, aspectRatio: number, near: number, far: number, result: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing an orthographic transformation matrix.
         * @param left  (Required) The number of meters to the left of the camera that will be in view.
         * @param right  (Required) The number of meters to the right of the camera that will be in view.
         * @param bottom  (Required) The number of meters below of the camera that will be in view.
         * @param top  (Required) The number of meters above of the camera that will be in view.
         * @param near  (Required) The distance to the near plane in meters.
         * @param far  (Required) The distance to the far plane in meters.
         * @param result  (Required) The object in which the result will be stored.
         */
        static computeOrthographicOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing an off center perspective transformation.
         * @param left  (Required) The number of meters to the left of the camera that will be in view.
         * @param right  (Required) The number of meters to the right of the camera that will be in view.
         * @param bottom  (Required) The number of meters below of the camera that will be in view.
         * @param top  (Required) The number of meters above of the camera that will be in view.
         * @param near  (Required) The distance to the near plane in meters.
         * @param far  (Required) The distance to the far plane in meters.
         * @param result  (Required) The object in which the result will be stored.
         */
        static computePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance representing an infinite off center perspective transformation.
         * @param left  (Required) The number of meters to the left of the camera that will be in view.
         * @param right  (Required) The number of meters to the right of the camera that will be in view.
         * @param bottom  (Required) The number of meters below of the camera that will be in view.
         * @param top  (Required) The number of meters above of the camera that will be in view.
         * @param near  (Required) The distance to the near plane in meters.
         * @param result  (Required) The object in which the result will be stored.
         */
        static computeInfinitePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, result: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
         * @param viewport  (Optional) The viewport's corners as shown in Example 1.
         * @param nearDepthRange  (Optional) The near plane distance in window coordinates.
         * @param farDepthRange  (Optional) The far plane distance in window coordinates.
         * @param result  (Optional) The object in which the result will be stored.
         */
        static computeViewportTransformation(viewport?: any, nearDepthRange?: number, farDepthRange?: number, result?: Matrix4): Matrix4;
        /**
         * Computes a Matrix4 instance that transforms from world space to view space.
         * @param position  (Required) The position of the camera.
         * @param direction  (Required) The forward direction.
         * @param up  (Required) The up direction.
         * @param right  (Required) The right direction.
         * @param result  (Required) The object in which the result will be stored.
         */
        static computeView(position: Cartesian3, direction: Cartesian3, up: Cartesian3, right: Cartesian3, result: Matrix4): Matrix4;
        /**
         * Computes an Array from the provided Matrix4 instance.
The array will be in column-major order.
         * @param matrix  (Required) The matrix to use..
         * @param result  (Optional) The Array onto which to store the result.
         */
        static toArray(matrix: Matrix4, result?: number[]): number[];
        /**
         * Computes the array index of the element at the provided row and column.
         * @param row  (Required) The zero-based index of the row.
         * @param column  (Required) The zero-based index of the column.
         */
        static getElementIndex(row: number, column: number): number;
        /**
         * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getColumn(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
        /**
         * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the column to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified column.
         * @param result  (Required) The object onto which to store the result.
         */
        static setColumn(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
        /**
         * Computes a new matrix that replaces the translation in the rightmost column of the provided
matrix with the provided translation.  This assumes the matrix is an affine transformation
         * @param matrix  (Required) The matrix to use.
         * @param translation  (Required) The translation that replaces the translation of the provided matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static setTranslation(matrix: Matrix4, translation: Cartesian3, result: Cartesian4): Matrix4;
        /**
         * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to retrieve.
         * @param result  (Required) The object onto which to store the result.
         */
        static getRow(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
        /**
         * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
         * @param matrix  (Required) The matrix to use.
         * @param index  (Required) The zero-based index of the row to set.
         * @param cartesian  (Required) The Cartesian whose values will be assigned to the specified row.
         * @param result  (Required) The object onto which to store the result.
         */
        static setRow(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
        /**
         * Extracts the non-uniform scale assuming the matrix is an affine transformation.
         * @param matrix  (Required) The matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static getScale(matrix: Matrix4, result: Cartesian3): Cartesian3;
        /**
         * Computes the maximum scale assuming the matrix is an affine transformation.
The maximum scale is the maximum length of the column vectors in the upper-left
3x3 matrix.
         * @param matrix  (Required) The matrix.
         */
        static getMaximumScale(matrix: Matrix4): number;
        /**
         * Computes the product of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiply(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes the sum of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes the difference of two matrices.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes the product of two matrices assuming the matrices are
affine transformation matrices, where the upper left 3x3 elements
are a rotation matrix, and the upper three elements in the fourth
column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
The matrix is not verified to be in the proper form.
This method is faster than computing the product for general 4x4
matrices using {@link Matrix4.multiply}.
         * @param left  (Required) The first matrix.
         * @param right  (Required) The second matrix.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyTransformation(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
        /**
         * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
by a 3x3 rotation matrix.  This is an optimization
for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
         * @param matrix  (Required) The matrix on the left-hand side.
         * @param rotation  (Required) The 3x3 rotation matrix on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByMatrix3(matrix: Matrix4, rotation: Matrix3, result: Matrix4): Matrix4;
        /**
         * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
         * @param matrix  (Required) The matrix on the left-hand side.
         * @param translation  (Required) The translation on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;
        /**
         * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
by an implicit uniform scale matrix.  This is an optimization
for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
<code>m</code> must be an affine matrix.
This function performs fewer allocations and arithmetic operations.
         * @param matrix  (Required) The affine matrix on the left-hand side.
         * @param scale  (Required) The uniform scale on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;
        /**
         * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
by an implicit non-uniform scale matrix.  This is an optimization
for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
<code>m</code> must be an affine matrix.
This function performs fewer allocations and arithmetic operations.
         * @param matrix  (Required) The affine matrix on the left-hand side.
         * @param scale  (Required) The non-uniform scale on the right-hand side.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;
        /**
         * Computes the product of a matrix and a column vector.
         * @param matrix  (Required) The matrix.
         * @param cartesian  (Required) The vector.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByVector(matrix: Matrix4, cartesian: Cartesian4, result: Cartesian4): Cartesian4;
        /**
         * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
with a {@link Cartesian4} with a <code>w</code> component of zero.
         * @param matrix  (Required) The matrix.
         * @param cartesian  (Required) The point.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByPointAsVector(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
         * @param matrix  (Required) The matrix.
         * @param cartesian  (Required) The point.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByPoint(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
        /**
         * Computes the product of a matrix and a scalar.
         * @param matrix  (Required) The matrix.
         * @param scalar  (Required) The number to multiply by.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(matrix: Matrix4, scalar: number, result: Matrix4): Matrix4;
        /**
         * Computes a negated copy of the provided matrix.
         * @param matrix  (Required) The matrix to negate.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(matrix: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes the transpose of the provided matrix.
         * @param matrix  (Required) The matrix to transpose.
         * @param result  (Required) The object onto which to store the result.
         */
        static transpose(matrix: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
         * @param matrix  (Required) The matrix with signed elements.
         * @param result  (Required) The object onto which to store the result.
         */
        static abs(matrix: Matrix4, result: Matrix4): Matrix4;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         */
        static equals(left?: Matrix4, right?: Matrix4): Boolean;
        /**
         * Compares the provided matrices componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param left  (Optional) The first matrix.
         * @param right  (Optional) The second matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        static equalsEpsilon(left?: Matrix4, right?: Matrix4, epsilon?: number): Boolean;
        /**
         * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
         * @param matrix  (Required) The matrix to use.
         * @param result  (Required) The object onto which to store the result.
         */
        static getTranslation(matrix: Matrix4, result: Cartesian3): Cartesian3;
        /**
         * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
         * @param matrix  (Required) The matrix to use.
         * @param result  (Required) The object onto which to store the result.
         */
        static getRotation(matrix: Matrix4, result: Matrix3): Matrix3;
        /**
         * Computes the inverse of the provided matrix using Cramers Rule.
If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
If the matrix is an affine transformation matrix, it is more efficient
to invert it with {@link Matrix4.inverseTransformation}.
         * @param matrix  (Required) The matrix to invert.
         * @param result  (Required) The object onto which to store the result.
         */
        static inverse(matrix: Matrix4, result: Matrix4): Matrix4;
        /**
         * Computes the inverse of the provided matrix assuming it is
an affine transformation matrix, where the upper left 3x3 elements
are a rotation matrix, and the upper three elements in the fourth
column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
The matrix is not verified to be in the proper form.
This method is faster than computing the inverse for a general 4x4
matrix using {@link Matrix4.inverse}.
         * @param matrix  (Required) The matrix to invert.
         * @param result  (Required) The object onto which to store the result.
         */
        static inverseTransformation(matrix: Matrix4, result: Matrix4): Matrix4;
        /**
         * Gets the number of items in the collection.
         */
        length: number;
        /**
         * Duplicates the provided Matrix4 instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Matrix4): Matrix4;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         */
        equals(right?: Matrix4): Boolean;
        /**
         * Compares this matrix to the provided matrix componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side matrix.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(right?: Matrix4, epsilon?: number): Boolean;
        /**
         * Computes a string representing this Matrix with each row being
on a separate line and in the format '(column0, column1, column2, column3)'.
         */
        toString(): string;
    }
    /**
     * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.
     */
    class NearFarScalar {
        /**
         * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.
         * @param near  (Optional) The lower bound of the camera range.
         * @param nearValue  (Optional) The value at the lower bound of the camera range.
         * @param far  (Optional) The upper bound of the camera range.
         * @param farValue  (Optional) The value at the upper bound of the camera range.
         */
        constructor(near?: number, nearValue?: number, far?: number, farValue?: number);
        /**
         * The lower bound of the camera range.
         */
        near: number;
        /**
         * The value at the lower bound of the camera range.
         */
        nearValue: number;
        /**
         * The upper bound of the camera range.
         */
        far: number;
        /**
         * The value at the upper bound of the camera range.
         */
        farValue: number;
        /**
         * Duplicates a NearFarScalar instance.
         * @param nearFarScalar  (Required) The NearFarScalar to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(nearFarScalar: NearFarScalar, result?: NearFarScalar): NearFarScalar;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: NearFarScalar, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: NearFarScalar): NearFarScalar;
        /**
         * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,
<code>false</code> otherwise.
         * @param left  (Optional) The first NearFarScalar.
         * @param right  (Optional) The second NearFarScalar.
         */
        static equals(left?: NearFarScalar, right?: NearFarScalar): Boolean;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: NearFarScalar): NearFarScalar;
        /**
         * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side NearFarScalar.
         */
        equals(right?: NearFarScalar): Boolean;
    }
    /**
     * Creates an Occluder derived from an object's position and radius, as well as the camera position.
The occluder can be used to determine whether or not other objects are visible or hidden behind the
visible horizon defined by the occluder and camera position.
     */
    class Occluder {
        /**
         * Creates an Occluder derived from an object's position and radius, as well as the camera position.
The occluder can be used to determine whether or not other objects are visible or hidden behind the
visible horizon defined by the occluder and camera position.
         * @param occluderBoundingSphere  (Required) The bounding sphere surrounding the occluder.
         * @param cameraPosition  (Required) The coordinate of the viewer/camera.
         */
        constructor(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3);
        /**
         * The position of the occluder.
         */
        position: Cartesian3;
        /**
         * The radius of the occluder.
         */
        radius: number;
        /**
         * The position of the camera.
         */
        cameraPosition: Cartesian3;
        /**
         * Creates an occluder from a bounding sphere and the camera position.
         * @param occluderBoundingSphere  (Required) The bounding sphere surrounding the occluder.
         * @param cameraPosition  (Required) The coordinate of the viewer/camera.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromBoundingSphere(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3, result?: Occluder): Occluder;
        /**
         * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
         * @param occludee  (Required) The point surrounding the occludee object.
         */
        isPointVisible(occludee: Cartesian3): Boolean;
        /**
         * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.
         * @param occludee  (Required) The bounding sphere surrounding the occludee object.
         */
        isBoundingSphereVisible(occludee: BoundingSphere): Boolean;
        /**
         * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
         * @param occludeeBS  (Required) The bounding sphere of the occludee.
         */
        computeVisibility(occludeeBS: BoundingSphere): number;
        /**
         * Computes a point that can be used as the occludee position to the visibility functions.
Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
an object that is used for visibility; however it is also possible to compute a point that if
seen/not seen would also indicate if an object is visible/not visible.  This function is better
called for objects that do not move relative to the occluder and is large, such as a chunk of
terrain.  You are better off not calling this and using the object's bounding sphere for objects
such as a satellite or ground vehicle.
         * @param occluderBoundingSphere  (Required) The bounding sphere surrounding the occluder.
         * @param occludeePosition  (Required) The point where the occludee (bounding sphere of radius 0) is located.
         * @param positions  (Required) List of altitude points on the horizon near the surface of the occluder.
         */
        static computeOccludeePoint(occluderBoundingSphere: BoundingSphere, occludeePosition: Cartesian3, positions: Cartesian3[]): any;
        /**
         * Computes a point that can be used as the occludee position to the visibility functions from an rectangle.
         * @param rectangle  (Required) The rectangle used to create a bounding sphere.
         * @param ellipsoid  (Optional) The ellipsoid used to determine positions of the rectangle.
         */
        static computeOccludeePointFromRectangle(rectangle: Rectangle, ellipsoid?: Ellipsoid): any;
    }
    /**
     * Creates an instance of an OrientedBoundingBox.
An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
     */
    class OrientedBoundingBox {
        /**
         * Creates an instance of an OrientedBoundingBox.
An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
         * @param center  (Optional) The center of the box.
         * @param halfAxes  (Optional) The three orthogonal half-axes of the bounding box.
                                         Equivalently, the transformation matrix, to rotate and scale a 2x2x2
                                         cube centered at the origin.
         */
        constructor(center?: Cartesian3, halfAxes?: Matrix3);
        /**
         * The center of the box.
         */
        center: Cartesian3;
        /**
         * The transformation matrix, to rotate the box to the right position.
         */
        halfAxes: Matrix3;
        /**
         * Computes an instance of an OrientedBoundingBox of the given positions.
This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).
Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf
         * @param positions  (Required) List of {@link Cartesian3} points that the bounding box will enclose.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromPoints(positions: Cartesian3[], result?: OrientedBoundingBox): OrientedBoundingBox;
        /**
         * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
There are no guarantees about the orientation of the bounding box.
         * @param rectangle  (Required) The cartographic rectangle on the surface of the ellipsoid.
         * @param minimumHeight  (Optional) The minimum height (elevation) within the tile.
         * @param maximumHeight  (Optional) The maximum height (elevation) within the tile.
         * @param ellipsoid  (Optional) The ellipsoid on which the rectangle is defined.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRectangle(rectangle: Rectangle, minimumHeight?: number, maximumHeight?: number, ellipsoid?: Ellipsoid, result?: OrientedBoundingBox): OrientedBoundingBox;
        /**
         * Duplicates a OrientedBoundingBox instance.
         * @param box  (Required) The bounding box to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(box: OrientedBoundingBox, result?: OrientedBoundingBox): OrientedBoundingBox;
        /**
         * Determines which side of a plane the oriented bounding box is located.
         * @param box  (Required) The oriented bounding box to test.
         * @param plane  (Required) The plane to test against.
         */
        static intersectPlane(box: OrientedBoundingBox, plane: Plane): number;
        /**
         * Computes the estimated distance squared from the closest point on a bounding box to a point.
         * @param box  (Required) The box.
         * @param cartesian  (Required) The point
         */
        static distanceSquaredTo(box: OrientedBoundingBox, cartesian: Cartesian3): number;
        /**
         * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
<br>
If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
closest and farthest planes from position that intersect the bounding box.
         * @param box  (Required) The bounding box to calculate the distance to.
         * @param position  (Required) The position to calculate the distance from.
         * @param direction  (Required) The direction from position.
         * @param result  (Optional) A Interval to store the nearest and farthest distances.
         */
        static computePlaneDistances(box: OrientedBoundingBox, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
        /**
         * Determines whether or not a bounding box is hidden from view by the occluder.
         * @param box  (Required) The bounding box surrounding the occludee object.
         * @param occluder  (Required) The occluder.
         */
        static isOccluded(box: OrientedBoundingBox, occluder: Occluder): Boolean;
        /**
         * Determines which side of a plane the oriented bounding box is located.
         * @param plane  (Required) The plane to test against.
         */
        intersectPlane(plane: Plane): number;
        /**
         * Computes the estimated distance squared from the closest point on a bounding box to a point.
         * @param cartesian  (Required) The point
         */
        distanceSquaredTo(cartesian: Cartesian3): number;
        /**
         * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
<br>
If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
closest and farthest planes from position that intersect the bounding box.
         * @param position  (Required) The position to calculate the distance from.
         * @param direction  (Required) The direction from position.
         * @param result  (Optional) A Interval to store the nearest and farthest distances.
         */
        computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
        /**
         * Determines whether or not a bounding box is hidden from view by the occluder.
         * @param occluder  (Required) The occluder.
         */
        isOccluded(occluder: Occluder): Boolean;
        /**
         * Compares the provided OrientedBoundingBox componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Required) The first OrientedBoundingBox.
         * @param right  (Required) The second OrientedBoundingBox.
         */
        static equals(left: OrientedBoundingBox, right: OrientedBoundingBox): Boolean;
        /**
         * Duplicates this OrientedBoundingBox instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: OrientedBoundingBox): OrientedBoundingBox;
        /**
         * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side OrientedBoundingBox.
         */
        equals(right?: OrientedBoundingBox): Boolean;
    }
    /**
     * A utility class for generating custom map pins as canvas elements.
<br /><br />
<div align='center'>
<img src='images/PinBuilder.png' width='500'/><br />
Example pins generated using both the maki icon set, which ships with Cesium, and single character text.
</div>
     */
    class PinBuilder {
        /**
         * A utility class for generating custom map pins as canvas elements.
<br /><br />
<div align='center'>
<img src='images/PinBuilder.png' width='500'/><br />
Example pins generated using both the maki icon set, which ships with Cesium, and single character text.
</div>
         */
        constructor();
        /**
         * Creates an empty pin of the specified color and size.
         * @param color  (Required) The color of the pin.
         * @param size  (Required) The size of the pin, in pixels.
         */
        fromColor(color: number, size: number): HTMLCanvasElement;
        /**
         * Creates a pin with the specified icon, color, and size.
         * @param url  (Required) The url of the image to be stamped onto the pin.
         * @param color  (Required) The color of the pin.
         * @param size  (Required) The size of the pin, in pixels.
         */
        fromUrl(url: string, color: number, size: number): HTMLCanvasElement|Promise<HTMLCanvasElement>;
        /**
         * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.
         * @param id  (Required) The id of the maki icon to be stamped onto the pin.
         * @param color  (Required) The color of the pin.
         * @param size  (Required) The size of the pin, in pixels.
         */
        fromMakiIconId(id: string, color: number, size: number): HTMLCanvasElement|Promise<HTMLCanvasElement>;
        /**
         * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible
while still being contained completely within the pin.
         * @param text  (Required) The text to be stamped onto the pin.
         * @param color  (Required) The color of the pin.
         * @param size  (Required) The size of the pin, in pixels.
         */
        fromText(text: string, color: number, size: number): HTMLCanvasElement;
    }
    /**
     * A plane in Hessian Normal Form defined by
<pre>
ax + by + cz + d = 0
</pre>
where (a, b, c) is the plane's <code>normal</code>, d is the signed
<code>distance</code> to the plane, and (x, y, z) is any point on
the plane.
     */
    class Plane {
        /**
         * A plane in Hessian Normal Form defined by
<pre>
ax + by + cz + d = 0
</pre>
where (a, b, c) is the plane's <code>normal</code>, d is the signed
<code>distance</code> to the plane, and (x, y, z) is any point on
the plane.
         * @param normal  (Required) The plane's normal (normalized).
         * @param distance  (Required) The shortest distance from the origin to the plane.  The sign of
<code>distance</code> determines which side of the plane the origin
is on.  If <code>distance</code> is positive, the origin is in the half-space
in the direction of the normal; if negative, the origin is in the half-space
opposite to the normal; if zero, the plane passes through the origin.
         */
        constructor(normal: Cartesian3, distance: number);
        /**
         * The plane's normal.
         */
        normal: Cartesian3;
        /**
         * The shortest distance from the origin to the plane.  The sign of
<code>distance</code> determines which side of the plane the origin
is on.  If <code>distance</code> is positive, the origin is in the half-space
in the direction of the normal; if negative, the origin is in the half-space
opposite to the normal; if zero, the plane passes through the origin.
         */
        distance: number;
        /**
         * Creates a plane from a normal and a point on the plane.
         * @param point  (Required) The point on the plane.
         * @param normal  (Required) The plane's normal (normalized).
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromPointNormal(point: Cartesian3, normal: Cartesian3, result?: Plane): Plane;
        /**
         * Creates a plane from the general equation
         * @param coefficients  (Required) The plane's normal (normalized).
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromCartesian4(coefficients: Cartesian4, result?: Plane): Plane;
        /**
         * Computes the signed shortest distance of a point to a plane.
The sign of the distance determines which side of the plane the point
is on.  If the distance is positive, the point is in the half-space
in the direction of the normal; if negative, the point is in the half-space
opposite to the normal; if zero, the plane passes through the point.
         * @param plane  (Required) The plane.
         * @param point  (Required) The point.
         */
        static getPointDistance(plane: Plane, point: Cartesian3): number;
    }
    /**
     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     */
    class PolygonGeometry {
        /**
         * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IPolygonGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        static fromPositions(options: PolygonGeometry.IPolygonGeometryFromPositionsOptions): PolygonGeometry;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;
        /**
         * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.
         * @param polygonGeometry  (Required) A description of the polygon.
         */
        static createGeometry(polygonGeometry: PolygonGeometry): Geometry;
    }
    /**
     * An hierarchy of linear rings which define a polygon and its holes.
The holes themselves may also have holes which nest inner polygons.
     */
    class PolygonHierarchy {
        /**
         * An hierarchy of linear rings which define a polygon and its holes.
The holes themselves may also have holes which nest inner polygons.
         * @param positions  (Optional) A linear ring defining the outer boundary of the polygon or hole.
         * @param holes  (Optional) An array of polygon hierarchies defining holes in the polygon.
         */
        constructor(positions?: Cartesian3[], holes?: PolygonHierarchy[]);
        /**
         * A linear ring defining the outer boundary of the polygon or hole.
         */
        positions: Cartesian3[];
        /**
         * An array of polygon hierarchies defining holes in the polygon.
         */
        holes: PolygonHierarchy[];
    }
    /**
     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
     */
    class PolygonOutlineGeometry {
        /**
         * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IPolygonOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: PolygonOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: PolygonOutlineGeometry): PolygonOutlineGeometry;
        /**
         * A description of a polygon outline from an array of positions.
         * @param options  (Required) Object with the following properties:
         */
        static fromPositions(options: PolygonOutlineGeometry.IPolygonOutlineGeometryFromPositionsOptions): PolygonOutlineGeometry;
        /**
         * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.
         * @param polygonGeometry  (Required) A description of the polygon outline.
         */
        static createGeometry(polygonGeometry: PolygonOutlineGeometry): Geometry;
    }
    /**
     * A description of a polyline modeled as a line strip; the first two positions define a line segment,
and each additional position defines a line segment from the previous position. The polyline is capable of
displaying with a material.
     */
    class PolylineGeometry {
        /**
         * A description of a polyline modeled as a line strip; the first two positions define a line segment,
and each additional position defines a line segment from the previous position. The polyline is capable of
displaying with a material.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IPolylineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: PolylineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: PolylineGeometry): PolylineGeometry;
        /**
         * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.
         * @param polylineGeometry  (Required) A description of the polyline.
         */
        static createGeometry(polylineGeometry: PolylineGeometry): Geometry;
    }
    /**
     * A description of a polyline with a volume (a 2D shape extruded along a polyline).
     */
    class PolylineVolumeGeometry {
        /**
         * A description of a polyline with a volume (a 2D shape extruded along a polyline).
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IPolylineVolumeGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: PolylineVolumeGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeGeometry): PolylineVolumeGeometry;
        /**
         * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.
         * @param polylineVolumeGeometry  (Required) A description of the polyline volume.
         */
        static createGeometry(polylineVolumeGeometry: PolylineVolumeGeometry): Geometry;
    }
    /**
     * A description of a polyline with a volume (a 2D shape extruded along a polyline).
     */
    class PolylineVolumeOutlineGeometry {
        /**
         * A description of a polyline with a volume (a 2D shape extruded along a polyline).
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IPolylineVolumeOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: PolylineVolumeOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeOutlineGeometry): PolylineVolumeOutlineGeometry;
        /**
         * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.
         * @param polylineVolumeOutlineGeometry  (Required) A description of the polyline volume outline.
         */
        static createGeometry(polylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry): Geometry;
    }
    /**
     * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized
mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed
as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner
of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile
and 32767 at the maximum height in the tile.
     */
    class QuantizedMeshTerrainData {
        /**
         * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized
mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed
as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner
of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile
and 32767 at the maximum height in the tile.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IQuantizedMeshTerrainDataOptions);
        /**
         * The water mask included in this terrain data, if any.  A water mask is a rectangular
Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
         */
        waterMask: Uint8Array|HTMLImageElement|HTMLCanvasElement;
        /**
         * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
vertices in this instance, interpolated if necessary.
         * @param tilingScheme  (Required) The tiling scheme of this terrain data.
         * @param thisX  (Required) The X coordinate of this tile in the tiling scheme.
         * @param thisY  (Required) The Y coordinate of this tile in the tiling scheme.
         * @param thisLevel  (Required) The level of this tile in the tiling scheme.
         * @param descendantX  (Required) The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantY  (Required) The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantLevel  (Required) The level within the tiling scheme of the descendant tile for which we are upsampling.
         */
        upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<QuantizedMeshTerrainData>;
        /**
         * Computes the terrain height at a specified longitude and latitude.
         * @param rectangle  (Required) The rectangle covered by this terrain data.
         * @param longitude  (Required) The longitude in radians.
         * @param latitude  (Required) The latitude in radians.
         */
        interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
        /**
         * Determines if a given child tile is available, based on the
{@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
to be one of the four children of this tile.  If non-child tile coordinates are
given, the availability of the southeast child tile is returned.
         * @param thisX  (Required) The tile X coordinate of this (the parent) tile.
         * @param thisY  (Required) The tile Y coordinate of this (the parent) tile.
         * @param childX  (Required) The tile X coordinate of the child tile to check for availability.
         * @param childY  (Required) The tile Y coordinate of the child tile to check for availability.
         */
        isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): Boolean;
        /**
         * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
terrain data.  If this value is false, the data was obtained from some other source, such
as by downloading it from a remote server.  This method should return true for instances
returned from a call to {@link HeightmapTerrainData#upsample}.
         */
        wasCreatedByUpsampling(): Boolean;
    }
    /**
     * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
     */
    class Quaternion {
        /**
         * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
         * @param x  (Optional) The X component.
         * @param y  (Optional) The Y component.
         * @param z  (Optional) The Z component.
         * @param w  (Optional) The W component.
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * The X component.
         */
        x: number;
        /**
         * The Y component.
         */
        y: number;
        /**
         * The Z component.
         */
        z: number;
        /**
         * The W component.
         */
        w: number;
        /**
         * Computes a quaternion representing a rotation around an axis.
         * @param axis  (Required) The axis of rotation.
         * @param angle  (Required) The angle in radians to rotate around the axis.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromAxisAngle(axis: Cartesian3, angle: number, result?: Quaternion): Quaternion;
        /**
         * Computes a Quaternion from the provided Matrix3 instance.
         * @param matrix  (Required) The rotation matrix.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromRotationMatrix(matrix: Matrix3, result?: Quaternion): Quaternion;
        /**
         * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
the positive x axis.
         * @param heading  (Required) The heading angle in radians.
         * @param pitch  (Required) The pitch angle in radians.
         * @param roll  (Required) The roll angle in radians.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromHeadingPitchRoll(heading: number, pitch: number, roll: number, result?: Quaternion): Quaternion;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Quaternion, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Quaternion): Quaternion;
        /**
         * The number of elements used to store the object into an array in its interpolatable form.
         */
        packedInterpolationLength: number;
        /**
         * Converts a packed array into a form suitable for interpolation.
         * @param packedArray  (Required) The packed array.
         * @param startingIndex  (Optional) The index of the first element to be converted.
         * @param lastIndex  (Optional) The index of the last element to be converted.
         * @param result  (Optional) The object into which to store the result.
         */
        static convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
        /**
         * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
         * @param array  (Required) The array previously packed for interpolation.
         * @param sourceArray  (Required) The original packed array.
         * @param startingIndex  (Optional) The startingIndex used to convert the array.
         * @param lastIndex  (Optional) The lastIndex used to convert the array.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: Quaternion): Quaternion;
        /**
         * Duplicates a Quaternion instance.
         * @param quaternion  (Required) The quaternion to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(quaternion: Quaternion, result?: Quaternion): Quaternion;
        /**
         * Computes the conjugate of the provided quaternion.
         * @param quaternion  (Required) The quaternion to conjugate.
         * @param result  (Required) The object onto which to store the result.
         */
        static conjugate(quaternion: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes magnitude squared for the provided quaternion.
         * @param quaternion  (Required) The quaternion to conjugate.
         */
        static magnitudeSquared(quaternion: Quaternion): number;
        /**
         * Computes magnitude for the provided quaternion.
         * @param quaternion  (Required) The quaternion to conjugate.
         */
        static magnitude(quaternion: Quaternion): number;
        /**
         * Computes the normalized form of the provided quaternion.
         * @param quaternion  (Required) The quaternion to normalize.
         * @param result  (Required) The object onto which to store the result.
         */
        static normalize(quaternion: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes the inverse of the provided quaternion.
         * @param quaternion  (Required) The quaternion to normalize.
         * @param result  (Required) The object onto which to store the result.
         */
        static inverse(quaternion: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes the componentwise sum of two quaternions.
         * @param left  (Required) The first quaternion.
         * @param right  (Required) The second quaternion.
         * @param result  (Required) The object onto which to store the result.
         */
        static add(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes the componentwise difference of two quaternions.
         * @param left  (Required) The first quaternion.
         * @param right  (Required) The second quaternion.
         * @param result  (Required) The object onto which to store the result.
         */
        static subtract(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
        /**
         * Negates the provided quaternion.
         * @param quaternion  (Required) The quaternion to be negated.
         * @param result  (Required) The object onto which to store the result.
         */
        static negate(quaternion: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes the dot (scalar) product of two quaternions.
         * @param left  (Required) The first quaternion.
         * @param right  (Required) The second quaternion.
         */
        static dot(left: Quaternion, right: Quaternion): number;
        /**
         * Computes the product of two quaternions.
         * @param left  (Required) The first quaternion.
         * @param right  (Required) The second quaternion.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiply(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
        /**
         * Multiplies the provided quaternion componentwise by the provided scalar.
         * @param quaternion  (Required) The quaternion to be scaled.
         * @param scalar  (Required) The scalar to multiply with.
         * @param result  (Required) The object onto which to store the result.
         */
        static multiplyByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
        /**
         * Divides the provided quaternion componentwise by the provided scalar.
         * @param quaternion  (Required) The quaternion to be divided.
         * @param scalar  (Required) The scalar to divide by.
         * @param result  (Required) The object onto which to store the result.
         */
        static divideByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
        /**
         * Computes the axis of rotation of the provided quaternion.
         * @param quaternion  (Required) The quaternion to use.
         * @param result  (Required) The object onto which to store the result.
         */
        static computeAxis(quaternion: Quaternion, result: Cartesian3): Cartesian3;
        /**
         * Computes the angle of rotation of the provided quaternion.
         * @param quaternion  (Required) The quaternion to use.
         */
        static computeAngle(quaternion: Quaternion): number;
        /**
         * Computes the linear interpolation or extrapolation at t using the provided quaternions.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static lerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
        /**
         * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static slerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
        /**
         * The logarithmic quaternion function.
         * @param quaternion  (Required) The unit quaternion.
         * @param result  (Required) The object onto which to store the result.
         */
        static log(quaternion: Quaternion, result: Cartesian3): Cartesian3;
        /**
         * The exponential quaternion function.
         * @param cartesian  (Required) The cartesian.
         * @param result  (Required) The object onto which to store the result.
         */
        static exp(cartesian: Cartesian3, result: Quaternion): Quaternion;
        /**
         * Computes an inner quadrangle point.
<p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
         * @param q0  (Required) The first quaternion.
         * @param q1  (Required) The second quaternion.
         * @param q2  (Required) The third quaternion.
         * @param result  (Required) The object onto which to store the result.
         */
        static computeInnerQuadrangle(q0: Quaternion, q1: Quaternion, q2: Quaternion, result: Quaternion): Quaternion;
        /**
         * Computes the spherical quadrangle interpolation between quaternions.
         * @param q0  (Required) The first quaternion.
         * @param q1  (Required) The second quaternion.
         * @param s0  (Required) The first inner quadrangle.
         * @param s1  (Required) The second inner quadrangle.
         * @param t  (Required) The time in [0,1] used to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static squad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
        /**
         * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
         * @param start  (Required) The value corresponding to t at 0.0.
         * @param end  (Required) The value corresponding to t at 1.0.
         * @param t  (Required) The point along t at which to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static fastSlerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
        /**
         * Computes the spherical quadrangle interpolation between quaternions.
An implementation that is faster than {@link Quaternion#squad}, but less accurate.
         * @param q0  (Required) The first quaternion.
         * @param q1  (Required) The second quaternion.
         * @param s0  (Required) The first inner quadrangle.
         * @param s1  (Required) The second inner quadrangle.
         * @param t  (Required) The time in [0,1] used to interpolate.
         * @param result  (Required) The object onto which to store the result.
         */
        static fastSquad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
        /**
         * Compares the provided quaternions componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first quaternion.
         * @param right  (Optional) The second quaternion.
         */
        static equals(left?: Quaternion, right?: Quaternion): Boolean;
        /**
         * Compares the provided quaternions componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param left  (Optional) The first quaternion.
         * @param right  (Optional) The second quaternion.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        static equalsEpsilon(left?: Quaternion, right?: Quaternion, epsilon?: number): Boolean;
        /**
         * Duplicates this Quaternion instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Quaternion): Quaternion;
        /**
         * Compares this and the provided quaternion componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side quaternion.
         */
        equals(right?: Quaternion): Boolean;
        /**
         * Compares this and the provided quaternion componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side quaternion.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(right?: Quaternion, epsilon?: number): Boolean;
        /**
         * Returns a string representing this quaternion in the format (x, y, z, w).
         */
        toString(): string;
    }
    /**
     * A spline that uses spherical quadrangle (squad) interpolation to create a quaternion curve.
The generated curve is in the class C<sup>1</sup>.
     */
    class QuaternionSpline {
        /**
         * A spline that uses spherical quadrangle (squad) interpolation to create a quaternion curve.
The generated curve is in the class C<sup>1</sup>.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IQuaternionSplineOptions);
        /**
         * An array of times for the control points.
         */
        times: number[];
        /**
         * An array of {@link Quaternion} control points.
         */
        points: Quaternion[];
        /**
         * An array of {@link Quaternion} inner quadrangles for the control points.
         */
        innerQuadrangles: Quaternion[];
        /**
         * Finds an index <code>i</code> in <code>times</code> such that the parameter
<code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
         * @param time  (Required) The time.
         */
        findTimeInterval(time: number): number;
        /**
         * Evaluates the curve at a given time.
         * @param time  (Required) The time at which to evaluate the curve.
         * @param result  (Optional) The object onto which to store the result.
         */
        evaluate(time: number, result?: Quaternion): Quaternion;
    }
    /**
     * A queue that can enqueue items at the end, and dequeue items from the front.
     */
    class Queue {
        /**
         * A queue that can enqueue items at the end, and dequeue items from the front.
         */
        constructor();
        /**
         * The length of the queue.
         */
        length: number;
        /**
         * Enqueues the specified item.
         * @param item  (Required) The item to enqueue.
         */
        enqueue(item: any): void;
        /**
         * Dequeues an item.  Returns undefined if the queue is empty.
         */
        dequeue(): any;
        /**
         * Returns the item at the front of the queue.  Returns undefined if the queue is empty.
         */
        peek(): any;
        /**
         * Check whether this queue contains the specified item.
         * @param item  (Required) The item to search for.
         */
        contains(item: any): void;
        /**
         * Remove all items from the queue.
         */
        clear(): void;
        /**
         * Sort the items in the queue in-place.
         * @param compareFunction  (Required) A function that defines the sort order.
         */
        sort(compareFunction: Queue.Comparator): void;
    }
    /**
     * Represents a ray that extends infinitely from the provided origin in the provided direction.
     */
    class Ray {
        /**
         * Represents a ray that extends infinitely from the provided origin in the provided direction.
         * @param origin  (Optional) The origin of the ray.
         * @param direction  (Optional) The direction of the ray.
         */
        constructor(origin?: Cartesian3, direction?: Cartesian3);
        /**
         * The origin of the ray.
         */
        origin: Cartesian3;
        /**
         * The direction of the ray.
         */
        direction: Cartesian3;
        /**
         * Computes the point along the ray given by r(t) = o + t*d,
where o is the origin of the ray and d is the direction.
         * @param ray  (Required) The ray.
         * @param t  (Required) A scalar value.
         * @param result  (Optional) The object in which the result will be stored.
         */
        static getPoint(ray: Ray, t: number, result?: Cartesian3): Cartesian3;
    }
    /**
     * A two dimensional region specified as longitude and latitude coordinates.
     */
    class Rectangle {
        /**
         * A two dimensional region specified as longitude and latitude coordinates.
         * @param west  (Optional) The westernmost longitude, in radians, in the range [-Pi, Pi].
         * @param south  (Optional) The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
         * @param east  (Optional) The easternmost longitude, in radians, in the range [-Pi, Pi].
         * @param north  (Optional) The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
         */
        constructor(west?: number, south?: number, east?: number, north?: number);
        /**
         * The westernmost longitude in radians in the range [-Pi, Pi].
         */
        west: number;
        /**
         * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
         */
        south: number;
        /**
         * The easternmost longitude in radians in the range [-Pi, Pi].
         */
        east: number;
        /**
         * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
         */
        north: number;
        /**
         * Gets the width of the rectangle in radians.
         */
        width: number;
        /**
         * Gets the height of the rectangle in radians.
         */
        height: number;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: Rectangle, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: Rectangle): Rectangle;
        /**
         * Computes the width of a rectangle in radians.
         * @param rectangle  (Required) The rectangle to compute the width of.
         */
        static computeWidth(rectangle: Rectangle): number;
        /**
         * Computes the height of a rectangle in radians.
         * @param rectangle  (Required) The rectangle to compute the height of.
         */
        static computeHeight(rectangle: Rectangle): number;
        /**
         * Creates an rectangle given the boundary longitude and latitude in degrees.
         * @param west  (Optional) The westernmost longitude in degrees in the range [-180.0, 180.0].
         * @param south  (Optional) The southernmost latitude in degrees in the range [-90.0, 90.0].
         * @param east  (Optional) The easternmost longitude in degrees in the range [-180.0, 180.0].
         * @param north  (Optional) The northernmost latitude in degrees in the range [-90.0, 90.0].
         * @param result  (Optional) The object onto which to store the result, or undefined if a new instance should be created.
         */
        static fromDegrees(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;
        /**
         * Creates the smallest possible Rectangle that encloses all positions in the provided array.
         * @param cartographics  (Required) The list of Cartographic instances.
         * @param result  (Optional) The object onto which to store the result, or undefined if a new instance should be created.
         */
        static fromCartographicArray(cartographics: Cartographic[], result?: Rectangle): Rectangle;
        /**
         * Creates the smallest possible Rectangle that encloses all positions in the provided array.
         * @param cartesians  (Required) The list of Cartesian instances.
         * @param ellipsoid  (Optional) The ellipsoid the cartesians are on.
         * @param result  (Optional) The object onto which to store the result, or undefined if a new instance should be created.
         */
        static fromCartesianArray(cartesians: (Cartesian2|Cartesian3|Cartesian4)[], ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle;
        /**
         * Duplicates an Rectangle.
         * @param rectangle  (Required) The rectangle to clone.
         * @param result  (Optional) The object onto which to store the result, or undefined if a new instance should be created.
         */
        static clone(rectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Duplicates this Rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: Rectangle): Rectangle;
        /**
         * Compares the provided Rectangle with this Rectangle componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The Rectangle to compare.
         */
        equals(other?: Rectangle): Boolean;
        /**
         * Compares the provided rectangles and returns <code>true</code> if they are equal,
<code>false</code> otherwise.
         * @param left  (Optional) The first Rectangle.
         * @param right  (Optional) The second Rectangle.
         */
        static equals(left?: Rectangle, right?: Rectangle): Boolean;
        /**
         * Compares the provided Rectangle with this Rectangle componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param other  (Optional) The Rectangle to compare.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         */
        equalsEpsilon(other?: Rectangle, epsilon?: number): Boolean;
        /**
         * Checks an Rectangle's properties and throws if they are not in valid ranges.
         * @param rectangle  (Required) The rectangle to validate
         */
        static validate(rectangle: Rectangle): void;
        /**
         * Computes the southwest corner of an rectangle.
         * @param rectangle  (Required) The rectangle for which to find the corner
         * @param result  (Optional) The object onto which to store the result.
         */
        static southwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
        /**
         * Computes the northwest corner of an rectangle.
         * @param rectangle  (Required) The rectangle for which to find the corner
         * @param result  (Optional) The object onto which to store the result.
         */
        static northwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
        /**
         * Computes the northeast corner of an rectangle.
         * @param rectangle  (Required) The rectangle for which to find the corner
         * @param result  (Optional) The object onto which to store the result.
         */
        static northeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
        /**
         * Computes the southeast corner of an rectangle.
         * @param rectangle  (Required) The rectangle for which to find the corner
         * @param result  (Optional) The object onto which to store the result.
         */
        static southeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
        /**
         * Computes the center of an rectangle.
         * @param rectangle  (Required) The rectangle for which to find the center
         * @param result  (Optional) The object onto which to store the result.
         */
        static center(rectangle: Rectangle, result?: Cartographic): Cartographic;
        /**
         * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are
latitude and longitude in radians and produces a correct intersection, taking into account the fact that
the same angle can be represented with multiple values as well as the wrapping of longitude at the
anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
coordinates, see {@link Rectangle.simpleIntersection}.
         * @param rectangle  (Required) On rectangle to find an intersection
         * @param otherRectangle  (Required) Another rectangle to find an intersection
         * @param result  (Optional) The object onto which to store the result.
         */
        static intersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function
does not attempt to put the angular coordinates into a consistent range or to account for crossing the
anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
and longitude (i.e. projected coordinates).
         * @param rectangle  (Required) On rectangle to find an intersection
         * @param otherRectangle  (Required) Another rectangle to find an intersection
         * @param result  (Optional) The object onto which to store the result.
         */
        static simpleIntersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Computes a rectangle that is the union of two rectangles.
         * @param rectangle  (Required) A rectangle to enclose in rectangle.
         * @param otherRectangle  (Required) A rectangle to enclose in a rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static union(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.
         * @param rectangle  (Required) A rectangle to expand.
         * @param cartographic  (Required) A cartographic to enclose in a rectangle.
         * @param result  (Optional) The object onto which to store the result.
         */
        static expand(rectangle: Rectangle, cartographic: Cartographic, result?: Rectangle): Rectangle;
        /**
         * Returns true if the cartographic is on or inside the rectangle, false otherwise.
         * @param rectangle  (Required) The rectangle
         * @param cartographic  (Required) The cartographic to test.
         */
        static contains(rectangle: Rectangle, cartographic: Cartographic): Boolean;
        /**
         * Samples an rectangle so that it includes a list of Cartesian points suitable for passing to
{@link BoundingSphere#fromPoints}.  Sampling is necessary to account
for rectangles that cover the poles or cross the equator.
         * @param rectangle  (Required) The rectangle to subsample.
         * @param ellipsoid  (Optional) The ellipsoid to use.
         * @param surfaceHeight  (Optional) The height of the rectangle above the ellipsoid.
         * @param result  (Optional) The array of Cartesians onto which to store the result.
         */
        static subsample(rectangle: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: Cartesian3[]): Cartesian3[];
    }
    /**
     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     */
    class RectangleGeometry {
        /**
         * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IRectangleGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: RectangleGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: RectangleGeometry): RectangleGeometry;
        /**
         * Computes the geometric representation of an rectangle, including its vertices, indices, and a bounding sphere.
         * @param rectangleGeometry  (Required) A description of the rectangle.
         */
        static createGeometry(rectangleGeometry: RectangleGeometry): Geometry;
    }
    /**
     * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.
     */
    class RectangleOutlineGeometry {
        /**
         * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IRectangleOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: RectangleOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: RectangleOutlineGeometry): RectangleOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of an rectangle, including its vertices, indices, and a bounding sphere.
         * @param rectangleGeometry  (Required) A description of the rectangle outline.
         */
        static createGeometry(rectangleGeometry: RectangleOutlineGeometry): Geometry;
    }
    /**
     * An event that is raised when a request encounters an error.
     */
    class RequestErrorEvent {
        /**
         * An event that is raised when a request encounters an error.
         * @param statusCode  (Optional) The HTTP error status code, such as 404.
         * @param response  (Optional) The response included along with the error.
         * @param responseHeaders  (Optional) The response headers, represented either as an object literal or as a
                       string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
         */
        constructor(statusCode?: number, response?: any, responseHeaders?: string|any);
        /**
         * The HTTP error status code, such as 404.  If the error does not have a particular
HTTP code, this property will be undefined.
         */
        statusCode: number;
        /**
         * The response included along with the error.  If the error does not include a response,
this property will be undefined.
         */
        response: any;
        /**
         * The headers included in the response, represented as an object literal of key/value pairs.
If the error does not include any headers, this property will be undefined.
         */
        responseHeaders: any;
        /**
         * Creates a string representing this RequestErrorEvent.
         */
        toString(): string;
    }
    /**
     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
out of memory, could not compile shader, etc.  If a function may throw this
exception, the calling code should be prepared to catch it.
<br /><br />
On the other hand, a {@link DeveloperError} indicates an exception due
to a developer error, e.g., invalid argument, that usually indicates a bug in the
calling code.
     */
    class RuntimeError extends Error {
        /**
         * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
out of memory, could not compile shader, etc.  If a function may throw this
exception, the calling code should be prepared to catch it.
<br /><br />
On the other hand, a {@link DeveloperError} indicates an exception due
to a developer error, e.g., invalid argument, that usually indicates a bug in the
calling code.
         * @param message  (Optional) The error message for this exception.
         */
        constructor(message?: string);
        /**
         * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
         */
        name: string;
        /**
         * The explanation for why this exception was thrown.
         */
        message: string;
        /**
         * The stack trace of this exception, if available.
         */
        stack: string;
    }
    /**
     * Handles user input events. Custom functions can be added to be executed on
when the user enters input.
     */
    class ScreenSpaceEventHandler {
        /**
         * Handles user input events. Custom functions can be added to be executed on
when the user enters input.
         * @param element  (Optional) The element to add events to.
         */
        constructor(element?: HTMLCanvasElement);
        /**
         * Set a function to be executed on an input event.
         * @param action  (Required) Function to be executed when the input event occurs.
         * @param type  (Required) The ScreenSpaceEventType of input event.
         * @param modifier  (Optional) A KeyboardEventModifier key that is held when a <code>type</code>
event occurs.
         */
        setInputAction(action: Function, type: number, modifier?: number): void;
        /**
         * Returns the function to be executed on an input event.
         * @param type  (Required) The ScreenSpaceEventType of input event.
         * @param modifier  (Optional) A KeyboardEventModifier key that is held when a <code>type</code>
event occurs.
         */
        getInputAction(type: number, modifier?: number): void;
        /**
         * Removes the function to be executed on an input event.
         * @param type  (Required) The ScreenSpaceEventType of input event.
         * @param modifier  (Optional) A KeyboardEventModifier key that is held when a <code>type</code>
event occurs.
         */
        removeInputAction(type: number, modifier?: number): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Removes listeners held by this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.
     */
    class ShowGeometryInstanceAttribute {
        /**
         * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.
         * @param show  (Optional) Determines if the geometry instance will be shown.
         */
        constructor(show?: Boolean);
        /**
         * The values for the attributes stored in a typed array.
         */
        value: Uint8Array;
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
{@link ColorGeometryInstanceAttribute#value}.
         */
        componentDatatype: number;
        /**
         * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
         */
        componentsPerAttribute: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
indicate that the components should be mapped to the range [0, 1] (unsigned)
or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         */
        normalize: Boolean;
        /**
         * Converts a boolean show to a typed array that can be used to assign a show attribute.
         * @param show  (Required) The show value.
         * @param result  (Optional) The array to store the result in, if undefined a new instance will be created.
         */
        static toValue(show: Boolean, result?: Uint8Array): Uint8Array;
    }
    /**
     * A description of a polyline modeled as a line strip; the first two positions define a line segment,
and each additional position defines a line segment from the previous position.
     */
    class SimplePolylineGeometry {
        /**
         * A description of a polyline modeled as a line strip; the first two positions define a line segment,
and each additional position defines a line segment from the previous position.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ISimplePolylineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: SimplePolylineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: SimplePolylineGeometry): SimplePolylineGeometry;
        /**
         * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.
         * @param simplePolylineGeometry  (Required) A description of the polyline.
         */
        static createGeometry(simplePolylineGeometry: SimplePolylineGeometry): Geometry;
    }
    /**
     * A description of a sphere centered at the origin.
     */
    class SphereGeometry {
        /**
         * A description of a sphere centered at the origin.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ISphereGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: SphereGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: SphereGeometry): SphereGeometry;
        /**
         * Computes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.
         * @param sphereGeometry  (Required) A description of the sphere.
         */
        static createGeometry(sphereGeometry: SphereGeometry): Geometry;
    }
    /**
     * A description of the outline of a sphere.
     */
    class SphereOutlineGeometry {
        /**
         * A description of the outline of a sphere.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ISphereOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: SphereOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: SphereOutlineGeometry): SphereOutlineGeometry;
        /**
         * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.
         * @param sphereGeometry  (Required) A description of the sphere outline.
         */
        static createGeometry(sphereGeometry: SphereOutlineGeometry): Geometry;
    }
    /**
     * A set of curvilinear 3-dimensional coordinates.
     */
    class Spherical {
        /**
         * A set of curvilinear 3-dimensional coordinates.
         * @param clock  (Optional) The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
         * @param cone  (Optional) The angular coordinate measured from the positive z-axis and toward the negative z-axis.
         * @param magnitude  (Optional) The linear coordinate measured from the origin.
         */
        constructor(clock?: number, cone?: number, magnitude?: number);
        /**
         * Converts the provided Cartesian3 into Spherical coordinates.
         * @param cartesian3  (Required) The Cartesian3 to be converted to Spherical.
         * @param spherical  (Optional) The object in which the result will be stored, if undefined a new instance will be created.
         */
        static fromCartesian3(cartesian3: Cartesian3, spherical?: Spherical): Spherical;
        /**
         * Creates a duplicate of a Spherical.
         * @param spherical  (Required) The spherical to clone.
         * @param result  (Optional) The object to store the result into, if undefined a new instance will be created.
         */
        static clone(spherical: Spherical, result?: Spherical): Spherical;
        /**
         * Computes the normalized version of the provided spherical.
         * @param spherical  (Required) The spherical to be normalized.
         * @param result  (Optional) The object to store the result into, if undefined a new instance will be created.
         */
        static normalize(spherical: Spherical, result?: Spherical): Spherical;
        /**
         * Returns true if the first spherical is equal to the second spherical, false otherwise.
         * @param left  (Required) The first Spherical to be compared.
         * @param right  (Required) The second Spherical to be compared.
         */
        static equals(left: Spherical, right: Spherical): Boolean;
        /**
         * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
         * @param left  (Required) The first Spherical to be compared.
         * @param right  (Required) The second Spherical to be compared.
         * @param epsilon  (Optional) The epsilon to compare against.
         */
        static equalsEpsilon(left: Spherical, right: Spherical, epsilon?: number): Boolean;
        /**
         * Returns true if this spherical is equal to the provided spherical, false otherwise.
         * @param other  (Required) The Spherical to be compared.
         */
        equals(other: Spherical): Boolean;
        /**
         * Creates a duplicate of this Spherical.
         * @param result  (Optional) The object to store the result into, if undefined a new instance will be created.
         */
        clone(result?: Spherical): Spherical;
        /**
         * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
         * @param other  (Required) The Spherical to be compared.
         * @param epsilon  (Required) The epsilon to compare against.
         */
        equalsEpsilon(other: Spherical, epsilon: number): Boolean;
        /**
         * Returns a string representing this instance in the format (clock, cone, magnitude).
         */
        toString(): string;
    }
    /**
     * Creates a curve parameterized and evaluated by time. This type describes an interface
and is not intended to be instantiated directly.
     */
    class Spline {
        /**
         * Creates a curve parameterized and evaluated by time. This type describes an interface
and is not intended to be instantiated directly.
         */
        constructor();
        /**
         * An array of times for the control points.
         */
        times: number[];
        /**
         * An array of control points.
         */
        points: Cartesian3[]|Quaternion[];
        /**
         * Evaluates the curve at a given time.
         * @param time  (Required) The time at which to evaluate the curve.
         * @param result  (Optional) The object onto which to store the result.
         */
        evaluate(time: number, result?: Cartesian3|Quaternion): Cartesian3|Quaternion;
        /**
         * Finds an index <code>i</code> in <code>times</code> such that the parameter
<code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
         * @param time  (Required) The time.
         * @param startIndex  (Required) The index from which to start the search.
         */
        findTimeInterval(time: number, startIndex: number): number;
    }
    /**
     * A wrapper around a web worker that allows scheduling tasks for a given worker,
returning results asynchronously via a promise.

The Worker is not constructed until a task is scheduled.
     */
    class TaskProcessor {
        /**
         * A wrapper around a web worker that allows scheduling tasks for a given worker,
returning results asynchronously via a promise.

The Worker is not constructed until a task is scheduled.
         * @param workerName  (Required) The name of the worker.  This is expected to be a script
                           in the Workers folder.
         * @param maximumActiveTasks  (Optional) The maximum number of active tasks.  Once exceeded,
                                       scheduleTask will not queue any more tasks, allowing
                                       work to be rescheduled in future frames.
         */
        constructor(workerName: string, maximumActiveTasks?: number);
        /**
         * Schedule a task to be processed by the web worker asynchronously.  If there are currently more
tasks active than the maximum set by the constructor, will immediately return undefined.
Otherwise, returns a promise that will resolve to the result posted back by the worker when
finished.
         * @param parameters  (Required) Any input data that will be posted to the worker.
         * @param transferableObjects  (Optional) An array of objects contained in parameters that should be
                                     transferred to the worker instead of copied.
         */
        scheduleTask(parameters: any, transferableObjects?: any[]): Promise<any>;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys this object.  This will immediately terminate the Worker.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        destroy(): void;
    }
    /**
     * Terrain data for a single tile.  This type describes an
interface and is not intended to be instantiated directly.
     */
    class TerrainData {
        /**
         * Terrain data for a single tile.  This type describes an
interface and is not intended to be instantiated directly.
         */
        constructor();
        /**
         * The water mask included in this terrain data, if any.  A water mask is a rectangular
Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
         */
        waterMask: Uint8Array|HTMLImageElement|HTMLCanvasElement;
        /**
         * Computes the terrain height at a specified longitude and latitude.
         * @param rectangle  (Required) The rectangle covered by this terrain data.
         * @param longitude  (Required) The longitude in radians.
         * @param latitude  (Required) The latitude in radians.
         */
        interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
        /**
         * Determines if a given child tile is available, based on the
{@link TerrainData#childTileMask}.  The given child tile coordinates are assumed
to be one of the four children of this tile.  If non-child tile coordinates are
given, the availability of the southeast child tile is returned.
         * @param thisX  (Required) The tile X coordinate of this (the parent) tile.
         * @param thisY  (Required) The tile Y coordinate of this (the parent) tile.
         * @param childX  (Required) The tile X coordinate of the child tile to check for availability.
         * @param childY  (Required) The tile Y coordinate of the child tile to check for availability.
         */
        isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): Boolean;
        /**
         * Upsamples this terrain data for use by a descendant tile.
         * @param tilingScheme  (Required) The tiling scheme of this terrain data.
         * @param thisX  (Required) The X coordinate of this tile in the tiling scheme.
         * @param thisY  (Required) The Y coordinate of this tile in the tiling scheme.
         * @param thisLevel  (Required) The level of this tile in the tiling scheme.
         * @param descendantX  (Required) The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantY  (Required) The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
         * @param descendantLevel  (Required) The level within the tiling scheme of the descendant tile for which we are upsampling.
         */
        upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<TerrainData>;
        /**
         * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
terrain data.  If this value is false, the data was obtained from some other source, such
as by downloading it from a remote server.  This method should return true for instances
returned from a call to {@link TerrainData#upsample}.
         */
        wasCreatedByUpsampling(): Boolean;
    }
    /**
     * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
interface and is not intended to be instantiated directly.
     */
    class TerrainProvider {
        /**
         * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
interface and is not intended to be instantiated directly.
         */
        constructor();
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
the source of the terrain. This function should
not be called before {@link TerrainProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the tiling scheme used by the provider.  This function should
not be called before {@link TerrainProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
indicates which areas of the globe are water rather than land, so they can be rendered
as a reflective surface with animated waves.  This function should not be
called before {@link TerrainProvider#ready} returns true.
         */
        hasWaterMask: Boolean;
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
This function should not be called before {@link TerrainProvider#ready} returns true.
         */
        hasVertexNormals: Boolean;
        /**
         * Gets a list of indices for a triangle mesh representing a regular grid.  Calling
this function multiple times with the same grid width and height returns the
same list of indices.  The total number of vertices must be less than or equal
to 65536.
         * @param width  (Required) The number of vertices in the regular grid in the horizontal direction.
         * @param height  (Required) The number of vertices in the regular grid in the vertical direction.
         */
        static getRegularGridIndices(width: number, height: number): Uint16Array;
        /**
         * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
ensure that adjacent heightmap vertices are separated by no more than
{@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.
A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
screen pixels between adjacent heightmap vertices and thus rendering more quickly.
         */
        heightmapTerrainQuality: number;
        /**
         * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
         * @param ellipsoid  (Required) The ellipsoid to which the terrain is attached.
         * @param tileImageWidth  (Required) The width, in pixels, of the heightmap associated with a single tile.
         * @param numberOfTilesAtLevelZero  (Required) The number of tiles in the horizontal direction at tile level zero.
         */
        static getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid: Ellipsoid, tileImageWidth: number, numberOfTilesAtLevelZero: number): number;
        /**
         * Requests the geometry for a given tile.  This function should not be called before
{@link TerrainProvider#ready} returns true.  The result must include terrain data and
may optionally include a water mask and an indication of which child tiles are available.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         * @param throttleRequests  (Optional) True if the number of simultaneous requests should be limited,
                 or false if the request should be initiated regardless of the number of requests
                 already in progress.
         */
        requestTileGeometry(x: number, y: number, level: number, throttleRequests?: Boolean): Promise<TerrainData>;
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be
called before {@link TerrainProvider#ready} returns true.
         * @param level  (Required) The tile level for which to get the maximum geometric error.
         */
        getLevelMaximumGeometricError(level: number): number;
        /**
         * Determines whether data for a tile is available to be loaded.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        getTileDataAvailable(x: number, y: number, level: number): Boolean;
    }
    /**
     * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.
     */
    class TileProviderError {
        /**
         * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.
         * @param provider  (Required) The imagery or terrain provider that experienced the error.
         * @param message  (Required) A message describing the error.
         * @param x  (Optional) The X coordinate of the tile that experienced the error, or undefined if the error
       is not specific to a particular tile.
         * @param y  (Optional) The Y coordinate of the tile that experienced the error, or undefined if the error
       is not specific to a particular tile.
         * @param level  (Optional) The level of the tile that experienced the error, or undefined if the error
       is not specific to a particular tile.
         * @param timesRetried  (Optional) The number of times this operation has been retried.
         * @param error  (Optional) The error or exception that occurred, if any.
         */
        constructor(provider: ImageryProvider|TerrainProvider, message: string, x?: number, y?: number, level?: number, timesRetried?: number, error?: Error);
        /**
         * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.
         */
        provider: ImageryProvider|TerrainProvider;
        /**
         * The message describing the error.
         */
        message: string;
        /**
         * The X coordinate of the tile that experienced the error.  If the error is not specific
to a particular tile, this property will be undefined.
         */
        x: number;
        /**
         * The Y coordinate of the tile that experienced the error.  If the error is not specific
to a particular tile, this property will be undefined.
         */
        y: number;
        /**
         * The level-of-detail of the tile that experienced the error.  If the error is not specific
to a particular tile, this property will be undefined.
         */
        level: number;
        /**
         * The number of times this operation has been retried.
         */
        timesRetried: number;
        /**
         * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider
will set the initial value of this property before raising the event, but any listeners
can change it.  The value after the last listener is invoked will be acted upon.
         */
        retry: Boolean;
        /**
         * The error or exception that occurred, if any.
         */
        error: Error;
        /**
         * Handles an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by
logging the error to the console if the event has no listeners.  This method also tracks the number
of times the operation has been retried and will automatically retry if requested to do so by the
event listeners.
         * @param previousError  (Required) The error instance returned by this function the last
       time it was called for this error, or undefined if this is the first time this error has
       occurred.
         * @param provider  (Required) The imagery or terrain provider that encountered the error.
         * @param event  (Required) The event to raise to inform listeners of the error.
         * @param message  (Required) The message describing the error.
         * @param x  (Required) The X coordinate of the tile that experienced the error, or undefined if the
       error is not specific to a particular tile.
         * @param y  (Required) The Y coordinate of the tile that experienced the error, or undefined if the
       error is not specific to a particular tile.
         * @param level  (Required) The level-of-detail of the tile that experienced the error, or undefined if the
       error is not specific to a particular tile.
         * @param retryFunction  (Required) The function to call to retry the operation.  If undefined, the
       operation will not be retried.
         * @param errorDetails  (Optional) The error or exception that occurred, if any.
         */
        static handleError(previousError: TileProviderError, provider: ImageryProvider|TerrainProvider, event: Event, message: string, x: number, y: number, level: number, retryFunction: TileProviderError.RetryFunction, errorDetails?: Error): TileProviderError;
        /**
         * Handles success of an operation by resetting the retry count of a previous error, if any.  This way,
if the error occurs again in the future, the listeners will be informed that it has not yet been retried.
         * @param previousError  (Required) The previous error, or undefined if this operation has
       not previously resulted in an error.
         */
        static handleSuccess(previousError: TileProviderError): void;
    }
    /**
     * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
the coarsest, least-detailed level, the number of tiles is configurable.
At level of detail one, each of the level zero tiles has four children, two in each direction.
At level of detail two, each of the level one tiles has four children, two in each direction.
This continues for as many levels as are present in the geometry or imagery source.
     */
    class TilingScheme {
        /**
         * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
the coarsest, least-detailed level, the number of tiles is configurable.
At level of detail one, each of the level zero tiles has four children, two in each direction.
At level of detail two, each of the level one tiles has four children, two in each direction.
This continues for as many levels as are present in the geometry or imagery source.
         */
        constructor();
        /**
         * Gets the ellipsoid that is tiled by the tiling scheme.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the rectangle, in radians, covered by this tiling scheme.
         */
        rectangle: Rectangle;
        /**
         * Gets the map projection used by the tiling scheme.
         */
        projection: MapProjection;
        /**
         * Gets the total number of tiles in the X direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfXTilesAtLevel(level: number): number;
        /**
         * Gets the total number of tiles in the Y direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfYTilesAtLevel(level: number): number;
        /**
         * Transforms an rectangle specified in geodetic radians to the native coordinate system
of this tiling scheme.
         * @param rectangle  (Required) The rectangle to transform.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Converts tile x, y coordinates and level to an rectangle expressed in the native coordinates
of the tiling scheme.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Calculates the tile x, y coordinates of the tile containing
a given cartographic position.
         * @param position  (Required) The position.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
    }
    /**
     * An interval defined by a start and a stop time; optionally including those times as part of the interval.
Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
     */
    class TimeInterval {
        /**
         * An interval defined by a start and a stop time; optionally including those times as part of the interval.
Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ITimeIntervalOptions);
        /**
         * Gets or sets the start time of this interval.
         */
        start: JulianDate;
        /**
         * Gets or sets the stop time of this interval.
         */
        stop: JulianDate;
        /**
         * Gets or sets the data associated with this interval.
         */
        data: any;
        /**
         * Gets or sets whether or not the start time is included in this interval.
         */
        isStartIncluded: Boolean;
        /**
         * Gets or sets whether or not the stop time is included in this interval.
         */
        isStopIncluded: Boolean;
        /**
         * Gets whether or not this interval is empty.
         */
        isEmpty: Boolean;
        /**
         * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
         * @param options  (Required) Object with the following properties:
         * @param result  (Optional) An existing instance to use for the result.
         */
        static fromIso8601(options: TimeInterval.ITimeIntervalFromIso8601Options, result?: TimeInterval): TimeInterval;
        /**
         * Creates an ISO8601 representation of the provided interval.
         * @param timeInterval  (Required) The interval to be converted.
         * @param precision  (Optional) The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
         */
        static toIso8601(timeInterval: TimeInterval, precision?: number): string;
        /**
         * Duplicates the provided instance.
         * @param timeInterval  (Optional) The instance to clone.
         * @param result  (Optional) An existing instance to use for the result.
         */
        static clone(timeInterval?: TimeInterval, result?: TimeInterval): TimeInterval;
        /**
         * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         * @param left  (Optional) The first instance.
         * @param right  (Optional) The second instance.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        static equals(left?: TimeInterval, right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): Boolean;
        /**
         * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
each other.  That is, in order for the dates to be considered equal (and for
this function to return <code>true</code>), the absolute value of the difference between them, in
seconds, must be less than <code>epsilon</code>.
         * @param left  (Optional) The first instance.
         * @param right  (Optional) The second instance.
         * @param epsilon  (Optional) The maximum number of seconds that should separate the two instances.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        static equalsEpsilon(left?: TimeInterval, right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): Boolean;
        /**
         * Computes the intersection of two intervals, optionally merging their data.
         * @param left  (Required) The first interval.
         * @param right  (Optional) The second interval.
         * @param result  (Optional) An existing instance to use for the result.
         * @param mergeCallback  (Optional) A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
         */
        static intersect(left: TimeInterval, right?: TimeInterval, result?: TimeInterval, mergeCallback?: TimeInterval.MergeCallback): TimeInterval;
        /**
         * Checks if the specified date is inside the provided interval.
         * @param timeInterval  (Required) The interval.
         * @param julianDate  (Required) The date to check.
         */
        static contains(timeInterval: TimeInterval, julianDate: JulianDate): Boolean;
        /**
         * Duplicates this instance.
         * @param result  (Optional) An existing instance to use for the result.
         */
        clone(result?: TimeInterval): TimeInterval;
        /**
         * Compares this instance against the provided instance componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side interval.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        equals(right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): Boolean;
        /**
         * Compares this instance against the provided instance componentwise and returns
<code>true</code> if they are within the provided epsilon,
<code>false</code> otherwise.
         * @param right  (Optional) The right hand side interval.
         * @param epsilon  (Optional) The epsilon to use for equality testing.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        equalsEpsilon(right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): Boolean;
        /**
         * Creates a string representing this TimeInterval in ISO8601 format.
         */
        toString(): string;
    }
    /**
     * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
     */
    class TimeIntervalCollection {
        /**
         * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
         * @param intervals  (Optional) An array of intervals to add to the collection.
         */
        constructor(intervals?: TimeInterval[]);
        /**
         * Gets an event that is raised whenever the collection of intervals change.
         */
        changedEvent: Event;
        /**
         * Gets the start time of the collection.
         */
        start: JulianDate;
        /**
         * Gets whether or not the start time is included in the collection.
         */
        isStartIncluded: Boolean;
        /**
         * Gets the stop time of the collection.
         */
        stop: JulianDate;
        /**
         * Gets whether or not the stop time is included in the collection.
         */
        isStopIncluded: Boolean;
        /**
         * Gets the number of intervals in the collection.
         */
        length: number;
        /**
         * Gets whether or not the collection is empty.
         */
        isEmpty: Boolean;
        /**
         * Compares this instance against the provided instance componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side collection.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        equals(right?: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer): Boolean;
        /**
         * Gets the interval at the specified index.
         * @param index  (Required) The index of the interval to retrieve.
         */
        get(index: number): TimeInterval;
        /**
         * Removes all intervals from the collection.
         */
        removeAll(): void;
        /**
         * Finds and returns the interval that contains the specified date.
         * @param date  (Required) The date to search for.
         */
        findIntervalContainingDate(date: JulianDate): TimeInterval;
        /**
         * Finds and returns the data for the interval that contains the specified date.
         * @param date  (Required) The date to search for.
         */
        findDataForIntervalContainingDate(date: JulianDate): any;
        /**
         * Checks if the specified date is inside this collection.
         * @param julianDate  (Required) The date to check.
         */
        contains(julianDate: JulianDate): Boolean;
        /**
         * Finds and returns the index of the interval in the collection that contains the specified date.
         * @param date  (Required) The date to search for.
         */
        indexOf(date: JulianDate): number;
        /**
         * Returns the first interval in the collection that matches the specified parameters.
All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.
         * @param options  (Optional) Object with the following properties:
         */
        findInterval(options?: TimeIntervalCollection.ITimeIntervalCollectionFindIntervalOptions): TimeInterval;
        /**
         * Adds an interval to the collection, merging intervals that contain the same data and
splitting intervals of different data as needed in order to maintain a non-overlapping collection.
The data in the new interval takes precedence over any existing intervals in the collection.
         * @param interval  (Required) The interval to add.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         */
        addInterval(interval: TimeInterval, dataComparer?: TimeInterval.DataComparer): void;
        /**
         * Removes the specified interval from this interval collection, creating a hole over the specified interval.
The data property of the input interval is ignored.
         * @param interval  (Required) The interval to remove.
         */
        removeInterval(interval: TimeInterval): void;
        /**
         * Creates a new instance that is the intersection of this collection and the provided collection.
         * @param other  (Required) The collection to intersect with.
         * @param dataComparer  (Optional) A function which compares the data of the two intervals.  If omitted, reference equality is used.
         * @param mergeCallback  (Optional) A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
         */
        intersect(other: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer, mergeCallback?: TimeInterval.MergeCallback): TimeIntervalCollection;
    }
    /**
     * An affine transformation defined by a translation, rotation, and scale.
     */
    class TranslationRotationScale {
        /**
         * An affine transformation defined by a translation, rotation, and scale.
         * @param translation  (Optional) A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.
         * @param rotation  (Optional) A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.
         * @param scale  (Optional) A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.
         */
        constructor(translation?: Cartesian3, rotation?: Quaternion, scale?: Cartesian3);
        /**
         * Gets or sets the (x, y, z) translation to apply to the node.
         */
        translation: Cartesian3;
        /**
         * Gets or sets the (x, y, z, w) rotation to apply to the node.
         */
        rotation: Quaternion;
        /**
         * Gets or sets the (x, y, z) scaling to apply to the node.
         */
        scale: Cartesian3;
        /**
         * Compares this instance against the provided instance and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param right  (Optional) The right hand side TranslationRotationScale.
         */
        equals(right?: TranslationRotationScale): Boolean;
    }
    /**
     * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided
to a {@link Geometry} to request that certain properties be computed, e.g., just position,
position and normal, etc.
     */
    class VertexFormat {
        /**
         * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided
to a {@link Geometry} to request that certain properties be computed, e.g., just position,
position and normal, etc.
         * @param options  (Optional) An object with boolean properties corresponding to VertexFormat properties as shown in the code example.
         */
        constructor(options?: any);
        /**
         * When <code>true</code>, the vertex has a 3D position attribute.
<p>
64-bit floating-point (for precision).  3 components per attribute.
</p>
         */
        position: Boolean;
        /**
         * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        normal: Boolean;
        /**
         * When <code>true</code>, the vertex has a 2D texture coordinate attribute.
<p>
32-bit floating-point.  2 components per attribute
</p>
         */
        st: Boolean;
        /**
         * When <code>true</code>, the vertex has a binormal attribute (normalized), which is used for tangent-space effects like bump mapping.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        binormal: Boolean;
        /**
         * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
<p>
32-bit floating-point.  3 components per attribute.
</p>
         */
        tangent: Boolean;
        /**
         * When <code>true</code>, the vertex has an RGB color attribute.
<p>
8-bit unsigned byte.  3 components per attribute.
</p>
         */
        color: Boolean;
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: VertexFormat, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: VertexFormat): VertexFormat;
        /**
         * Duplicates a VertexFormat instance.
         * @param cartesian  (Required) The vertex format to duplicate.
         * @param result  (Optional) The object onto which to store the result.
         */
        static clone(cartesian: VertexFormat, result?: VertexFormat): VertexFormat;
    }
    /**
     * Synchronizes a video element with a simulation clock.
     */
    class VideoSynchronizer {
        /**
         * Synchronizes a video element with a simulation clock.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IVideoSynchronizerOptions);
        /**
         * Gets or sets the simulation time that marks the start of the video.
         */
        epoch: JulianDate;
        /**
         * Gets or sets the amount of time in seconds the video's currentTime
and the clock's currentTime can diverge before a video seek is performed.
Lower values make the synchronization more accurate but video
performance might suffer.  Higher values provide better performance
but at the cost of accuracy.
         */
        tolerance: number;
        /**
         * Gets or sets the clock used to drive the video element.
         */
        clock: Clock;
        /**
         * Gets or sets the video element to synchronize.
         */
        element: HTMLVideoElement;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
    }
    /**
     * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.
     */
    class VRTheWorldTerrainProvider {
        /**
         * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IVRTheWorldTerrainProviderOptions);
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
the source of the terrain.  This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
         */
        tilingScheme: GeographicTilingScheme;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
indicates which areas of the globe are water rather than land, so they can be rendered
as a reflective surface with animated waves.  This function should not be
called before {@link VRTheWorldTerrainProvider#ready} returns true.
         */
        hasWaterMask: Boolean;
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
         */
        hasVertexNormals: Boolean;
        /**
         * Requests the geometry for a given tile.  This function should not be called before
{@link VRTheWorldTerrainProvider#ready} returns true.  The result includes terrain
data and indicates that all child tiles are available.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         * @param throttleRequests  (Optional) True if the number of simultaneous requests should be limited,
                 or false if the request should be initiated regardless of the number of requests
                 already in progress.
         */
        requestTileGeometry(x: number, y: number, level: number, throttleRequests?: Boolean): Promise<TerrainData>;
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.
         * @param level  (Required) The tile level for which to get the maximum geometric error.
         */
        getLevelMaximumGeometricError(level: number): number;
        /**
         * Determines whether data for a tile is available to be loaded.
         * @param x  (Required) The X coordinate of the tile for which to request geometry.
         * @param y  (Required) The Y coordinate of the tile for which to request geometry.
         * @param level  (Required) The level of the tile for which to request geometry.
         */
        getTileDataAvailable(x: number, y: number, level: number): Boolean;
    }
    /**
     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     */
    class WallGeometry {
        /**
         * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IWallGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: WallGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: WallGeometry): WallGeometry;
        /**
         * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
         * @param options  (Required) Object with the following properties:
         */
        static fromConstantHeights(options: WallGeometry.IWallGeometryFromConstantHeightsOptions): WallGeometry;
        /**
         * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.
         * @param wallGeometry  (Required) A description of the wall.
         */
        static createGeometry(wallGeometry: WallGeometry): Geometry;
    }
    /**
     * A description of a wall outline. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     */
    class WallOutlineGeometry {
        /**
         * A description of a wall outline. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IWallOutlineGeometryOptions);
        /**
         * The number of elements used to pack the object into an array.
         */
        packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        static pack(value: WallOutlineGeometry, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        static unpack(array: number[], startingIndex?: number, result?: WallOutlineGeometry): WallOutlineGeometry;
        /**
         * A description of a walloutline. A wall is defined by a series of points,
which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
         * @param options  (Required) Object with the following properties:
         */
        static fromConstantHeights(options: WallOutlineGeometry.IWallOutlineGeometryFromConstantHeightsOptions): WallOutlineGeometry;
        /**
         * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.
         * @param wallGeometry  (Required) A description of the wall outline.
         */
        static createGeometry(wallGeometry: WallOutlineGeometry): Geometry;
    }
    /**
     * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
the spherical (rather than ellipsoidal) equations.
     */
    class WebMercatorProjection {
        /**
         * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
the spherical (rather than ellipsoidal) equations.
         * @param ellipsoid  (Optional) The ellipsoid.
         */
        constructor(ellipsoid?: Ellipsoid);
        /**
         * Gets the {@link Ellipsoid}.
         */
        ellipsoid: Ellipsoid;
        /**
         * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude
in the range -PI/2 to PI/2.
         * @param mercatorAngle  (Required) The angle to convert.
         */
        static mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;
        /**
         * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator
angle in the range -PI to PI.
         * @param latitude  (Required) The geodetic latitude in radians.
         */
        static geodeticLatitudeToMercatorAngle(latitude: number): number;
        /**
         * The maximum latitude (both North and South) supported by a Web Mercator
(EPSG:3857) projection.  Technically, the Mercator projection is defined
for any latitude up to (but not including) 90 degrees, but it makes sense
to cut it off sooner because it grows exponentially with increasing latitude.
The logic behind this particular cutoff value, which is the one used by
Google Maps, Bing Maps, and Esri, is that it makes the projection
square.  That is, the rectangle is equal in the X and Y directions.

The constant value is computed by calling:
   WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)
         */
        MaximumLatitude: number;
        /**
         * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator
X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height
is copied unmodified to the Z coordinate.
         * @param cartographic  (Required) The cartographic coordinates in radians.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a
       new instance should be created.
         */
        project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
        /**
         * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}
containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the
height.
         * @param cartesian  (Required) The web mercator Cartesian position to unrproject with height (z) in meters.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a
       new instance should be created.
         */
        unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
    }
    /**
     * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
     */
    class WebMercatorTilingScheme {
        /**
         * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IWebMercatorTilingSchemeOptions);
        /**
         * Gets the ellipsoid that is tiled by this tiling scheme.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the rectangle, in radians, covered by this tiling scheme.
         */
        rectangle: Rectangle;
        /**
         * Gets the map projection used by this tiling scheme.
         */
        projection: MapProjection;
        /**
         * Gets the total number of tiles in the X direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfXTilesAtLevel(level: number): number;
        /**
         * Gets the total number of tiles in the Y direction at a specified level-of-detail.
         * @param level  (Required) The level-of-detail.
         */
        getNumberOfYTilesAtLevel(level: number): number;
        /**
         * Transforms an rectangle specified in geodetic radians to the native coordinate system
of this tiling scheme.
         * @param rectangle  (Required) The rectangle to transform.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
        /**
         * Converts tile x, y coordinates and level to an rectangle expressed in the native coordinates
of the tiling scheme.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
         * @param x  (Required) The integer x coordinate of the tile.
         * @param y  (Required) The integer y coordinate of the tile.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
        /**
         * Calculates the tile x, y coordinates of the tile containing
a given cartographic position.
         * @param position  (Required) The position.
         * @param level  (Required) The tile level-of-detail.  Zero is the least detailed.
         * @param result  (Optional) The instance to which to copy the result, or undefined if a new instance
       should be created.
         */
        positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
    }
    /**
     * Describes a two dimensional icon located at the position of the containing {@link Entity}.
<p>
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
</p>
     */
    class BillboardGraphics {
        /**
         * Describes a two dimensional icon located at the position of the containing {@link Entity}.
<p>
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IBillboardGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
         */
        image: Property;
        /**
         * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
measured in pixels from the bottom-left.
         */
        imageSubRegion: Property;
        /**
         * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
<p>
<div align='center'>
<img src='images/Billboard.setScale.png' width='400' height='300' /><br/>
From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
</div>
</p>
         */
        scale: Property;
        /**
         * Gets or sets the numeric Property specifying the rotation of the image
counter clockwise from the <code>alignedAxis</code>.
         */
        rotation: Property;
        /**
         * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
         */
        alignedAxis: Property;
        /**
         * Gets or sets the Property specifying the {@link HorizontalOrigin}.
         */
        horizontalOrigin: Property;
        /**
         * Gets or sets the Property specifying the {@link VerticalOrigin}.
         */
        verticalOrigin: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
This has two common use cases.  First, the same white texture may be used by many different billboards,
each with a different color, to create colored billboards. Second, the color's alpha component can be
used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
transparent, and <code>1.0</code> makes the billboard opaque.
<p>
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
<td align='center'><code>alpha : 0.5</code><br/><img src='images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
</tr></table>
</div>
</p>
         */
        color: Property;
        /**
         * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
right, <code>y</code> points up, and <code>z</code> points into the screen.
<p>
An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
arrange a billboard above its corresponding 3D model.
</p>
Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
appear on top of the Earth regardless of the viewer's or Earth's orientation.
<p>
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
<td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
</tr></table>
<code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
</div>
</p>
         */
        eyeOffset: Property;
        /**
         * Gets or sets the Property specifying the {@link HeightReference}.
         */
        heightReference: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
<p>
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
<td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
</tr></table>
The billboard's origin is indicated by the yellow point.
</div>
</p>
         */
        pixelOffset: Property;
        /**
         * Gets or sets the boolean Property specifying the visibility of the billboard.
         */
        show: Property;
        /**
         * Gets or sets the numeric Property specifying the billboard's width in pixels.
When undefined, the native width is used.
         */
        width: Property;
        /**
         * Gets or sets the numeric Property specifying the height of the billboard in pixels.
When undefined, the native height is used.
         */
        height: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's scale remains clamped to the nearest bound.
         */
        scaleByDistance: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
         */
        translucencyByDistance: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
         */
        pixelOffsetScaleByDistance: Property;
        /**
         * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
         */
        sizeInMeters: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: BillboardGraphics): BillboardGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: BillboardGraphics): void;
    }
    /**
     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
     */
    class BillboardVisualizer {
        /**
         * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
         * @param entityCluster  (Required) The entity cluster to manage the collection of billboards and optionally cluster with other entities.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
        /**
         * Updates the primitives created by this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * A {@link GeometryUpdater} for boxes.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class BoxGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for boxes.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
     */
    class BoxGraphics {
        /**
         * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IBoxGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the box.
         */
        show: Property;
        /**
         * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
         */
        dimensions: Property;
        /**
         * Gets or sets the material used to fill the box.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the box is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Get or sets the enum Property specifying whether the box
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: BoxGraphics): BoxGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: BoxGraphics): void;
    }
    /**
     * A {@link Property} whose value is lazily evaluated by a callback function.
     */
    class CallbackProperty {
        /**
         * A {@link Property} whose value is lazily evaluated by a callback function.
         * @param callback  (Required) The function to be called when the property is evaluated.
         * @param isConstant  (Required) <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
         */
        constructor(callback: CallbackProperty.Callback, isConstant: Boolean);
        /**
         * Gets a value indicating if this property is constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setCallback is called.
         */
        definitionChanged: Event;
        /**
         * Gets the value of the property.
         * @param time  (Optional) The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time?: JulianDate, result?: any): any;
        /**
         * Sets the callback to be used.
         * @param callback  (Required) The function to be called when the property is evaluated.
         * @param isConstant  (Required) <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
         */
        setCallback(callback: CallbackProperty.Callback, isConstant: Boolean): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link MaterialProperty} that maps to checkerboard {@link Material} uniforms.
     */
    class CheckerboardMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to checkerboard {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ICheckerboardMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the first {@link Color}.
         */
        evenColor: Property;
        /**
         * Gets or sets the Property specifying the second {@link Color}.
         */
        oddColor: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
         */
        repeat: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
     */
    class ColorMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
         * @param color  (Optional) The {@link Color} Property to be used.
         */
        constructor(color?: Property);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the {@link Color} {@link Property}.
         */
        color: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
If a Entity with the same ID exists in multiple collections, it is non-destructively
merged into a single new entity instance.  If an entity has the same property in multiple
collections, the property of the Entity in the last collection of the list it
belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
EntityCollection is used.
     */
    class CompositeEntityCollection {
        /**
         * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
If a Entity with the same ID exists in multiple collections, it is non-destructively
merged into a single new entity instance.  If an entity has the same property in multiple
collections, the property of the Entity in the last collection of the list it
belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
EntityCollection is used.
         * @param collections  (Optional) The initial list of EntityCollection instances to merge.
         * @param owner  (Optional) The data source (or composite entity collection) which created this collection.
         */
        constructor(collections?: EntityCollection[], owner?: DataSource|CompositeEntityCollection);
        /**
         * Gets the event that is fired when entities are added or removed from the collection.
The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
         */
        collectionChanged: Event;
        /**
         * Gets a globally unique identifier for this collection.
         */
        id: string;
        /**
         * Gets the array of Entity instances in the collection.
This array should not be modified directly.
         */
        values: Entity[];
        /**
         * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.
         */
        owner: DataSource|CompositeEntityCollection;
        /**
         * Adds a collection to the composite.
         * @param collection  (Required) the collection to add.
         * @param index  (Optional) the index to add the collection at.  If omitted, the collection will
                        added on top of all existing collections.
         */
        addCollection(collection: EntityCollection, index?: number): void;
        /**
         * Removes a collection from this composite, if present.
         * @param collection  (Required) The collection to remove.
         */
        removeCollection(collection: EntityCollection): Boolean;
        /**
         * Removes all collections from this composite.
         */
        removeAllCollections(): void;
        /**
         * Checks to see if the composite contains a given collection.
         * @param collection  (Required) the collection to check for.
         */
        containsCollection(collection: EntityCollection): Boolean;
        /**
         * Returns true if the provided entity is in this collection, false otherwise.
         * @param entity  (Required) The entity.
         */
        contains(entity: Entity): Boolean;
        /**
         * Determines the index of a given collection in the composite.
         * @param collection  (Required) The collection to find the index of.
         */
        indexOfCollection(collection: EntityCollection): number;
        /**
         * Gets a collection by index from the composite.
         * @param index  (Required) the index to retrieve.
         */
        getCollection(index: number): void;
        /**
         * Gets the number of collections in this composite.
         */
        getCollectionsLength(): void;
        /**
         * Raises a collection up one position in the composite.
         * @param collection  (Required) the collection to move.
         */
        raiseCollection(collection: EntityCollection): void;
        /**
         * Lowers a collection down one position in the composite.
         * @param collection  (Required) the collection to move.
         */
        lowerCollection(collection: EntityCollection): void;
        /**
         * Raises a collection to the top of the composite.
         * @param collection  (Required) the collection to move.
         */
        raiseCollectionToTop(collection: EntityCollection): void;
        /**
         * Lowers a collection to the bottom of the composite.
         * @param collection  (Required) the collection to move.
         */
        lowerCollectionToBottom(collection: EntityCollection): void;
        /**
         * Prevents {@link EntityCollection#collectionChanged} events from being raised
until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
point a single event will be raised that covers all suspended operations.
This allows for many items to be added and removed efficiently.
While events are suspended, recompositing of the collections will
also be suspended, as this can be a costly operation.
This function can be safely called multiple times as long as there
are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        suspendEvents(): void;
        /**
         * Resumes raising {@link EntityCollection#collectionChanged} events immediately
when an item is added or removed.  Any modifications made while while events were suspended
will be triggered as a single event when this function is called.  This function also ensures
the collection is recomposited if events are also resumed.
This function is reference counted and can safely be called multiple times as long as there
are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        resumeEvents(): void;
        /**
         * Computes the maximum availability of the entities in the collection.
If the collection contains a mix of infinitely available data and non-infinite data,
It will return the interval pertaining to the non-infinite data only.  If all
data is infinite, an infinite interval will be returned.
         */
        computeAvailability(): TimeInterval;
        /**
         * Gets an entity with the specified id.
         * @param id  (Required) The id of the entity to retrieve.
         */
        getById(id: any): Entity;
    }
    /**
     * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
     */
    class CompositeMaterialProperty {
        /**
         * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value.
         */
        definitionChanged: Event;
        /**
         * Gets the interval collection.
         */
        intervals: TimeIntervalCollection;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link CompositeProperty} which is also a {@link PositionProperty}.
     */
    class CompositePositionProperty {
        /**
         * A {@link CompositeProperty} which is also a {@link PositionProperty}.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         */
        constructor(referenceFrame?: number);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value.
         */
        definitionChanged: Event;
        /**
         * Gets the interval collection.
         */
        intervals: TimeIntervalCollection;
        /**
         * Gets or sets the reference frame which this position presents itself as.
Each PositionProperty making up this object has it's own reference frame,
so this property merely exposes a "preferred" reference frame for clients
to use.
         */
        referenceFrame: number;
        /**
         * Gets the value of the property at the provided time in the fixed frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
data property of each {@link TimeInterval} is another Property instance which is
evaluated at the provided time.
     */
    class CompositeProperty {
        /**
         * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
data property of each {@link TimeInterval} is another Property instance which is
evaluated at the provided time.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value.
         */
        definitionChanged: Event;
        /**
         * Gets the interval collection.
         */
        intervals: TimeIntervalCollection;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link PositionProperty} whose value does not change in respect to the
{@link ReferenceFrame} in which is it defined.
     */
    class ConstantPositionProperty {
        /**
         * A {@link PositionProperty} whose value does not change in respect to the
{@link ReferenceFrame} in which is it defined.
         * @param value  (Optional) The property value.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         */
        constructor(value?: Cartesian3, referenceFrame?: number);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the reference frame in which the position is defined.
         */
        referenceFrame: number;
        /**
         * Gets the value of the property at the provided time in the fixed frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Sets the value of the property.
         * @param value  (Required) The property value.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         */
        setValue(value: Cartesian3, referenceFrame?: number): void;
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} whose value does not change with respect to simulation time.
     */
    class ConstantProperty {
        /**
         * A {@link Property} whose value does not change with respect to simulation time.
         * @param value  (Optional) The property value.
         */
        constructor(value?: any);
        /**
         * Gets a value indicating if this property is constant.
This property always returns <code>true</code>.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value.
         */
        definitionChanged: Event;
        /**
         * Gets the value of the property.
         * @param time  (Optional) The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time?: JulianDate, result?: any): any;
        /**
         * Sets the value of the property.
         * @param value  (Required) The property value.
         */
        setValue(value: any): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link GeometryUpdater} for corridors.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class CorridorGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for corridors.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets a value indicating if the geometry should be drawn on terrain.
         */
        onTerrain: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a corridor, which is a shape defined by a centerline and width that
conforms to the curvature of the globe. It can be placed on the surface or at altitude
and can optionally be extruded into a volume.
     */
    class CorridorGraphics {
        /**
         * Describes a corridor, which is a shape defined by a centerline and width that
conforms to the curvature of the globe. It can be placed on the surface or at altitude
and can optionally be extruded into a volume.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ICorridorGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the corridor.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the corridor.
         */
        material: MaterialProperty;
        /**
         * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
         */
        positions: Property;
        /**
         * Gets or sets the numeric Property specifying the altitude of the corridor.
         */
        height: Property;
        /**
         * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
Setting this property creates a corridor shaped volume starting at height and ending
at this altitude.
         */
        extrudedHeight: Property;
        /**
         * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
         */
        granularity: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the corridor.
         */
        width: Property;
        /**
         * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the corridor is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the {@link CornerType} Property specifying how corners are styled.
         */
        cornerType: Property;
        /**
         * Get or sets the enum Property specifying whether the corridor
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this corridor will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: CorridorGraphics): CorridorGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: CorridorGraphics): void;
    }
    /**
     * A {@link DataSource} implementation which can be used to manually manage a group of entities.
     */
    class CustomDataSource extends DataSource {
        /**
         * A {@link DataSource} implementation which can be used to manually manage a group of entities.
         * @param name  (Optional) A human-readable name for this instance.
         */
        constructor(name?: string);
        /**
         * Gets or sets a human-readable name for this instance.
         */
        name: string;
        /**
         * Gets or sets the clock for this instance.
         */
        clock: DataSourceClock;
        /**
         * Gets the collection of {@link Entity} instances.
         */
        entities: EntityCollection;
        /**
         * Gets or sets whether the data source is currently loading data.
         */
        isLoading: Boolean;
        /**
         * Gets an event that will be raised when the underlying data changes.
         */
        changedEvent: Event;
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         */
        errorEvent: Event;
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         */
        loadingEvent: Event;
        /**
         * Gets whether or not this data source should be displayed.
         */
        show: Boolean;
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         */
        clustering: EntityCluster;
    }
    /**
     * A {@link GeometryUpdater} for cylinders.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class CylinderGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for cylinders.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
The center position and orientation are determined by the containing {@link Entity}.
     */
    class CylinderGraphics {
        /**
         * Describes a cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
The center position and orientation are determined by the containing {@link Entity}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ICylinderGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the numeric Property specifying the length of the cylinder.
         */
        length: Property;
        /**
         * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
         */
        topRadius: Property;
        /**
         * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
         */
        bottomRadius: Property;
        /**
         * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
         */
        numberOfVerticalLines: Property;
        /**
         * Gets or sets the Property specifying the number of edges around the perimeter of the cylinder.
         */
        slices: Property;
        /**
         * Gets or sets the boolean Property specifying the visibility of the cylinder.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the cylinder.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the boolean Property specifying whether the cylinder is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Get or sets the enum Property specifying whether the cylinder
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this cylinder will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: CylinderGraphics): CylinderGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: CylinderGraphics): void;
    }
    /**
     * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide|CZML}.
     */
    class CzmlDataSource extends DataSource {
        /**
         * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide|CZML}.
         * @param name  (Optional) An optional name for the data source.  This value will be overwritten if a loaded document contains a name.
         */
        constructor(name?: string);
        /**
         * Creates a Promise to a new instance loaded with the provided CZML data.
         * @param data  (Required) A url or CZML object to be processed.
         * @param options  (Optional) An object with the following properties:
         */
        static load(data: string|any, options?: CzmlDataSource.ICzmlDataSourceLoadOptions): Promise<CzmlDataSource>;
        /**
         * Gets a human-readable name for this instance.
         */
        name: string;
        /**
         * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
defined in the CZML, the combined availability of all objects is returned.  If
only static data exists, this value is undefined.
         */
        clock: DataSourceClock;
        /**
         * Gets the collection of {@link Entity} instances.
         */
        entities: EntityCollection;
        /**
         * Gets a value indicating if the data source is currently loading data.
         */
        isLoading: Boolean;
        /**
         * Gets an event that will be raised when the underlying data changes.
         */
        changedEvent: Event;
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         */
        errorEvent: Event;
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         */
        loadingEvent: Event;
        /**
         * Gets whether or not this data source should be displayed.
         */
        show: Boolean;
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         */
        clustering: EntityCluster;
        /**
         * Gets the array of CZML processing functions.
         */
        updaters: any[];
        /**
         * Processes the provided url or CZML object without clearing any existing data.
         * @param czml  (Required) A url or CZML object to be processed.
         * @param options  (Optional) An object with the following properties:
         */
        process(czml: string|any, options?: CzmlDataSource.ICzmlDataSourceProcessOptions): Promise<CzmlDataSource>;
        /**
         * Loads the provided url or CZML object, replacing any existing data.
         * @param czml  (Required) A url or CZML object to be processed.
         * @param options  (Optional) An object with the following properties:
         */
        load(czml: string|any, options?: CzmlDataSource.ICzmlDataSourceLoadOptions): Promise<CzmlDataSource>;
        /**
         * A helper function used by custom CZML updater functions
which creates or updates a {@link Property} from a CZML packet.
         * @param type  (Required) The constructor function for the property being processed.
         * @param object  (Required) The object on which the property will be added or updated.
         * @param propertyName  (Required) The name of the property on the object.
         * @param packetData  (Required) The CZML packet being processed.
         * @param interval  (Required) A constraining interval for which the data is valid.
         * @param sourceUri  (Required) The originating uri of the data being processed.
         * @param entityCollection  (Required) The collection being processsed.
         */
        static processPacketData(type: Function, object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
        /**
         * A helper function used by custom CZML updater functions
which creates or updates a {@link PositionProperty} from a CZML packet.
         * @param object  (Required) The object on which the property will be added or updated.
         * @param propertyName  (Required) The name of the property on the object.
         * @param packetData  (Required) The CZML packet being processed.
         * @param interval  (Required) A constraining interval for which the data is valid.
         * @param sourceUri  (Required) The originating uri of the data being processed.
         * @param entityCollection  (Required) The collection being processsed.
         */
        static processPositionPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
        /**
         * A helper function used by custom CZML updater functions
which creates or updates a {@link MaterialProperty} from a CZML packet.
         * @param object  (Required) The object on which the property will be added or updated.
         * @param propertyName  (Required) The name of the property on the object.
         * @param packetData  (Required) The CZML packet being processed.
         * @param interval  (Required) A constraining interval for which the data is valid.
         * @param sourceUri  (Required) The originating uri of the data being processed.
         * @param entityCollection  (Required) The collection being processsed.
         */
        static processMaterialPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
    }
    /**
     * Defines the interface for data sources, which turn arbitrary data into a
{@link EntityCollection} for generic consumption. This object is an interface
for documentation purposes and is not intended to be instantiated directly.
     */
    class DataSource {
        /**
         * Defines the interface for data sources, which turn arbitrary data into a
{@link EntityCollection} for generic consumption. This object is an interface
for documentation purposes and is not intended to be instantiated directly.
         */
        constructor();
        /**
         * Gets a human-readable name for this instance.
         */
        name: string;
        /**
         * Gets the preferred clock settings for this data source.
         */
        clock: DataSourceClock;
        /**
         * Gets the collection of {@link Entity} instances.
         */
        entities: EntityCollection;
        /**
         * Gets a value indicating if the data source is currently loading data.
         */
        isLoading: Boolean;
        /**
         * Gets an event that will be raised when the underlying data changes.
         */
        changedEvent: Event;
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         */
        errorEvent: Event;
        /**
         * Gets an event that will be raised when the value of isLoading changes.
         */
        loadingEvent: Event;
        /**
         * Gets whether or not this data source should be displayed.
         */
        show: Boolean;
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         */
        clustering: EntityCluster;
        /**
         * Updates the data source to the provided time.  This function is optional and
is not required to be implemented.  It is provided for data sources which
retrieve data based on the current animation time or scene state.
If implemented, update will be called by {@link DataSourceDisplay} once a frame.
         * @param time  (Required) The simulation time.
         */
        update(time: JulianDate): Boolean;
    }
    /**
     * Represents desired clock settings for a particular {@link DataSource}.  These settings may be applied
to the {@link Clock} when the DataSource is loaded.
     */
    class DataSourceClock {
        /**
         * Represents desired clock settings for a particular {@link DataSource}.  These settings may be applied
to the {@link Clock} when the DataSource is loaded.
         */
        constructor();
        /**
         * Gets the event that is raised whenever a new property is assigned.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the desired start time of the clock.
See {@link Clock#startTime}.
         */
        startTime: JulianDate;
        /**
         * Gets or sets the desired stop time of the clock.
See {@link Clock#stopTime}.
         */
        stopTime: JulianDate;
        /**
         * Gets or sets the desired current time when this data source is loaded.
See {@link Clock#currentTime}.
         */
        currentTime: JulianDate;
        /**
         * Gets or sets the desired clock range setting.
See {@link Clock#clockRange}.
         */
        clockRange: number;
        /**
         * Gets or sets the desired clock step setting.
See {@link Clock#clockStep}.
         */
        clockStep: number;
        /**
         * Gets or sets the desired clock multiplier.
See {@link Clock#multiplier}.
         */
        multiplier: number;
        /**
         * Duplicates a DataSourceClock instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: DataSourceClock): DataSourceClock;
        /**
         * Returns true if this DataSourceClock is equivalent to the other
         * @param other  (Required) The other DataSourceClock to compare to.
         */
        equals(other: DataSourceClock): Boolean;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: DataSourceClock): void;
        /**
         * Gets the value of this clock instance as a {@link Clock} object.
         */
        getValue(): Clock;
    }
    /**
     * A collection of {@link DataSource} instances.
     */
    class DataSourceCollection {
        /**
         * A collection of {@link DataSource} instances.
         */
        constructor();
        /**
         * Gets the number of data sources in this collection.
         */
        length: number;
        /**
         * An event that is raised when a data source is added to the collection.
Event handlers are passed the data source that was added.
         */
        dataSourceAdded: Event;
        /**
         * An event that is raised when a data source is removed from the collection.
Event handlers are passed the data source that was removed.
         */
        dataSourceRemoved: Event;
        /**
         * Adds a data source to the collection.
         * @param dataSource  (Required) A data source or a promise to a data source to add to the collection.
                                       When passing a promise, the data source will not actually be added
                                       to the collection until the promise resolves successfully.
         */
        add(dataSource: DataSource|Promise<DataSource>): Promise<DataSource>;
        /**
         * Removes a data source from this collection, if present.
         * @param dataSource  (Required) The data source to remove.
         * @param destroy  (Optional) Whether to destroy the data source in addition to removing it.
         */
        remove(dataSource: DataSource, destroy?: Boolean): Boolean;
        /**
         * Removes all data sources from this collection.
         * @param destroy  (Optional) whether to destroy the data sources in addition to removing them.
         */
        removeAll(destroy?: Boolean): void;
        /**
         * Checks to see if the collection contains a given data source.
         * @param dataSource  (Required) The data source to check for.
         */
        contains(dataSource: DataSource): Boolean;
        /**
         * Determines the index of a given data source in the collection.
         * @param dataSource  (Required) The data source to find the index of.
         */
        indexOf(dataSource: DataSource): number;
        /**
         * Gets a data source by index from the collection.
         * @param index  (Required) the index to retrieve.
         */
        get(index: number): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the resources held by all data sources in this collection.  Explicitly destroying this
object allows for deterministic release of WebGL resources, instead of relying on the garbage
collector. Once this object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Visualizes a collection of {@link DataSource} instances.
     */
    class DataSourceDisplay {
        /**
         * Visualizes a collection of {@link DataSource} instances.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IDataSourceDisplayOptions);
        /**
         * Gets or sets the default function which creates an array of visualizers used for visualization.
By default, this function uses all standard visualizers.
         */
        defaultVisualizersCallback: DataSourceDisplay.VisualizersCallback;
        /**
         * Gets the scene associated with this display.
         */
        scene: Scene;
        /**
         * Gets the collection of data sources to display.
         */
        dataSources: DataSourceCollection;
        /**
         * Gets the default data source instance which can be used to
manually create and visualize entities not tied to
a specific data source. This instance is always available
and does not appear in the list dataSources collection.
         */
        defaultDataSource: CustomDataSource;
        /**
         * Gets a value indicating whether or not all entities in the data source are ready
         */
        ready: Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
        /**
         * Updates the display to the provided time.
         * @param time  (Required) The simulation time.
         */
        update(time: JulianDate): Boolean;
    }
    /**
     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater
is responsible for handling visualization of a specific type of geometry
that needs to be recomputed based on simulation time.
This object is never used directly by client code, but is instead created by
{@link GeometryUpdater} implementations which contain dynamic geometry.

This type defines an interface and cannot be instantiated directly.
     */
    class DynamicGeometryUpdater {
        /**
         * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater
is responsible for handling visualization of a specific type of geometry
that needs to be recomputed based on simulation time.
This object is never used directly by client code, but is instead created by
{@link GeometryUpdater} implementations which contain dynamic geometry.

This type defines an interface and cannot be instantiated directly.
         */
        constructor();
        /**
         * Updates the geometry to the specified time.
         * @param time  (Required) The current time.
         */
        update(time: JulianDate): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
    }
    /**
     * A {@link GeometryUpdater} for ellipses.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class EllipseGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for ellipses.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets a value indicating if the geometry should be drawn on terrain.
         */
        onTerrain: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes an ellipse defined by a center point and semi-major and semi-minor axes.
The ellipse conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
The center point is determined by the containing {@link Entity}.
     */
    class EllipseGraphics {
        /**
         * Describes an ellipse defined by a center point and semi-major and semi-minor axes.
The ellipse conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
The center point is determined by the containing {@link Entity}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipseGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the numeric Property specifying the semi-major axis.
         */
        semiMajorAxis: Property;
        /**
         * Gets or sets the numeric Property specifying the semi-minor axis.
         */
        semiMinorAxis: Property;
        /**
         * Gets or sets the numeric property specifying the rotation of the ellipse clockwise from north.
         */
        rotation: Property;
        /**
         * Gets or sets the boolean Property specifying the visibility of the ellipse.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the ellipse.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the numeric Property specifying the altitude of the ellipse.
         */
        height: Property;
        /**
         * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
Setting this property creates volume starting at height and ending at this altitude.
         */
        extrudedHeight: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
         */
        granularity: Property;
        /**
         * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
         */
        stRotation: Property;
        /**
         * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the ellipse is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
         */
        numberOfVerticalLines: Property;
        /**
         * Get or sets the enum Property specifying whether the ellipse
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipse will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: EllipseGraphics): EllipseGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: EllipseGraphics): void;
    }
    /**
     * A {@link GeometryUpdater} for ellipsoids.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class EllipsoidGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for ellipsoids.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describe an ellipsoid or sphere.  The center position and orientation are determined by the containing {@link Entity}.
     */
    class EllipsoidGraphics {
        /**
         * Describe an ellipsoid or sphere.  The center position and orientation are determined by the containing {@link Entity}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipsoidGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
         */
        show: Property;
        /**
         * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
         */
        radii: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the ellipsoid.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the ellipsoid is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the Property specifying the number of stacks.
         */
        stackPartitions: Property;
        /**
         * Gets or sets the Property specifying the number of radial slices.
         */
        slicePartitions: Property;
        /**
         * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
         */
        subdivisions: Property;
        /**
         * Get or sets the enum Property specifying whether the ellipsoid
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipsoid will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: EllipsoidGraphics): EllipsoidGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: EllipsoidGraphics): void;
    }
    /**
     * Entity instances aggregate multiple forms of visualization into a single high-level object.
They can be created manually and added to {@link Viewer#entities} or be produced by
data sources, such as {@link CzmlDataSource} and {@link GeoJsonDataSource}.
     */
    class Entity {
        /**
         * Entity instances aggregate multiple forms of visualization into a single high-level object.
They can be created manually and added to {@link Viewer#entities} or be produced by
data sources, such as {@link CzmlDataSource} and {@link GeoJsonDataSource}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEntityOptions);
        /**
         * Gets or sets the entity collection that this entity belongs to.
         */
        entityCollection: EntityCollection;
        /**
         * The availability, if any, associated with this object.
If availability is undefined, it is assumed that this object's
other properties will return valid data for any provided time.
If availability exists, the objects other properties will only
provide valid data if queried within the given interval.
         */
        availability: TimeIntervalCollection;
        /**
         * Gets the unique ID associated with this object.
         */
        id: string;
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the name of the object.  The name is intended for end-user
consumption and does not need to be unique.
         */
        name: string;
        /**
         * Gets or sets whether this entity should be displayed. When set to true,
the entity is only displayed if the parent entity's show property is also true.
         */
        show: Boolean;
        /**
         * Gets whether this entity is being displayed, taking into account
the visibility of any ancestor entities.
         */
        isShowing: Boolean;
        /**
         * Gets or sets the parent object.
         */
        parent: Entity;
        /**
         * Gets the names of all properties registered on this instance.
         */
        propertyNames: any[];
        /**
         * Gets or sets the billboard.
         */
        billboard: BillboardGraphics;
        /**
         * Gets or sets the box.
         */
        box: BoxGraphics;
        /**
         * Gets or sets the corridor.
         */
        corridor: CorridorGraphics;
        /**
         * Gets or sets the cylinder.
         */
        cylinder: CylinderGraphics;
        /**
         * Gets or sets the description.
         */
        description: Property;
        /**
         * Gets or sets the ellipse.
         */
        ellipse: EllipseGraphics;
        /**
         * Gets or sets the ellipsoid.
         */
        ellipsoid: EllipsoidGraphics;
        /**
         * Gets or sets the label.
         */
        label: LabelGraphics;
        /**
         * Gets or sets the model.
         */
        model: ModelGraphics;
        /**
         * Gets or sets the orientation.
         */
        orientation: Property;
        /**
         * Gets or sets the path.
         */
        path: PathGraphics;
        /**
         * Gets or sets the point graphic.
         */
        point: PointGraphics;
        /**
         * Gets or sets the polygon.
         */
        polygon: PolygonGraphics;
        /**
         * Gets or sets the polyline.
         */
        polyline: PolylineGraphics;
        /**
         * Gets or sets the polyline volume.
         */
        polylineVolume: PolylineVolumeGraphics;
        /**
         * Gets or sets the position.
         */
        position: PositionProperty;
        /**
         * Gets or sets the rectangle.
         */
        rectangle: RectangleGraphics;
        /**
         * Gets or sets the suggested initial offset for viewing this object
with the camera.  The offset is defined in the east-north-up reference frame.
         */
        viewFrom: Property;
        /**
         * Gets or sets the wall.
         */
        wall: WallGraphics;
        /**
         * Given a time, returns true if this object should have data during that time.
         * @param time  (Required) The time to check availability for.
         */
        isAvailable(time: JulianDate): Boolean;
        /**
         * Adds a property to this object.  Once a property is added, it can be
observed with {@link Entity#definitionChanged} and composited
with {@link CompositeEntityCollection}
         * @param propertyName  (Required) The name of the property to add.
         */
        addProperty(propertyName: string): void;
        /**
         * Removed a property previously added with addProperty.
         * @param propertyName  (Required) The name of the property to remove.
         */
        removeProperty(propertyName: string): void;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: Entity): void;
    }
    /**
     * Defines how screen space objects (billboards, points, labels) are clustered.
     */
    class EntityCluster {
        /**
         * Defines how screen space objects (billboards, points, labels) are clustered.
         * @param options  (Optional) An object with the following properties:
         */
        constructor(options?: IEntityClusterOptions);
        /**
         * Gets or sets whether clustering is enabled.
         */
        enabled: Boolean;
        /**
         * Gets or sets the pixel range to extend the screen space bounding box.
         */
        pixelRange: number;
        /**
         * Gets or sets the minimum number of screen space objects that can be clustered.
         */
        minimumClusterSize: number;
        /**
         * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster~newClusterCallback}.
         */
        clusterEvent: Event;
        /**
         * Gets or sets whether clustering billboard entities is enabled.
         */
        clusterBillboards: Boolean;
        /**
         * Gets or sets whether clustering labels entities is enabled.
         */
        clusterLabels: Boolean;
        /**
         * Gets or sets whether clustering point entities is enabled.
         */
        clusterPoints: Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<p>
Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed
from a data source collection and added to another.
</p>
         */
        destroy(): void;
    }
    /**
     * An observable collection of {@link Entity} instances where each entity has a unique id.
     */
    class EntityCollection {
        /**
         * An observable collection of {@link Entity} instances where each entity has a unique id.
         * @param owner  (Optional) The data source (or composite entity collection) which created this collection.
         */
        constructor(owner?: DataSource|CompositeEntityCollection);
        /**
         * Prevents {@link EntityCollection#collectionChanged} events from being raised
until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
point a single event will be raised that covers all suspended operations.
This allows for many items to be added and removed efficiently.
This function can be safely called multiple times as long as there
are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        suspendEvents(): void;
        /**
         * Resumes raising {@link EntityCollection#collectionChanged} events immediately
when an item is added or removed.  Any modifications made while while events were suspended
will be triggered as a single event when this function is called.
This function is reference counted and can safely be called multiple times as long as there
are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        resumeEvents(): void;
        /**
         * The signature of the event generated by {@link EntityCollection#collectionChanged}.
         * @param collection  (Required) The collection that triggered the event.
         * @param added  (Required) The array of {@link Entity} instances that have been added to the collection.
         * @param removed  (Required) The array of {@link Entity} instances that have been removed from the collection.
         * @param changed  (Required) The array of {@link Entity} instances that have been modified.
         */
        static collectionChangedEventCallback(collection: EntityCollection, added: Entity[], removed: Entity[], changed: Entity[]): void;
        /**
         * Gets the event that is fired when entities are added or removed from the collection.
The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
         */
        collectionChanged: Event;
        /**
         * Gets a globally unique identifier for this collection.
         */
        id: string;
        /**
         * Gets the array of Entity instances in the collection.
This array should not be modified directly.
         */
        values: Entity[];
        /**
         * Gets whether or not this entity collection should be
displayed.  When true, each entity is only displayed if
its own show property is also true.
         */
        show: Boolean;
        /**
         * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
         */
        owner: DataSource|CompositeEntityCollection;
        /**
         * Computes the maximum availability of the entities in the collection.
If the collection contains a mix of infinitely available data and non-infinite data,
it will return the interval pertaining to the non-infinite data only.  If all
data is infinite, an infinite interval will be returned.
         */
        computeAvailability(): TimeInterval;
        /**
         * Add an entity to the collection.
         * @param entity  (Required) The entity to be added.
         */
        add(entity: Entity): Entity;
        /**
         * Removes an entity from the collection.
         * @param entity  (Required) The entity to be removed.
         */
        remove(entity: Entity): Boolean;
        /**
         * Returns true if the provided entity is in this collection, false otherwise.
         * @param entity  (Required) The entity.
         */
        contains(entity: Entity): Boolean;
        /**
         * Removes an entity with the provided id from the collection.
         * @param id  (Required) The id of the entity to remove.
         */
        removeById(id: any): Boolean;
        /**
         * Removes all Entities from the collection.
         */
        removeAll(): void;
        /**
         * Gets an entity with the specified id.
         * @param id  (Required) The id of the entity to retrieve.
         */
        getById(id: any): Entity;
        /**
         * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.
         * @param id  (Required) The id of the entity to retrieve or create.
         */
        getOrCreateEntity(id: any): Entity;
    }
    /**
     * A utility object for tracking an entity with the camera.
     */
    class EntityView {
        /**
         * A utility object for tracking an entity with the camera.
         * @param entity  (Required) The entity to track with the camera.
         * @param scene  (Required) The scene to use.
         * @param ellipsoid  (Optional) The ellipsoid to use for orienting the camera.
         */
        constructor(entity: Entity, scene: Scene, ellipsoid?: Ellipsoid);
        /**
         * The entity to track with the camera.
         */
        entity: Entity;
        /**
         * The scene in which to track the object.
         */
        scene: Scene;
        /**
         * The ellipsoid to use for orienting the camera.
         */
        ellipsoid: Ellipsoid;
        /**
         * The bounding sphere of the object.
         */
        boundingSphere: BoundingSphere;
        /**
         * Gets or sets a camera offset that will be used to
initialize subsequent EntityViews.
         */
        defaultOffset3D: Cartesian3;
        /**
         * Should be called each animation frame to update the camera
to the latest settings.
         * @param time  (Required) The current animation time.
         * @param current  (Required) bounding sphere of the object.
         */
        update(time: JulianDate, current: BoundingSphere): void;
    }
    /**
     * A {@link DataSource} which processes both
{@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.
{@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they
are present.
     */
    class GeoJsonDataSource extends DataSource {
        /**
         * A {@link DataSource} which processes both
{@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.
{@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they
are present.
         * @param name  (Optional) The name of this data source.  If undefined, a name will be taken from
                       the name of the GeoJSON file.
         */
        constructor(name?: string);
        /**
         * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.
         * @param data  (Required) A url, GeoJSON object, or TopoJSON object to be loaded.
         * @param options  (Optional) An object with the following properties:
         */
        static load(data: string|any, options?: GeoJsonDataSource.IGeoJsonDataSourceLoadOptions): Promise<GeoJsonDataSource>;
        /**
         * Gets or sets the default size of the map pin created for each point, in pixels.
         */
        markerSize: number;
        /**
         * Gets or sets the default symbol of the map pin created for each point.
This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,
or blank if no symbol is to be used.
         */
        markerSymbol: string;
        /**
         * Gets or sets the default color of the map pin created for each point.
         */
        markerColor: number;
        /**
         * Gets or sets the default color of polylines and polygon outlines.
         */
        stroke: number;
        /**
         * Gets or sets the default width of polylines and polygon outlines.
         */
        strokeWidth: number;
        /**
         * Gets or sets default color for polygon interiors.
         */
        fill: number;
        /**
         * Gets or sets default of whether to clamp to the ground.
         */
        clampToGround: Boolean;
        /**
         * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate
and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which
supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,
for example 'EPSG:4326'.
         */
        crsNames: any;
        /**
         * Gets an object that maps the href property of a crs link to a callback function
which takes the crs properties object and returns a Promise that resolves
to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming
the link has a type specified.
         */
        crsLinkHrefs: any;
        /**
         * Gets an object that maps the type property of a crs link to a callback function
which takes the crs properties object and returns a Promise that resolves
to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
Items in <code>crsLinkHrefs</code> take precedence over this object.
         */
        crsLinkTypes: any;
        /**
         * Gets a human-readable name for this instance.
         */
        name: string;
        /**
         * This DataSource only defines static data, therefore this property is always undefined.
         */
        clock: DataSourceClock;
        /**
         * Gets the collection of {@link Entity} instances.
         */
        entities: EntityCollection;
        /**
         * Gets a value indicating if the data source is currently loading data.
         */
        isLoading: Boolean;
        /**
         * Gets an event that will be raised when the underlying data changes.
         */
        changedEvent: Event;
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         */
        errorEvent: Event;
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         */
        loadingEvent: Event;
        /**
         * Gets whether or not this data source should be displayed.
         */
        show: Boolean;
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         */
        clustering: EntityCluster;
        /**
         * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.
         * @param data  (Required) A url, GeoJSON object, or TopoJSON object to be loaded.
         * @param options  (Optional) An object with the following properties:
         */
        load(data: string|any, options?: GeoJsonDataSource.IGeoJsonDataSourceLoadOptions): Promise<GeoJsonDataSource>;
    }
    /**
     * Defines the interface for a geometry updater.  A GeometryUpdater maps
geometry defined as part of a {@link Entity} into {@link Geometry}
instances.  These instances are then visualized by {@link GeometryVisualizer}.

This type defines an interface and cannot be instantiated directly.
     */
    class GeometryUpdater {
        /**
         * Defines the interface for a geometry updater.  A GeometryUpdater maps
geometry defined as part of a {@link Entity} into {@link Geometry}
instances.  These instances are then visualized by {@link GeometryVisualizer}.

This type defines an interface and cannot be instantiated directly.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * A general purpose visualizer for geometry represented by {@link Primitive} instances.
     */
    class GeometryVisualizer {
        /**
         * A general purpose visualizer for geometry represented by {@link Primitive} instances.
         * @param type  (Required) The updater to be used for creating the geometry.
         * @param scene  (Required) The scene the primitives will be rendered in.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(type: GeometryUpdater, scene: Scene, entityCollection: EntityCollection);
        /**
         * Updates all of the primitives created by this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
     */
    class GridMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IGridMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the grid {@link Color}.
         */
        color: Property;
        /**
         * Gets or sets the numeric Property specifying cell alpha values.
         */
        cellAlpha: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.
         */
        lineCount: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
         */
        lineThickness: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.
         */
        lineOffset: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link MaterialProperty} that maps to image {@link Material} uniforms.
     */
    class ImageMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to image {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IImageMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
         */
        image: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
         */
        repeat: Property;
        /**
         * Gets or sets the Color Property specifying the desired color applied to the image.
         */
        color: Property;
        /**
         * Gets or sets the Boolean Property specifying whether the image has transparency
         */
        transparent: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
<p>
KML support in Cesium is incomplete, but a large amount of the standard,
as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
{@link https://github.com/AnalyticalGraphicsInc/cesium/issues/873|#873} for a
detailed list of what is and isn't support. Cesium will also write information to the
console when it encounters most unsupported features.
</p>
<p>
Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
under the <code>kml</code> property.
</p>
     */
    class KmlDataSource extends DataSource {
        /**
         * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
<p>
KML support in Cesium is incomplete, but a large amount of the standard,
as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
{@link https://github.com/AnalyticalGraphicsInc/cesium/issues/873|#873} for a
detailed list of what is and isn't support. Cesium will also write information to the
console when it encounters most unsupported features.
</p>
<p>
Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
under the <code>kml</code> property.
</p>
         * @param options  (Required) An object with the following properties
         */
        constructor(options: IKmlDataSourceOptions);
        /**
         * Creates a Promise to a new instance loaded with the provided KML data.
         * @param data  (Required) A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
         * @param options  (Optional) An object with the following properties:
         */
        static load(data: string|Document|Blob, options?: KmlDataSource.IKmlDataSourceLoadOptions): Promise<KmlDataSource>;
        /**
         * Gets a human-readable name for this instance.
This will be automatically be set to the KML document name on load.
         */
        name: string;
        /**
         * Gets the clock settings defined by the loaded KML. This represents the total
availability interval for all time-dynamic data. If the KML does not contain
time-dynamic data, this value is undefined.
         */
        clock: DataSourceClock;
        /**
         * Gets the collection of {@link Entity} instances.
         */
        entities: EntityCollection;
        /**
         * Gets a value indicating if the data source is currently loading data.
         */
        isLoading: Boolean;
        /**
         * Gets an event that will be raised when the underlying data changes.
         */
        changedEvent: Event;
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         */
        errorEvent: Event;
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         */
        loadingEvent: Event;
        /**
         * Gets an event that will be raised when the data source refreshes a network link.
         */
        refreshEvent: Event;
        /**
         * Gets an event that will be raised when the data source finds an unsupported node type.
         */
        unsupportedNodeEvent: Event;
        /**
         * Gets whether or not this data source should be displayed.
         */
        show: Boolean;
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         */
        clustering: EntityCluster;
        /**
         * Asynchronously loads the provided KML data, replacing any existing data.
         * @param data  (Required) A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
         * @param options  (Optional) An object with the following properties:
         */
        load(data: string|Document|Blob, options?: KmlDataSource.IKmlDataSourceLoadOptions): Promise<KmlDataSource>;
        /**
         * Updates any NetworkLink that require updating
         * @param time  (Required) The simulation time.
         */
        update(time: JulianDate): Boolean;
    }
    /**
     * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.
     */
    class KmlFeatureData {
        /**
         * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.
         */
        constructor();
        /**
         * Gets the atom syndication format author field.
         */
        author: IKmlFeatureDataOptions;
        /**
         * Gets the link.
         */
        link: IKmlFeatureDataOptions;
        /**
         * Gets the unstructured address field.
         */
        address: string;
        /**
         * Gets the phone number.
         */
        phoneNumber: string;
        /**
         * Gets the snippet.
         */
        snippet: string;
        /**
         * Gets the extended data, parsed into a JSON object.
Currently only the <code>Data</code> property is supported.
<code>SchemaData</code> and custom data are ignored.
         */
        extendedData: string;
    }
    /**
     * Describes a two dimensional label located at the position of the containing {@link Entity}.
<p>
<div align='center'>
<img src='images/Label.png' width='400' height='300' /><br />
Example labels
</div>
</p>
     */
    class LabelGraphics {
        /**
         * Describes a two dimensional label located at the position of the containing {@link Entity}.
<p>
<div align='center'>
<img src='images/Label.png' width='400' height='300' /><br />
Example labels
</div>
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ILabelGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the string Property specifying the text of the label.
         */
        text: Property;
        /**
         * Gets or sets the string Property specifying the font in CSS syntax.
         */
        font: Property;
        /**
         * Gets or sets the Property specifying the {@link LabelStyle}.
         */
        style: Property;
        /**
         * Gets or sets the Property specifying the fill {@link Color}.
         */
        fillColor: Property;
        /**
         * Gets or sets the Property specifying the outline {@link Color}.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the outline width.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the Property specifying the {@link HorizontalOrigin}.
         */
        horizontalOrigin: Property;
        /**
         * Gets or sets the Property specifying the {@link VerticalOrigin}.
         */
        verticalOrigin: Property;
        /**
         * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
right, <code>y</code> points up, and <code>z</code> points into the screen.
<p>
An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
arrange a label above its corresponding 3D model.
</p>
Below, the label is positioned at the center of the Earth but an eye offset makes it always
appear on top of the Earth regardless of the viewer's or Earth's orientation.
<p>
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
<td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
</tr></table>
<code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
</div>
</p>
         */
        eyeOffset: Property;
        /**
         * Gets or sets the Property specifying the {@link HeightReference}.
         */
        heightReference: Property;
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
from the origin of this label.  This is commonly used to align multiple labels and labels at
the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
<p>
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
<td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
</tr></table>
The label's origin is indicated by the yellow point.
</div>
</p>
         */
        pixelOffset: Property;
        /**
         * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
<p>
<div align='center'>
<img src='images/Label.setScale.png' width='400' height='300' /><br/>
From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
and <code>2.0</code>.
</div>
</p>
         */
        scale: Property;
        /**
         * Gets or sets the boolean Property specifying the visibility of the label.
         */
        show: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the label's translucency remains clamped to the nearest bound.
         */
        translucencyByDistance: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
         */
        pixelOffsetScaleByDistance: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: LabelGraphics): LabelGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: LabelGraphics): void;
    }
    /**
     * A {@link Visualizer} which maps the {@link LabelGraphics} instance
in {@link Entity#label} to a {@link Label}.
     */
    class LabelVisualizer {
        /**
         * A {@link Visualizer} which maps the {@link LabelGraphics} instance
in {@link Entity#label} to a {@link Label}.
         * @param entityCluster  (Required) The entity cluster to manage the collection of billboards and optionally cluster with other entities.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
        /**
         * Updates the primitives created by this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * The interface for all {@link Property} objects that represent {@link Material} uniforms.
This type defines an interface and cannot be instantiated directly.
     */
    class MaterialProperty {
        /**
         * The interface for all {@link Property} objects that represent {@link Material} uniforms.
This type defines an interface and cannot be instantiated directly.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A 3D model based on {@link https://github.com/KhronosGroup/glTF|glTF}, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
The position and orientation of the model is determined by the containing {@link Entity}.
<p>
Cesium includes support for glTF geometry, materials, animations, and skinning.
Cameras and lights are not currently supported.
</p>
     */
    class ModelGraphics {
        /**
         * A 3D model based on {@link https://github.com/KhronosGroup/glTF|glTF}, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
The position and orientation of the model is determined by the containing {@link Entity}.
<p>
Cesium includes support for glTF geometry, materials, animations, and skinning.
Cameras and lights are not currently supported.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IModelGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the model.
         */
        show: Property;
        /**
         * Gets or sets the numeric Property specifying a uniform linear scale
for this model. Values greater than 1.0 increase the size of the model while
values less than 1.0 decrease it.
         */
        scale: Property;
        /**
         * Gets or sets the numeric Property specifying the approximate minimum
pixel size of the model regardless of zoom. This can be used to ensure that
a model is visible even when the viewer zooms out.  When <code>0.0</code>,
no minimum size is enforced.
         */
        minimumPixelSize: Property;
        /**
         * Gets or sets the numeric Property specifying the maximum scale
size of a model. This property is used as an upper limit for
{@link ModelGraphics#minimumPixelSize}.
         */
        maximumScale: Property;
        /**
         * Get or sets the boolean Property specifying whether textures
may continue to stream in after the model is loaded.
         */
        incrementallyLoadTextures: Property;
        /**
         * Get or sets the enum Property specifying whether the model
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the string Property specifying the URI of the glTF asset.
         */
        uri: Property;
        /**
         * Gets or sets the boolean Property specifying if glTF animations should be run.
         */
        runAnimations: Property;
        /**
         * Gets or sets the set of node transformations to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
         */
        nodeTransformations: PropertyBag;
        /**
         * Gets or sets the Property specifying the {@link HeightReference}.
         */
        heightReference: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this model will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: ModelGraphics): ModelGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: ModelGraphics): void;
    }
    /**
     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.
     */
    class ModelVisualizer {
        /**
         * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.
         * @param scene  (Required) The scene the primitives will be rendered in.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(scene: Scene, entityCollection: EntityCollection);
        /**
         * Updates models created this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * A {@link Property} that produces {@link TranslationRotationScale} data.
     */
    class NodeTransformationProperty {
        /**
         * A {@link Property} that produces {@link TranslationRotationScale} data.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: INodeTransformationPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
         */
        translation: Property;
        /**
         * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
         */
        rotation: Property;
        /**
         * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
         */
        scale: Property;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: TranslationRotationScale): TranslationRotationScale;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * Describes a polyline defined as the path made by an {@link Entity} as it moves over time.
     */
    class PathGraphics {
        /**
         * Describes a polyline defined as the path made by an {@link Entity} as it moves over time.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPathGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the path.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to draw the path.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the numeric Property specifying the width in pixels.
         */
        width: Property;
        /**
         * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
         */
        resolution: Property;
        /**
         * Gets or sets the Property specifying the number of seconds in front of the object to show.
         */
        leadTime: Property;
        /**
         * Gets or sets the Property specifying the number of seconds behind the object to show.
         */
        trailTime: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this path will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PathGraphics): PathGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: PathGraphics): void;
    }
    /**
     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.
     */
    class PathVisualizer {
        /**
         * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.
         * @param scene  (Required) The scene the primitives will be rendered in.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(scene: Scene, entityCollection: EntityCollection);
        /**
         * Updates all of the primitives created by this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * Describes a graphical point located at the position of the containing {@link Entity}.
     */
    class PointGraphics {
        /**
         * Describes a graphical point located at the position of the containing {@link Entity}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPointGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the {@link Color} of the point.
         */
        color: Property;
        /**
         * Gets or sets the numeric Property specifying the size in pixels.
         */
        pixelSize: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the the outline width in pixels.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the boolean Property specifying the visibility of the point.
         */
        show: Property;
        /**
         * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
If undefined, a constant size is used.
         */
        scaleByDistance: Property;
        /**
         * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the points's translucency remains clamped to the nearest bound.
         */
        translucencyByDistance: Property;
        /**
         * Gets or sets the Property specifying the {@link HeightReference}.
         */
        heightReference: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PointGraphics): PointGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: PointGraphics): void;
    }
    /**
     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
     */
    class PointVisualizer {
        /**
         * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
         * @param entityCluster  (Required) The entity cluster to manage the collection of billboards and optionally cluster with other entities.
         * @param entityCollection  (Required) The entityCollection to visualize.
         */
        constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
        /**
         * Updates the primitives created by this visualizer to match their
Entity counterpart at the given time.
         * @param time  (Required) The time to update to.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes and destroys all primitives created by this instance.
         */
        destroy(): void;
    }
    /**
     * A {@link GeometryUpdater} for polygons.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class PolygonGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for polygons.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets a value indicating if the geometry should be drawn on terrain.
         */
        onTerrain: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
The polygon conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
     */
    class PolygonGraphics {
        /**
         * Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
The polygon conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolygonGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the polygon.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the polygon.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the Property specifying the {@link PolygonHierarchy}.
         */
        hierarchy: Property;
        /**
         * Gets or sets the numeric Property specifying the constant altitude of the polygon.
         */
        height: Property;
        /**
         * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
         */
        extrudedHeight: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
         */
        granularity: Property;
        /**
         * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north.
         */
        stRotation: Property;
        /**
         * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the polygon is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the boolean specifying whether or not the the height of each position is used.
If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
         */
        perPositionHeight: Property;
        /**
         * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
         */
        closeTop: Property;
        /**
         * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
         */
        closeBottom: Property;
        /**
         * Get or sets the enum Property specifying whether the polygon
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PolygonGraphics): PolygonGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: PolygonGraphics): void;
    }
    /**
     * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
     */
    class PolylineArrowMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
         * @param color  (Optional) The {@link Color} Property to be used.
         */
        constructor(color?: Property);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the {@link Color} {@link Property}.
         */
        color: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link GeometryUpdater} for polylines.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class PolylineGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for polylines.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
     */
    class PolylineGlowMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineGlowMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the {@link Color} of the line.
         */
        color: Property;
        /**
         * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
         */
        glowPower: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * Describes a polyline defined as a line strip. The first two positions define a line segment,
and each additional position defines a line segment from the previous position. The segments
can be linear connected points or great arcs.
     */
    class PolylineGraphics {
        /**
         * Describes a polyline defined as a line strip. The first two positions define a line segment,
and each additional position defines a line segment from the previous position. The segments
can be linear connected points or great arcs.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the polyline.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to draw the polyline.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the Property specifying the array of {@link Cartesian3}
positions that define the line strip.
         */
        positions: Property;
        /**
         * Gets or sets the numeric Property specifying the width in pixels.
         */
        width: Property;
        /**
         * Gets or sets the boolean Property specifying whether the line segments
should be great arcs or linearly connected.
         */
        followSurface: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if followSurface is true.
         */
        granularity: Property;
        /**
         * Get or sets the enum Property specifying whether the polyline
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PolylineGraphics): PolylineGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: PolylineGraphics): void;
    }
    /**
     * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
     */
    class PolylineOutlineMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineOutlineMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the {@link Color} of the line.
         */
        color: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link GeometryUpdater} for polyline volumes.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class PolylineVolumeGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for polyline volumes.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a polyline volume defined as a line strip and corresponding two dimensional shape which is extruded along it.
The resulting volume conforms to the curvature of the globe.
     */
    class PolylineVolumeGraphics {
        /**
         * Describes a polyline volume defined as a line strip and corresponding two dimensional shape which is extruded along it.
The resulting volume conforms to the curvature of the globe.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineVolumeGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the volume.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the volume.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
         */
        positions: Property;
        /**
         * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
         */
        shape: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between points on the volume.
         */
        granularity: Property;
        /**
         * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the volume is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the {@link CornerType} Property specifying the style of the corners.
         */
        cornerType: Property;
        /**
         * Get or sets the enum Property specifying whether the volume
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this volume will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PolylineVolumeGraphics): PolylineVolumeGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: PolylineVolumeGraphics): void;
    }
    /**
     * The interface for all {@link Property} objects that define a world
location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
This type defines an interface and cannot be instantiated directly.
     */
    class PositionProperty {
        /**
         * The interface for all {@link Property} objects that define a world
location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
This type defines an interface and cannot be instantiated directly.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the reference frame that the position is defined in.
         */
        referenceFrame: number;
        /**
         * Gets the value of the property at the provided time in the fixed frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: Cartesian3): Cartesian3;
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link PositionProperty} whose value is an array whose items are the computed value
of other PositionProperty instances.
     */
    class PositionPropertyArray {
        /**
         * A {@link PositionProperty} whose value is an array whose items are the computed value
of other PositionProperty instances.
         * @param value  (Optional) An array of Property instances.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         */
        constructor(value?: Property[], referenceFrame?: number);
        /**
         * Gets a value indicating if this property is constant.  This property
is considered constant if all property items in the array are constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value or one of the properties in the array also changes.
         */
        definitionChanged: Event;
        /**
         * Gets the reference frame in which the position is defined.
         */
        referenceFrame: number;
        /**
         * Gets the value of the property.
         * @param time  (Optional) The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time?: JulianDate, result?: Cartesian3[]): Cartesian3[];
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Sets the value of the property.
         * @param value  (Required) An array of Property instances.
         */
        setValue(value: Property[]): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * The interface for all properties, which represent a value that can optionally vary over time.
This type defines an interface and cannot be instantiated directly.
     */
    class Property {
        /**
         * The interface for all properties, which represent a value that can optionally vary over time.
This type defines an interface and cannot be instantiated directly.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} whose value is an array whose items are the computed value
of other property instances.
     */
    class PropertyArray {
        /**
         * A {@link Property} whose value is an array whose items are the computed value
of other property instances.
         * @param value  (Optional) An array of Property instances.
         */
        constructor(value?: Property[]);
        /**
         * Gets a value indicating if this property is constant.  This property
is considered constant if all property items in the array are constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value or one of the properties in the array also changes.
         */
        definitionChanged: Event;
        /**
         * Gets the value of the property.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any[]): any[];
        /**
         * Sets the value of the property.
         * @param value  (Required) An array of Property instances.
         */
        setValue(value: Property[]): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.
     */
    class PropertyBag {
        /**
         * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.
         * @param value  (Optional) An object, containing key-value mapping of property names to properties.
         * @param createPropertyCallback  (Optional) A function that will be called when the value of any of the properties in value are not a Property.
         */
        constructor(value?: any, createPropertyCallback?: Function);
        /**
         * Gets the names of all properties registered on this instance.
         */
        propertyNames: any[];
        /**
         * Gets a value indicating if this property is constant.  This property
is considered constant if all property items in this object are constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the set of properties contained in this
object changes, or one of the properties itself changes.
         */
        definitionChanged: Event;
        /**
         * Determines if this object has defined a property with the given name.
         * @param propertyName  (Required) The name of the property to check for.
         */
        hasProperty(propertyName: string): Boolean;
        /**
         * Adds a property to this object.
         * @param propertyName  (Required) The name of the property to add.
         * @param value  (Optional) The value of the new property, if provided.
         * @param createPropertyCallback  (Optional) A function that will be called when the value of this new property is set to a value that is not a Property.
         */
        addProperty(propertyName: string, value?: any, createPropertyCallback?: Function): void;
        /**
         * Removed a property previously added with addProperty.
         * @param propertyName  (Required) The name of the property to remove.
         */
        removeProperty(propertyName: string): void;
        /**
         * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall
result will be an object, mapping property names to those values.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
Note that any properties in result which are not part of this PropertyBag will be left as-is.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         * @param createPropertyCallback  (Optional) A function that will be called when the value of any of the properties in value are not a Property.
         */
        merge(source: any, createPropertyCallback?: Function): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link GeometryUpdater} for rectangles.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class RectangleGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for rectangles.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets a value indicating if the geometry should be drawn on terrain.
         */
        onTerrain: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         */
        createDynamicUpdater(primitives: PrimitiveCollection, groundPrimitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes graphics for a {@link Rectangle}.
The rectangle conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
     */
    class RectangleGraphics {
        /**
         * Describes graphics for a {@link Rectangle}.
The rectangle conforms to the curvature of the globe and can be placed on the surface or
at altitude and can optionally be extruded into a volume.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IRectangleGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the rectangle.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the {@link Rectangle}.
         */
        coordinates: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the rectangle.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the numeric Property specifying the altitude of the rectangle.
         */
        height: Property;
        /**
         * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
Setting this property creates volume starting at height and ending at this altitude.
         */
        extrudedHeight: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
         */
        granularity: Property;
        /**
         * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
         */
        stRotation: Property;
        /**
         * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
         */
        rotation: Property;
        /**
         * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the rectangle is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Gets or sets the boolean Property specifying whether the rectangle has a top cover when extruded.
         */
        closeTop: Property;
        /**
         * Gets or sets the boolean Property specifying whether the rectangle has a bottom cover when extruded.
         */
        closeBottom: Property;
        /**
         * Get or sets the enum Property specifying whether the rectangle
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this rectangle will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: RectangleGraphics): RectangleGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: RectangleGraphics): void;
    }
    /**
     * A {@link Property} which transparently links to another property on a provided object.
     */
    class ReferenceProperty {
        /**
         * A {@link Property} which transparently links to another property on a provided object.
         * @param targetCollection  (Required) The entity collection which will be used to resolve the reference.
         * @param targetId  (Required) The id of the entity which is being referenced.
         * @param targetPropertyNames  (Required) The names of the property on the target entity which we will use.
         */
        constructor(targetCollection: EntityCollection, targetId: string, targetPropertyNames: string[]);
        /**
         * Gets a value indicating if this property is constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever the referenced property's definition is changed.
         */
        definitionChanged: Event;
        /**
         * Gets the reference frame that the position is defined in.
This property is only valid if the referenced property is a {@link PositionProperty}.
         */
        referenceFrame: number;
        /**
         * Gets the id of the entity being referenced.
         */
        targetId: string;
        /**
         * Gets the collection containing the entity being referenced.
         */
        targetCollection: EntityCollection;
        /**
         * Gets the array of property names used to retrieve the referenced property.
         */
        targetPropertyNames: string[];
        /**
         * Gets the resolved instance of the underlying referenced property.
         */
        resolvedProperty: Property;
        /**
         * Creates a new instance given the entity collection that will
be used to resolve it and a string indicating the target entity id and property.
The format of the string is "objectId#foo.bar", where # separates the id from
property path and . separates sub-properties.  If the reference identifier or
or any sub-properties contains a # . or \ they must be escaped.
         * @param targetCollection  (Required) TODO: This parameter has no description. Contact this library author if this parameter should be documented

         * @param referenceString  (Required) TODO: This parameter has no description. Contact this library author if this parameter should be documented

         */
        static fromString(targetCollection: EntityCollection, referenceString: string): ReferenceProperty;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
This method is only valid if the property being referenced is a {@link PositionProperty}.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Gets the {@link Material} type at the provided time.
This method is only valid if the property being referenced is a {@link MaterialProperty}.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link SampledProperty} which is also a {@link PositionProperty}.
     */
    class SampledPositionProperty {
        /**
         * A {@link SampledProperty} which is also a {@link PositionProperty}.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         * @param numberOfDerivatives  (Optional) The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...
         */
        constructor(referenceFrame?: number, numberOfDerivatives?: number);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the reference frame in which the position is defined.
         */
        referenceFrame: number;
        /**
         * Gets the degree of interpolation to perform when retrieving a value.
         */
        interpolationDegree: number;
        /**
         * Gets the interpolation algorithm to use when retrieving a value.
         */
        interpolationAlgorithm: number;
        /**
         * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
         */
        numberOfDerivatives: Boolean;
        /**
         * Gets or sets the type of extrapolation to perform when a value
is requested at a time after any available samples.
         */
        forwardExtrapolationType: number;
        /**
         * Gets or sets the amount of time to extrapolate forward before
the property becomes undefined.  A value of 0 will extrapolate forever.
         */
        forwardExtrapolationDuration: number;
        /**
         * Gets or sets the type of extrapolation to perform when a value
is requested at a time before any available samples.
         */
        backwardExtrapolationType: number;
        /**
         * Gets or sets the amount of time to extrapolate backward
before the property becomes undefined.  A value of 0 will extrapolate forever.
         */
        backwardExtrapolationDuration: number;
        /**
         * Gets the position at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: Cartesian3): Cartesian3;
        /**
         * Gets the position at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Sets the algorithm and degree to use when interpolating a position.
         * @param options  (Optional) Object with the following properties:
         */
        setInterpolationOptions(options?: SampledPositionProperty.ISampledPositionPropertySetInterpolationOptionsOptions): void;
        /**
         * Adds a new sample.
         * @param time  (Required) The sample time.
         * @param position  (Required) The position at the provided time.
         * @param derivatives  (Optional) The array of derivative values at the provided time.
         */
        addSample(time: JulianDate, position: Cartesian3, derivatives?: Cartesian3[]): void;
        /**
         * Adds multiple samples via parallel arrays.
         * @param times  (Required) An array of JulianDate instances where each index is a sample time.
         * @param positions  (Required) An array of Cartesian3 position instances, where each value corresponds to the provided time index.
         * @param derivatives  (Optional) An array where each value is another array containing derivatives for the corresponding time index.
         */
        addSamples(times: JulianDate[], positions: Cartesian3[], derivatives?: any[][]): void;
        /**
         * Adds samples as a single packed array where each new sample is represented as a date,
followed by the packed representation of the corresponding value and derivatives.
         * @param packedSamples  (Required) The array of packed samples.
         * @param epoch  (Optional) If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
         */
        addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} whose value is interpolated for a given time from the
provided set of samples and specified interpolation algorithm and degree.
     */
    class SampledProperty {
        /**
         * A {@link Property} whose value is interpolated for a given time from the
provided set of samples and specified interpolation algorithm and degree.
         * @param type  (Required) The type of property.
         * @param derivativeTypes  (Optional) When supplied, indicates that samples will contain derivative information of the specified types.
         */
        constructor(type: number|Packable, derivativeTypes?: Packable[]);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the type of property.
         */
        type: any;
        /**
         * Gets the derivative types used by this property.
         */
        derivativeTypes: Packable[];
        /**
         * Gets the degree of interpolation to perform when retrieving a value.
         */
        interpolationDegree: number;
        /**
         * Gets the interpolation algorithm to use when retrieving a value.
         */
        interpolationAlgorithm: number;
        /**
         * Gets or sets the type of extrapolation to perform when a value
is requested at a time after any available samples.
         */
        forwardExtrapolationType: number;
        /**
         * Gets or sets the amount of time to extrapolate forward before
the property becomes undefined.  A value of 0 will extrapolate forever.
         */
        forwardExtrapolationDuration: number;
        /**
         * Gets or sets the type of extrapolation to perform when a value
is requested at a time before any available samples.
         */
        backwardExtrapolationType: number;
        /**
         * Gets or sets the amount of time to extrapolate backward
before the property becomes undefined.  A value of 0 will extrapolate forever.
         */
        backwardExtrapolationDuration: number;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Sets the algorithm and degree to use when interpolating a value.
         * @param options  (Optional) Object with the following properties:
         */
        setInterpolationOptions(options?: SampledProperty.ISampledPropertySetInterpolationOptionsOptions): void;
        /**
         * Adds a new sample
         * @param time  (Required) The sample time.
         * @param value  (Required) The value at the provided time.
         * @param derivatives  (Optional) The array of derivatives at the provided time.
         */
        addSample(time: JulianDate, value: Packable, derivatives?: Packable[]): void;
        /**
         * Adds an array of samples
         * @param times  (Required) An array of JulianDate instances where each index is a sample time.
         * @param values  (Required) The array of values, where each value corresponds to the provided times index.
         * @param derivativeValues  (Optional) An array where each item is the array of derivatives at the equivalent time index.
         */
        addSamples(times: JulianDate[], values: Packable[], derivativeValues?: any[][]): void;
        /**
         * Adds samples as a single packed array where each new sample is represented as a date,
followed by the packed representation of the corresponding value and derivatives.
         * @param packedSamples  (Required) The array of packed samples.
         * @param epoch  (Optional) If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
         */
        addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
     */
    class StripeMaterialProperty {
        /**
         * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IStripeMaterialPropertyOptions);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the Property specifying the {@link StripeOrientation}/
         */
        orientation: Property;
        /**
         * Gets or sets the Property specifying the first {@link Color}.
         */
        evenColor: Property;
        /**
         * Gets or sets the Property specifying the second {@link Color}.
         */
        oddColor: Property;
        /**
         * Gets or sets the numeric Property specifying the point into the pattern
to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning
of the odd color, 2.0 being the even color again, and any multiple or fractional values
being in between.
         */
        offset: Property;
        /**
         * Gets or sets the numeric Property specifying how many times the stripes repeat.
         */
        repeat: Property;
        /**
         * Gets the {@link Material} type at the provided time.
         * @param time  (Required) The time for which to retrieve the type.
         */
        getType(time: JulianDate): string;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link TimeIntervalCollectionProperty} which is also a {@link PositionProperty}.
     */
    class TimeIntervalCollectionPositionProperty {
        /**
         * A {@link TimeIntervalCollectionProperty} which is also a {@link PositionProperty}.
         * @param referenceFrame  (Optional) The reference frame in which the position is defined.
         */
        constructor(referenceFrame?: number);
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is considered to have changed if a call to getValue would return
a different result for the same time.
         */
        definitionChanged: Event;
        /**
         * Gets the interval collection.
         */
        intervals: TimeIntervalCollection;
        /**
         * Gets the reference frame in which the position is defined.
         */
        referenceFrame: number;
        /**
         * Gets the value of the property at the provided time in the fixed frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @param time  (Required) The time for which to retrieve the value.
         * @param referenceFrame  (Required) The desired referenceFrame of the result.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValueInReferenceFrame(time: JulianDate, referenceFrame: number, result?: Cartesian3): Cartesian3;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
data property of each {@link TimeInterval} represents the value at time.
     */
    class TimeIntervalCollectionProperty {
        /**
         * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
data property of each {@link TimeInterval} represents the value at time.
         */
        constructor();
        /**
         * Gets a value indicating if this property is constant.  A property is considered
constant if getValue always returns the same result for the current definition.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
The definition is changed whenever setValue is called with data different
than the current value.
         */
        definitionChanged: Event;
        /**
         * Gets the interval collection.
         */
        intervals: TimeIntervalCollection;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Required) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time: JulianDate, result?: any): any;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} which evaluates to a {@link Quaternion} rotation
based on the velocity of the provided {@link PositionProperty}.
     */
    class VelocityOrientationProperty {
        /**
         * A {@link Property} which evaluates to a {@link Quaternion} rotation
based on the velocity of the provided {@link PositionProperty}.
         * @param position  (Optional) The position property used to compute the orientation.
         * @param ellipsoid  (Optional) The ellipsoid used to determine which way is up.
         */
        constructor(position?: Property, ellipsoid?: Ellipsoid);
        /**
         * Gets a value indicating if this property is constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the position property used to compute orientation.
         */
        position: Property;
        /**
         * Gets or sets the ellipsoid used to determine which way is up.
         */
        ellipsoid: Property;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Optional) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time?: JulianDate, result?: Quaternion): Quaternion;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * A {@link Property} which evaluates to a {@link Cartesian3} vector
based on the velocity of the provided {@link PositionProperty}.
     */
    class VelocityVectorProperty {
        /**
         * A {@link Property} which evaluates to a {@link Cartesian3} vector
based on the velocity of the provided {@link PositionProperty}.
         * @param position  (Optional) The position property used to compute the velocity.
         * @param normalize  (Optional) Whether to normalize the computed velocity vector.
         */
        constructor(position?: Property, normalize?: Boolean);
        /**
         * Gets a value indicating if this property is constant.
         */
        isConstant: Boolean;
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the position property used to compute the velocity vector.
         */
        position: Property;
        /**
         * Gets or sets whether the vector produced by this property
will be normalized or not.
         */
        normalize: Boolean;
        /**
         * Gets the value of the property at the provided time.
         * @param time  (Optional) The time for which to retrieve the value.
         * @param result  (Optional) The object to store the value into, if omitted, a new instance is created and returned.
         */
        getValue(time?: JulianDate, result?: Cartesian3): Cartesian3;
        /**
         * Compares this property to the provided property and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The other property.
         */
        equals(other?: Property): Boolean;
    }
    /**
     * Defines the interface for visualizers. Visualizers are plug-ins to
{@link DataSourceDisplay} that render data associated with
{@link DataSource} instances.
This object is an interface for documentation purposes and is not intended
to be instantiated directly.
     */
    class Visualizer {
        /**
         * Defines the interface for visualizers. Visualizers are plug-ins to
{@link DataSourceDisplay} that render data associated with
{@link DataSource} instances.
This object is an interface for documentation purposes and is not intended
to be instantiated directly.
         */
        constructor();
        /**
         * Updates the visualization to the provided time.
         * @param time  (Required) The time.
         */
        update(time: JulianDate): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Removes all visualization and cleans up any resources associated with this instance.
         */
        destroy(): void;
    }
    /**
     * A {@link GeometryUpdater} for walls.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     */
    class WallGeometryUpdater {
        /**
         * A {@link GeometryUpdater} for walls.
Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
         * @param entity  (Required) The entity containing the geometry to be visualized.
         * @param scene  (Required) The scene where visualization is taking place.
         */
        constructor(entity: Entity, scene: Scene);
        /**
         * Gets the type of Appearance to use for simple color-based geometry.
         */
        perInstanceColorAppearanceType: Appearance;
        /**
         * Gets the type of Appearance to use for material-based geometry.
         */
        materialAppearanceType: Appearance;
        /**
         * Gets the entity associated with this geometry.
         */
        entity: Entity;
        /**
         * Gets a value indicating if the geometry has a fill component.
         */
        fillEnabled: Boolean;
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         */
        hasConstantFill: Boolean;
        /**
         * Gets the material property used to fill the geometry.
         */
        fillMaterialProperty: MaterialProperty;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        outlineEnabled: Boolean;
        /**
         * Gets a value indicating if the geometry has an outline component.
         */
        hasConstantOutline: Boolean;
        /**
         * Gets the {@link Color} property for the geometry outline.
         */
        outlineColorProperty: Property;
        /**
         * Gets the constant with of the geometry outline, in pixels.
This value is only valid if isDynamic is false.
         */
        outlineWidth: number;
        /**
         * Gets the property specifying whether the geometry
casts or receives shadows from each light source.
         */
        shadowsProperty: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         */
        distanceDisplayConditionProperty: Property;
        /**
         * Gets a value indicating if the geometry is time-varying.
If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
returned by GeometryUpdater#createDynamicUpdater.
         */
        isDynamic: Boolean;
        /**
         * Gets a value indicating if the geometry is closed.
This property is only valid for static geometry.
         */
        isClosed: Boolean;
        /**
         * Gets an event that is raised whenever the public properties
of this updater change.
         */
        geometryChanged: Boolean;
        /**
         * Checks if the geometry is outlined at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isOutlineVisible(time: JulianDate): Boolean;
        /**
         * Checks if the geometry is filled at the provided time.
         * @param time  (Required) The time for which to retrieve visibility.
         */
        isFilled(time: JulianDate): Boolean;
        /**
         * Creates the geometry instance which represents the fill of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createFillGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Creates the geometry instance which represents the outline of the geometry.
         * @param time  (Required) The time to use when retrieving initial attribute values.
         */
        createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
        /**
         * Returns true if this object was destroyed; otherwise, false.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
         */
        destroy(): void;
        /**
         * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
         * @param primitives  (Required) The primitive collection to use.
         */
        createDynamicUpdater(primitives: PrimitiveCollection): DynamicGeometryUpdater;
    }
    /**
     * Describes a two dimensional wall defined as a line strip and optional maximum and minimum heights.
The wall conforms to the curvature of the globe and can be placed along the surface or at altitude.
     */
    class WallGraphics {
        /**
         * Describes a two dimensional wall defined as a line strip and optional maximum and minimum heights.
The wall conforms to the curvature of the globe and can be placed along the surface or at altitude.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IWallGraphicsOptions);
        /**
         * Gets the event that is raised whenever a property or sub-property is changed or modified.
         */
        definitionChanged: Event;
        /**
         * Gets or sets the boolean Property specifying the visibility of the wall.
         */
        show: Property;
        /**
         * Gets or sets the Property specifying the material used to fill the wall.
         */
        material: MaterialProperty;
        /**
         * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
         */
        positions: Property;
        /**
         * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
If defined, the array must be the same length as {@link Wall#positions}.
         */
        minimumHeights: Property;
        /**
         * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
If defined, the array must be the same length as {@link Wall#positions}.
         */
        maximumHeights: Property;
        /**
         * Gets or sets the numeric Property specifying the angular distance between points on the wall.
         */
        granularity: Property;
        /**
         * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
         */
        fill: Property;
        /**
         * Gets or sets the Property specifying whether the wall is outlined.
         */
        outline: Property;
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         */
        outlineColor: Property;
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         */
        outlineWidth: Property;
        /**
         * Get or sets the enum Property specifying whether the wall
casts or receives shadows from each light source.
         */
        shadows: Property;
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this wall will be displayed.
         */
        distanceDisplayCondition: Property;
        /**
         * Duplicates this instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: WallGraphics): WallGraphics;
        /**
         * Assigns each unassigned property on this object to the value
of the same property on the provided source object.
         * @param source  (Required) The object to be merged into this object.
         */
        merge(source: WallGraphics): void;
    }
    /**
     * An appearance defines the full GLSL vertex and fragment shaders and the
render state used to draw a {@link Primitive}.  All appearances implement
this base <code>Appearance</code> interface.
     */
    class Appearance {
        /**
         * An appearance defines the full GLSL vertex and fragment shaders and the
render state used to draw a {@link Primitive}.  All appearances implement
this base <code>Appearance</code> interface.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IAppearanceOptions);
        /**
         * The material used to determine the fragment color.  Unlike other {@link Appearance}
properties, this is not read-only, so an appearance's material can change on the fly.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.  The full fragment shader
source is built procedurally taking into account the {@link Appearance#material}.
Use {@link Appearance#getFragmentShaderSource} to get the full source.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed.
         */
        closed: Boolean;
        /**
         * Procedurally creates the full GLSL fragment shader source for this appearance
taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
used, if available.
     */
    class ArcGisMapServerImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
used, if available.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IArcGisMapServerImageryProviderOptions);
        /**
         * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will
invoke the "identify" operation on the ArcGIS server and return the features included in the response.  If false,
{@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
without communicating with the server.
         */
        enablePickFeatures: Boolean;
        /**
         * Gets the URL of the ArcGIS MapServer.
         */
        url: string;
        /**
         * Gets the ArcGIS token used to authenticate with the ArcGis MapServer service.
         */
        token: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether this imagery provider is using pre-cached tiles from the
ArcGIS MapServer.  If the imagery provider is not yet ready ({@link ArcGisMapServerImageryProvider#ready}), this function
will return the value of `options.usePreCachedTilesIfAvailable`, even if the MapServer does
not have pre-cached tiles.
         */
        usingPrecachedTiles: Boolean;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * /**
Asynchronously determines what features, if any, are located at a given longitude and latitude within
a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * A viewport-aligned image positioned in the 3D scene, that is created
and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
properties are set by calling {@link BillboardCollection#add}.
<br /><br />
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
     */
    class Billboard {
        /**
         * A viewport-aligned image positioned in the 3D scene, that is created
and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
properties are set by calling {@link BillboardCollection#add}.
<br /><br />
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
         */
        constructor();
        /**
         * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
of removing it and re-adding it to the collection.
         */
        show: Boolean;
        /**
         * Gets or sets the Cartesian position of this billboard.
         */
        position: Cartesian3;
        /**
         * Gets or sets the height reference of this billboard.
         */
        heightReference: number;
        /**
         * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
to align multiple billboards and labels at the same position, e.g., an image and text.  The
screen space origin is the top, left corner of the canvas; <code>x</code> increases from
left to right, and <code>y</code> increases from top to bottom.
<br /><br />
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
<td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
</tr></table>
The billboard's origin is indicated by the yellow point.
</div>
         */
        pixelOffset: Cartesian2;
        /**
         * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
scaleByDistance will be disabled.
         */
        scaleByDistance: NearFarScalar;
        /**
         * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
translucencyByDistance will be disabled.
         */
        translucencyByDistance: NearFarScalar;
        /**
         * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
pixelOffsetScaleByDistance will be disabled.
         */
        pixelOffsetScaleByDistance: NearFarScalar;
        /**
         * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
<code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
which is typically meters.
<br /><br />
An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
arrange a billboard above its corresponding 3D model.
<br /><br />
Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
appear on top of the Earth regardless of the viewer's or Earth's orientation.
<br /><br />
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
<td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
</tr></table>
<code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
</div>
         */
        eyeOffset: Cartesian3;
        /**
         * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
to the left, center, or right of its position.
<br /><br />
<div align='center'>
<img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
</div>
         */
        horizontalOrigin: number;
        /**
         * Gets or sets the vertical origin of this billboard, which determines if the billboard is
to the above, below, or at the center of its position.
<br /><br />
<div align='center'>
<img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
</div>
         */
        verticalOrigin: number;
        /**
         * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
<code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
the billboard.
<br /><br />
<div align='center'>
<img src='images/Billboard.setScale.png' width='400' height='300' /><br/>
From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
and <code>2.0</code>.
</div>
         */
        scale: number;
        /**
         * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
the same white texture may be used by many different billboards, each with a different color, to create
colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
<br /><br />
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
<td align='center'><code>alpha : 0.5</code><br/><img src='images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
</tr></table>
</div>
<br />
The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
<code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
(no intensity) to <code>1.0</code> (full intensity).
         */
        color: number;
        /**
         * Gets or sets the rotation angle in radians.
         */
        rotation: number;
        /**
         * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
The default is the zero vector, which means the billboard is aligned to the screen up vector.
         */
        alignedAxis: Cartesian3;
        /**
         * Gets or sets a width for the billboard. If undefined, the image width will be used.
         */
        width: number;
        /**
         * Gets or sets a height for the billboard. If undefined, the image height will be used.
         */
        height: number;
        /**
         * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
otherwise, the size is in pixels.
         */
        sizeInMeters: Boolean;
        /**
         * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
         */
        distanceDisplayCondition: DistanceDisplayCondition;
        /**
         * Gets or sets the user-defined object returned when the billboard is picked.
         */
        id: any;
        /**
         * <p>
Gets or sets the image to be used for this billboard.  If a texture has already been created for the
given image, the existing texture is used.
</p>
<p>
This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
a canvas, or another billboard's image property (from the same billboard collection).
</p>
         */
        image: string;
        /**
         * When <code>true</code>, this billboard is ready to render, i.e., the image
has been downloaded and the WebGL resources are created.
         */
        ready: Boolean;
        /**
         * <p>
Sets the image to be used for this billboard.  If a texture has already been created for the
given id, the existing texture is used.
</p>
<p>
This function is useful for dynamically creating textures that are shared across many billboards.
Only the first billboard will actually call the function and create the texture, while subsequent
billboards created with the same id will simply re-use the existing texture.
</p>
<p>
To load an image from a URL, setting the {@link Billboard#image} property is more convenient.
</p>
         * @param id  (Required) The id of the image.  This can be any string that uniquely identifies the image.
         * @param image  (Required) The image to load.  This parameter
       can either be a loaded Image or Canvas, a URL which will be loaded as an Image automatically,
       or a function which will be called to create the image if it hasn't been loaded already.
         */
        setImage(id: string, image: HTMLImageElement|HTMLCanvasElement|string|Billboard.CreateImageCallback): void;
        /**
         * Uses a sub-region of the image with the given id as the image for this billboard,
measured in pixels from the bottom-left.
         * @param id  (Required) The id of the image to use.
         * @param subRegion  (Required) The sub-region of the image.
         */
        setImageSubRegion(id: string, subRegion: BoundingRectangle): void;
        /**
         * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
left to right, and <code>y</code> increases from top to bottom.
         * @param scene  (Required) The scene.
         * @param result  (Optional) The object onto which to store the result.
         */
        computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
        /**
         * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
are equal.  Billboards in different collections can be equal.
         * @param other  (Required) The billboard to compare for equality.
         */
        equals(other: Billboard): Boolean;
    }
    /**
     * A renderable collection of billboards.  Billboards are viewport-aligned
images positioned in the 3D scene.
<br /><br />
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
<br /><br />
Billboards are added and removed from the collection using {@link BillboardCollection#add}
and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures
for images with the same identifier.
     */
    class BillboardCollection {
        /**
         * A renderable collection of billboards.  Billboards are viewport-aligned
images positioned in the 3D scene.
<br /><br />
<div align='center'>
<img src='images/Billboard.png' width='400' height='300' /><br />
Example billboards
</div>
<br /><br />
Billboards are added and removed from the collection using {@link BillboardCollection#add}
and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures
for images with the same identifier.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IBillboardCollectionOptions);
        /**
         * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * Returns the number of billboards in this collection.  This is commonly used with
{@link BillboardCollection#get} to iterate over all the billboards
in the collection.
         */
        length: number;
        /**
         * Creates and adds a billboard with the specified initial properties to the collection.
The added billboard is returned so it can be modified or removed from the collection later.
         * @param billboard  (Optional) A template describing the billboard's properties as shown in Example 1.
         */
        add(billboard?: any): Billboard;
        /**
         * Removes a billboard from the collection.
         * @param billboard  (Required) The billboard to remove.
         */
        remove(billboard: Billboard): Boolean;
        /**
         * Removes all billboards from the collection.
         */
        removeAll(): void;
        /**
         * Check whether this collection contains a given billboard.
         * @param billboard  (Optional) The billboard to check for.
         */
        contains(billboard?: Billboard): Boolean;
        /**
         * Returns the billboard in the collection at the specified index.  Indices are zero-based
and increase as billboards are added.  Removing a billboard shifts all billboards after
it to the left, changing their indices.  This function is commonly used with
{@link BillboardCollection#length} to iterate over all the billboards
in the collection.
         * @param index  (Required) The zero-based index of the billboard.
         */
        get(index: number): Billboard;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Provides tiled imagery using the Bing Maps Imagery REST API.
     */
    class BingMapsImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery using the Bing Maps Imagery REST API.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IBingMapsImageryProviderOptions);
        /**
         * The default {@link ImageryLayer#gamma} to use for imagery layers created for this provider.
Changing this value after creating an {@link ImageryLayer} for this provider will have
no effect.  Instead, set the layer's {@link ImageryLayer#gamma} property.
         */
        defaultGamma: number;
        /**
         * Gets the name of the BingMaps server url hosting the imagery.
         */
        url: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the Bing Maps key.
         */
        key: string;
        /**
         * Gets the type of Bing Maps imagery to load.
         */
        mapStyle: number;
        /**
         * The culture to use when requesting Bing Maps imagery. Not
all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
for information on the supported cultures.
         */
        culture: string;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link BingMapsImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
and texture upload time.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link BingMapsImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
        /**
         * Converts a tiles (x, y, level) position into a quadkey used to request an image
from a Bing Maps server.
         * @param x  (Required) The tile's x coordinate.
         * @param y  (Required) The tile's y coordinate.
         * @param level  (Required) The tile's zoom level.
         */
        static tileXYToQuadKey(x: number, y: number, level: number): void;
        /**
         * Converts a tile's quadkey used to request an image from a Bing Maps server into the
(x, y, level) position.
         * @param quadkey  (Required) The tile's quad key
         */
        static quadKeyToTileXY(quadkey: string): void;
    }
    /**
     * The camera is defined by a position, orientation, and view frustum.
<br /><br />
The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
<br /><br />
The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
     */
    class Camera {
        /**
         * The camera is defined by a position, orientation, and view frustum.
<br /><br />
The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
<br /><br />
The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
         * @param scene  (Required) The scene.
         */
        constructor(scene: Scene);
        /**
         * The position of the camera.
         */
        position: Cartesian3;
        /**
         * The view direction of the camera.
         */
        direction: Cartesian3;
        /**
         * The up direction of the camera.
         */
        up: Cartesian3;
        /**
         * The right direction of the camera.
         */
        right: Cartesian3;
        /**
         * The region of space in view.
         */
        frustum: Frustum;
        /**
         * The default amount to move the camera when an argument is not
provided to the move methods.
         */
        defaultMoveAmount: number;
        /**
         * The default amount to rotate the camera when an argument is not
provided to the look methods.
         */
        defaultLookAmount: number;
        /**
         * The default amount to rotate the camera when an argument is not
provided to the rotate methods.
         */
        defaultRotateAmount: number;
        /**
         * The default amount to move the camera when an argument is not
provided to the zoom methods.
         */
        defaultZoomAmount: number;
        /**
         * If set, the camera will not be able to rotate past this axis in either direction.
         */
        constrainedAxis: Cartesian3;
        /**
         * The factor multiplied by the the map size used to determine where to clamp the camera position
when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.
         */
        maximumZoomFactor: number;
        /**
         * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.
         */
        percentageChanged: number;
        /**
         * The default rectangle the camera will view on creation.
         */
        DEFAULT_VIEW_RECTANGLE: Rectangle;
        /**
         * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.
A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero
will move it further away from the extent, and a value less than zero will move it close to the extent.
         */
        DEFAULT_VIEW_FACTOR: number;
        /**
         * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.
         */
        transform: Matrix4;
        /**
         * Gets the inverse camera transform.
         */
        inverseTransform: Matrix4;
        /**
         * Gets the view matrix.
         */
        viewMatrix: Matrix4;
        /**
         * Gets the inverse view matrix.
         */
        inverseViewMatrix: Matrix4;
        /**
         * Gets the {@link Cartographic} position of the camera, with longitude and latitude
expressed in radians and height in meters.  In 2D and Columbus View, it is possible
for the returned longitude and latitude to be outside the range of valid longitudes
and latitudes when the camera is outside the map.
         */
        positionCartographic: Cartographic;
        /**
         * Gets the position of the camera in world coordinates.
         */
        positionWC: Cartesian3;
        /**
         * Gets the view direction of the camera in world coordinates.
         */
        directionWC: Cartesian3;
        /**
         * Gets the up direction of the camera in world coordinates.
         */
        upWC: Cartesian3;
        /**
         * Gets the right direction of the camera in world coordinates.
         */
        rightWC: Cartesian3;
        /**
         * Gets the camera heading in radians.
         */
        heading: number;
        /**
         * Gets the camera pitch in radians.
         */
        pitch: number;
        /**
         * Gets the camera roll in radians.
         */
        roll: number;
        /**
         * Gets the event that will be raised at when the camera starts to move.
         */
        moveStart: Event;
        /**
         * Gets the event that will be raised when the camera has stopped moving.
         */
        moveEnd: Event;
        /**
         * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.
         */
        changed: Event;
        /**
         * Sets the camera position, orientation and transform.
         * @param options  (Required) Object with the following properties:
         */
        setView(options: Camera.ICameraSetViewOptions): void;
        /**
         * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set
the default view for the 3D scene.  The home view for 2D and columbus view shows the
entire map.
         * @param duration  (Optional) The number of seconds to complete the camera flight to home. See {@link Camera#flyTo}
         */
        flyHome(duration?: number): void;
        /**
         * Transform a vector or point from world coordinates to the camera's reference frame.
         * @param cartesian  (Required) The vector or point to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        worldToCameraCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
        /**
         * Transform a point from world coordinates to the camera's reference frame.
         * @param cartesian  (Required) The point to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        worldToCameraCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Transform a vector from world coordinates to the camera's reference frame.
         * @param cartesian  (Required) The vector to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        worldToCameraCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Transform a vector or point from the camera's reference frame to world coordinates.
         * @param cartesian  (Required) The vector or point to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        cameraToWorldCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
        /**
         * Transform a point from the camera's reference frame to world coordinates.
         * @param cartesian  (Required) The point to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        cameraToWorldCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Transform a vector from the camera's reference frame to world coordinates.
         * @param cartesian  (Required) The vector to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        cameraToWorldCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
        /**
         * Translates the camera's position by <code>amount</code> along <code>direction</code>.
         * @param direction  (Required) The direction to move.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        move(direction: Cartesian3, amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the camera's view vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveForward(amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the opposite direction
of the camera's view vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveBackward(amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the camera's up vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveUp(amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the opposite direction
of the camera's up vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveDown(amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the camera's right vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveRight(amount?: number): void;
        /**
         * Translates the camera's position by <code>amount</code> along the opposite direction
of the camera's right vector.
         * @param amount  (Optional) The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
         */
        moveLeft(amount?: number): void;
        /**
         * Rotates the camera around its up vector by amount, in radians, in the opposite direction
of its right vector.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        lookLeft(amount?: number): void;
        /**
         * Rotates the camera around its up vector by amount, in radians, in the direction
of its right vector.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        lookRight(amount?: number): void;
        /**
         * Rotates the camera around its right vector by amount, in radians, in the direction
of its up vector.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        lookUp(amount?: number): void;
        /**
         * Rotates the camera around its right vector by amount, in radians, in the opposite direction
of its up vector.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        lookDown(amount?: number): void;
        /**
         * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
         * @param axis  (Required) The axis to rotate around.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        look(axis: Cartesian3, angle?: number): void;
        /**
         * Rotate the camera counter-clockwise around its direction vector by amount, in radians.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        twistLeft(amount?: number): void;
        /**
         * Rotate the camera clockwise around its direction vector by amount, in radians.
         * @param amount  (Optional) The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
         */
        twistRight(amount?: number): void;
        /**
         * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
of the camera's position to the center of the camera's reference frame remains the same.
         * @param axis  (Required) The axis to rotate around given in world coordinates.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
         */
        rotate(axis: Cartesian3, angle?: number): void;
        /**
         * Rotates the camera around the center of the camera's reference frame by angle downwards.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
         */
        rotateDown(angle?: number): void;
        /**
         * Rotates the camera around the center of the camera's reference frame by angle upwards.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
         */
        rotateUp(angle?: number): void;
        /**
         * Rotates the camera around the center of the camera's reference frame by angle to the right.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
         */
        rotateRight(angle?: number): void;
        /**
         * Rotates the camera around the center of the camera's reference frame by angle to the left.
         * @param angle  (Optional) The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
         */
        rotateLeft(angle?: number): void;
        /**
         * Zooms <code>amount</code> along the camera's view vector.
         * @param amount  (Optional) The amount to move. Defaults to <code>defaultZoomAmount</code>.
         */
        zoomIn(amount?: number): void;
        /**
         * Zooms <code>amount</code> along the opposite direction of
the camera's view vector.
         * @param amount  (Optional) The amount to move. Defaults to <code>defaultZoomAmount</code>.
         */
        zoomOut(amount?: number): void;
        /**
         * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and
Columbus view, this is the distance to the map.
         */
        getMagnitude(): number;
        /**
         * Sets the camera position and orientation using a target and offset. The target must be given in
world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.
If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.

In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
determined from the offset, the heading will be north.
         * @param target  (Required) The target position in world coordinates.
         * @param offset  (Required) The offset from the target in the local east-north-up reference frame centered at the target.
         */
        lookAt(target: Cartesian3, offset: Cartesian3|HeadingPitchRange): void;
        /**
         * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.
If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.

In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the
target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
determined from the offset, the heading will be north.
         * @param transform  (Required) The transformation matrix defining the reference frame.
         * @param offset  (Optional) The offset from the target in a reference frame centered at the target.
         */
        lookAtTransform(transform: Matrix4, offset?: Cartesian3|HeadingPitchRange): void;
        /**
         * Get the camera position needed to view an rectangle on an ellipsoid or map
         * @param rectangle  (Required) The rectangle to view.
         * @param result  (Optional) The camera position needed to view the rectangle
         */
        getRectangleCameraCoordinates(rectangle: Rectangle, result?: Cartesian3): Cartesian3;
        /**
         * Pick an ellipsoid or map.
         * @param windowPosition  (Required) The x and y coordinates of a pixel.
         * @param ellipsoid  (Optional) The ellipsoid to pick.
         * @param result  (Optional) The object onto which to store the result.
         */
        pickEllipsoid(windowPosition: Cartesian2, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
        /**
         * Create a ray from the camera position through the pixel at <code>windowPosition</code>
in world coordinates.
         * @param windowPosition  (Required) The x and y coordinates of a pixel.
         * @param result  (Optional) The object onto which to store the result.
         */
        getPickRay(windowPosition: Cartesian2, result?: Ray): Ray;
        /**
         * Return the distance from the camera to the front of the bounding sphere.
         * @param boundingSphere  (Required) The bounding sphere in world coordinates.
         */
        distanceToBoundingSphere(boundingSphere: BoundingSphere): number;
        /**
         * Return the pixel size in meters.
         * @param boundingSphere  (Required) The bounding sphere in world coordinates.
         * @param drawingBufferWidth  (Required) The drawing buffer width.
         * @param drawingBufferHeight  (Required) The drawing buffer height.
         */
        getPixelSize(boundingSphere: BoundingSphere, drawingBufferWidth: number, drawingBufferHeight: number): number;
        /**
         * Cancels the current camera flight if one is in progress.
The camera is left at it's current location.
         */
        cancelFlight(): void;
        /**
         * Flies the camera from its current position to a new position.
         * @param options  (Required) Object with the following properties:
         */
        flyTo(options: Camera.ICameraFlyToOptions): void;
        /**
         * Sets the camera so that the current view contains the provided bounding sphere.

<p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
The heading and the pitch angles are defined in the local east-north-up reference frame.
The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
zero, a range will be computed such that the whole bounding sphere is visible.</p>

<p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
target will be the range. The heading will be determined from the offset. If the heading cannot be
determined from the offset, the heading will be north.</p>
         * @param boundingSphere  (Required) The bounding sphere to view, in world coordinates.
         * @param offset  (Optional) The offset from the target in the local east-north-up reference frame centered at the target.
         */
        viewBoundingSphere(boundingSphere: BoundingSphere, offset?: HeadingPitchRange): void;
        /**
         * Flies the camera to a location where the current view contains the provided bounding sphere.

<p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
The heading and the pitch angles are defined in the local east-north-up reference frame.
The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
zero, a range will be computed such that the whole bounding sphere is visible.</p>

<p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the
target will be the range. The heading will be aligned to local north.</p>
         * @param boundingSphere  (Required) The bounding sphere to view, in world coordinates.
         * @param options  (Optional) Object with the following properties:
         */
        flyToBoundingSphere(boundingSphere: BoundingSphere, options?: Camera.ICameraFlyToBoundingSphereOptions): void;
        /**
         * Computes the approximate visible rectangle on the ellipsoid.
         * @param ellipsoid  (Optional) The ellipsoid that you want to know the visible region.
         * @param result  (Optional) The rectangle in which to store the result
         */
        computeViewRectangle(ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle;
    }
    /**
     * Aggregates input events. For example, suppose the following inputs are received between frames:
left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into
one event with a start and end position of the mouse.
     */
    class CameraEventAggregator {
        /**
         * Aggregates input events. For example, suppose the following inputs are received between frames:
left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into
one event with a start and end position of the mouse.
         * @param element  (Optional) The element to handle events for.
         */
        constructor(element?: HTMLCanvasElement);
        /**
         * Gets the current mouse position.
         */
        currentMousePosition: Cartesian2;
        /**
         * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.
         */
        anyButtonDown: Boolean;
        /**
         * Gets if a mouse button down or touch has started and has been moved.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        isMoving(type: number, modifier?: number): Boolean;
        /**
         * Gets the aggregated start and end position of the current event.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        getMovement(type: number, modifier?: number): any;
        /**
         * Gets the start and end position of the last move event (not the aggregated event).
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        getLastMovement(type: number, modifier?: number): any;
        /**
         * Gets whether the mouse button is down or a touch has started.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        isButtonDown(type: number, modifier?: number): Boolean;
        /**
         * Gets the mouse position that started the aggregation.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        getStartMousePosition(type: number, modifier?: number): Cartesian2;
        /**
         * Gets the time the button was pressed or the touch was started.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        getButtonPressTime(type: number, modifier?: number): Date;
        /**
         * Gets the time the button was released or the touch was ended.
         * @param type  (Required) The camera event type.
         * @param modifier  (Optional) The keyboard modifier.
         */
        getButtonReleaseTime(type: number, modifier?: number): Date;
        /**
         * Signals that all of the events have been handled and the aggregator should be reset to handle new events.
         */
        reset(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Removes mouse listeners held by this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * The credit display is responsible for displaying credits on screen.
     */
    class CreditDisplay {
        /**
         * The credit display is responsible for displaying credits on screen.
         * @param container  (Required) The HTML element where credits will be displayed
         * @param delimiter  (Optional) The string to separate text credits
         */
        constructor(container: HTMLElement, delimiter?: string);
        /**
         * The HTML element where credits will be displayed.
         */
        container: HTMLElement;
        /**
         * Adds a credit to the list of current credits to be displayed in the credit container
         * @param credit  (Required) The credit to display
         */
        addCredit(credit: Credit): void;
        /**
         * Adds credits that will persist until they are removed
         * @param credit  (Required) The credit to added to defaults
         */
        addDefaultCredit(credit: Credit): void;
        /**
         * Removes a default credit
         * @param credit  (Required) The credit to be removed from defaults
         */
        removeDefaultCredit(credit: Credit): void;
        /**
         * Resets the credit display to a beginning of frame state, clearing out current credits.
         * @param credit  (Required) The credit to display
         */
        beginFrame(credit: Credit): void;
        /**
         * Sets the credit display to the end of frame state, displaying current credits in the credit container
         * @param credit  (Required) The credit to display
         */
        endFrame(credit: Credit): void;
        /**
         * Destroys the resources held by this object.  Destroying an object allows for deterministic
release of resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
         */
        isDestroyed(): Boolean;
    }
    /**
     * The culling volume defined by planes.
     */
    class CullingVolume {
        /**
         * The culling volume defined by planes.
         * @param planes  (Optional) An array of clipping planes.
         */
        constructor(planes?: Cartesian4[]);
        /**
         * Each plane is represented by a Cartesian4 object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin.
         */
        planes: Cartesian4[];
        /**
         * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
The planes are aligned to the x, y, and z axes in world coordinates.
         * @param boundingSphere  (Required) The bounding sphere used to create the culling volume.
         * @param result  (Optional) The object onto which to store the result.
         */
        static fromBoundingSphere(boundingSphere: BoundingSphere, result?: CullingVolume): CullingVolume;
        /**
         * Determines whether a bounding volume intersects the culling volume.
         * @param boundingVolume  (Required) The bounding volume whose intersection with the culling volume is to be tested.
         */
        computeVisibility(boundingVolume: any): number;
    }
    /**
     * Visualizes a vertex attribute by displaying it as a color for debugging.
<p>
Components for well-known unit-length vectors, i.e., <code>normal</code>,
<code>binormal</code>, and <code>tangent</code>, are scaled and biased
from [-1.0, 1.0] to (-1.0, 1.0).
</p>
     */
    class DebugAppearance {
        /**
         * Visualizes a vertex attribute by displaying it as a color for debugging.
<p>
Components for well-known unit-length vectors, i.e., <code>normal</code>,
<code>binormal</code>, and <code>tangent</code>, are scaled and biased
from [-1.0, 1.0] to (-1.0, 1.0).
</p>
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IDebugAppearanceOptions);
        /**
         * This property is part of the {@link Appearance} interface, but is not
used by {@link DebugAppearance} since a fully custom fragment shader is used.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.  The full fragment shader
source is built procedurally taking into account the {@link DebugAppearance#material}.
Use {@link DebugAppearance#getFragmentShaderSource} to get the full source.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed.
         */
        closed: Boolean;
        /**
         * The name of the attribute being visualized.
         */
        attributeName: string;
        /**
         * The GLSL datatype of the attribute being visualized.
         */
        glslDatatype: string;
        /**
         * Returns the full GLSL fragment shader source, which for {@link DebugAppearance} is just
{@link DebugAppearance#fragmentShaderSource}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link DebugAppearance#translucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * Draws the outline of the camera's view frustum.
     */
    class DebugCameraPrimitive {
        /**
         * Draws the outline of the camera's view frustum.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IDebugCameraPrimitiveOptions);
        /**
         * Determines if this primitive will be shown.
         */
        show: Boolean;
        /**
         * User-defined object returned when the primitive is picked.
         */
        id: any;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<p>
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
</p>
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<p>
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
</p>
         */
        destroy(): void;
    }
    /**
     * Draws the axes of a reference frame defined by a matrix that transforms to world
coordinates, i.e., Earth's WGS84 coordinates.  The most prominent example is
a primitives <code>modelMatrix</code>.
<p>
The X axis is red; Y is green; and Z is blue.
</p>
<p>
This is for debugging only; it is not optimized for production use.
</p>
     */
    class DebugModelMatrixPrimitive {
        /**
         * Draws the axes of a reference frame defined by a matrix that transforms to world
coordinates, i.e., Earth's WGS84 coordinates.  The most prominent example is
a primitives <code>modelMatrix</code>.
<p>
The X axis is red; Y is green; and Z is blue.
</p>
<p>
This is for debugging only; it is not optimized for production use.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IDebugModelMatrixPrimitiveOptions);
        /**
         * The length of the axes in meters.
         */
        length: number;
        /**
         * The width of the axes in pixels.
         */
        width: number;
        /**
         * Determines if this primitive will be shown.
         */
        show: Boolean;
        /**
         * The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
         */
        modelMatrix: Matrix4;
        /**
         * User-defined object returned when the primitive is picked.
         */
        id: any;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<p>
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
</p>
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<p>
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
</p>
         */
        destroy(): void;
    }
    /**
     * A policy for discarding tile images that match a known image containing a
"missing" image.
     */
    class DiscardMissingTileImagePolicy {
        /**
         * A policy for discarding tile images that match a known image containing a
"missing" image.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IDiscardMissingTileImagePolicyOptions);
        /**
         * Determines if the discard policy is ready to process images.
         */
        isReady(): Boolean;
        /**
         * Given a tile image, decide whether to discard that image.
         * @param image  (Required) An image to test.
         */
        shouldDiscardImage(image: HTMLImageElement): Boolean;
    }
    /**
     * An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}
and {@link RectangleGeometry}, which supports all materials like {@link MaterialAppearance}
with {@link MaterialAppearance.MaterialSupport.ALL}.  However, this appearance requires
fewer vertex attributes since the fragment shader can procedurally compute <code>normal</code>,
<code>binormal</code>, and <code>tangent</code>.
     */
    class EllipsoidSurfaceAppearance {
        /**
         * An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}
and {@link RectangleGeometry}, which supports all materials like {@link MaterialAppearance}
with {@link MaterialAppearance.MaterialSupport.ALL}.  However, this appearance requires
fewer vertex attributes since the fragment shader can procedurally compute <code>normal</code>,
<code>binormal</code>, and <code>tangent</code>.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IEllipsoidSurfaceAppearanceOptions);
        /**
         * The material used to determine the fragment color.  Unlike other {@link EllipsoidSurfaceAppearance}
properties, this is not read-only, so an appearance's material can change on the fly.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.  The full fragment shader
source is built procedurally taking into account {@link EllipsoidSurfaceAppearance#material},
{@link EllipsoidSurfaceAppearance#flat}, and {@link EllipsoidSurfaceAppearance#faceForward}.
Use {@link EllipsoidSurfaceAppearance#getFragmentShaderSource} to get the full source.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
<p>
The render state can be explicitly defined when constructing a {@link EllipsoidSurfaceAppearance}
instance, or it is set implicitly via {@link EllipsoidSurfaceAppearance#translucent}
and {@link EllipsoidSurfaceAppearance#aboveGround}.
</p>
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed so
{@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
If the viewer enters the geometry, it will not be visible.
         */
        closed: Boolean;
        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
A geometry can have more vertex attributes and still be compatible - at a
potential performance cost - but it can't have less.
         */
        vertexFormat: VertexFormat;
        /**
         * When <code>true</code>, flat shading is used in the fragment shader,
which means lighting is not taking into account.
         */
        flat: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal
as needed to ensure that the normal faces the viewer to avoid
dark spots.  This is useful when both sides of a geometry should be
shaded like {@link WallGeometry}.
         */
        faceForward: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to be on the ellipsoid's
surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState}
has backface culling enabled.
         */
        aboveGround: Boolean;
        /**
         * Procedurally creates the full GLSL fragment shader source.  For {@link EllipsoidSurfaceAppearance},
this is derived from {@link EllipsoidSurfaceAppearance#fragmentShaderSource}, {@link EllipsoidSurfaceAppearance#flat},
and {@link EllipsoidSurfaceAppearance#faceForward}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link EllipsoidSurfaceAppearance#translucent} and {@link Material#isTranslucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
performance improvements by rendering less geometry and dispatching less terrain requests.
     */
    class Fog {
        /**
         * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
performance improvements by rendering less geometry and dispatching less terrain requests.
         */
        constructor();
        /**
         * <code>true</code> if fog is enabled, <code>false</code> otherwise.
         */
        enabled: Boolean;
        /**
         * A scalar that determines the density of the fog. Terrain that is in full fog are culled.
The density of the fog increases as this number approaches 1.0 and becomes less dense as it approaches zero.
The more dense the fog is, the more aggressively the terrain is culled. For example, if the camera is a height of
1000.0m above the ellipsoid, increasing the value to 3.0e-3 will cause many tiles close to the viewer be culled.
Decreasing the value will push the fog further from the viewer, but decrease performance as more of the terrain is rendered.
         */
        density: number;
        /**
         * A factor used to increase the screen space error of terrain tiles when they are partially in fog. The effect is to reduce
the number of terrain tiles requested for rendering. If set to zero, the feature will be disabled. If the value is increased
for mountainous regions, less tiles will need to be requested, but the terrain meshes near the horizon may be a noticeably
lower resolution. If the value is increased in a relatively flat area, there will be little noticeable change on the horizon.
         */
        screenSpaceErrorFactor: number;
    }
    /**
     * Monitors the frame rate (frames per second) in a {@link Scene} and raises an event if the frame rate is
lower than a threshold.  Later, if the frame rate returns to the required level, a separate event is raised.
To avoid creating multiple FrameRateMonitors for a single {@link Scene}, use {@link FrameRateMonitor.fromScene}
instead of constructing an instance explicitly.
     */
    class FrameRateMonitor {
        /**
         * Monitors the frame rate (frames per second) in a {@link Scene} and raises an event if the frame rate is
lower than a threshold.  Later, if the frame rate returns to the required level, a separate event is raised.
To avoid creating multiple FrameRateMonitors for a single {@link Scene}, use {@link FrameRateMonitor.fromScene}
instead of constructing an instance explicitly.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IFrameRateMonitorOptions);
        /**
         * Gets or sets the length of the sliding window over which to compute the average frame rate, in seconds.
         */
        samplingWindow: number;
        /**
         * Gets or sets the length of time to wait at startup and each time the page becomes visible (i.e. when the user
switches back to the tab) before starting to measure performance, in seconds.
         */
        quietPeriod: number;
        /**
         * Gets or sets the length of the warmup period, in seconds.  During the warmup period, a separate
(usually lower) frame rate is required.
         */
        warmupPeriod: number;
        /**
         * Gets or sets the minimum frames-per-second that are required for acceptable performance during
the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> during the <code>warmupPeriod</code>, the
<code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
         */
        minimumFrameRateDuringWarmup: number;
        /**
         * Gets or sets the minimum frames-per-second that are required for acceptable performance after
the end of the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> after the <code>warmupPeriod</code>, the
<code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
         */
        minimumFrameRateAfterWarmup: number;
        /**
         * The default frame rate monitoring settings.  These settings are used when {@link FrameRateMonitor.fromScene}
needs to create a new frame rate monitor, and for any settings that are not passed to the
{@link FrameRateMonitor} constructor.
         */
        defaultSettings: any;
        /**
         * Gets the {@link FrameRateMonitor} for a given scene.  If the scene does not yet have
a {@link FrameRateMonitor}, one is created with the {@link FrameRateMonitor.defaultSettings}.
         * @param scene  (Required) The scene for which to get the {@link FrameRateMonitor}.
         */
        static fromScene(scene: Scene): FrameRateMonitor;
        /**
         * Gets the {@link Scene} instance for which to monitor performance.
         */
        scene: Scene;
        /**
         * Gets the event that is raised when a low frame rate is detected.  The function will be passed
the {@link Scene} instance as its first parameter and the average number of frames per second
over the sampling window as its second parameter.
         */
        lowFrameRate: Event;
        /**
         * Gets the event that is raised when the frame rate returns to a normal level after having been low.
The function will be passed the {@link Scene} instance as its first parameter and the average
number of frames per second over the sampling window as its second parameter.
         */
        nominalFrameRate: Event;
        /**
         * Gets the most recently computed average frames-per-second over the last <code>samplingWindow</code>.
This property may be undefined if the frame rate has not been computed.
         */
        lastFramesPerSecond: number;
        /**
         * Pauses monitoring of the frame rate.  To resume monitoring, {@link FrameRateMonitor#unpause}
must be called once for each time this function is called.
         */
        pause(): void;
        /**
         * Resumes monitoring of the frame rate.  If {@link FrameRateMonitor#pause} was called
multiple times, this function must be called the same number of times in order to
actually resume monitoring.
         */
        unpause(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Unsubscribes this instance from all events it is listening to.
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * State information about the current frame.  An instance of this class
is provided to update functions.
     */
    class FrameState {
        /**
         * State information about the current frame.  An instance of this class
is provided to update functions.
         * @param creditDisplay  (Required) Handles adding and removing credits from an HTML element
         */
        constructor(creditDisplay: CreditDisplay);
        /**
         * The rendering context.
         */
        context: Context;
        /**
         * An array of rendering commands.
         */
        commandList: DrawCommand[];
        /**
         * An array of shadow maps.
         */
        shadowMaps: ShadowMap[];
        /**
         * The current mode of the scene.
         */
        mode: number;
        /**
         * The current morph transition time between 2D/Columbus View and 3D,
with 0.0 being 2D or Columbus View and 1.0 being 3D.
         */
        morphTime: number;
        /**
         * The current frame number.
         */
        frameNumber: number;
        /**
         * The scene's current time.
         */
        time: JulianDate;
        /**
         * The map projection to use in 2D and Columbus View modes.
         */
        mapProjection: MapProjection;
        /**
         * The current camera.
         */
        camera: Camera;
        /**
         * The culling volume.
         */
        cullingVolume: CullingVolume;
        /**
         * The current occluder.
         */
        occluder: Occluder;
        /**
         * The credit display.
         */
        creditDisplay: CreditDisplay;
        /**
         * An array of functions to be called at the end of the frame.  This array
will be cleared after each frame.
<p>
This allows queueing up events in <code>update</code> functions and
firing them at a time when the subscribers are free to change the
scene state, e.g., manipulate the camera, instead of firing events
directly in <code>update</code> functions.
</p>
         */
        afterRender: FrameState.AfterRenderCallback[];
        /**
         * Gets whether or not to optimized for 3D only.
         */
        scene3DOnly: Boolean;
        /**
         * A scalar used to exaggerate the terrain.
         */
        terrainExaggeration: number;
    }
    /**
     * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.
     */
    class GetFeatureInfoFormat {
        /**
         * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.
         * @param type  (Required) The type of response to expect from a GetFeatureInfo request.  Valid
       values are 'json', 'xml', 'html', or 'text'.
         * @param format  (Optional) The info format to request from the WMS server.  This is usually a
       MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'
       using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.
         * @param callback  (Optional) A function to invoke with the GetFeatureInfo response from the WMS server
       in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,
       a default function for the type of response is used.
         */
        constructor(type: string, format?: string, callback?: Function);
    }
    /**
     * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})
and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.
     */
    class Globe {
        /**
         * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})
and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.
         * @param ellipsoid  (Optional) Determines the size and shape of the
globe.
         */
        constructor(ellipsoid?: Ellipsoid);
        /**
         * Determines if the globe will be shown.
         */
        show: Boolean;
        /**
         * The normal map to use for rendering waves in the ocean.  Setting this property will
only have an effect if the configured terrain provider includes a water mask.
         */
        oceanNormalMapUrl: string;
        /**
         * The maximum screen-space error used to drive level-of-detail refinement.  Higher
values will provide better performance but lower visual quality.
         */
        maximumScreenSpaceError: number;
        /**
         * The size of the terrain tile cache, expressed as a number of tiles.  Any additional
tiles beyond this number will be freed, as long as they aren't needed for rendering
this frame.  A larger number will consume more memory but will show detail faster
when, for example, zooming out and then back in.
         */
        tileCacheSize: number;
        /**
         * Enable lighting the globe with the sun as a light source.
         */
        enableLighting: Boolean;
        /**
         * The distance where everything becomes lit. This only takes effect
when <code>enableLighting</code> is <code>true</code>.
         */
        lightingFadeOutDistance: number;
        /**
         * The distance where lighting resumes. This only takes effect
when <code>enableLighting</code> is <code>true</code>.
         */
        lightingFadeInDistance: number;
        /**
         * True if an animated wave effect should be shown in areas of the globe
covered by water; otherwise, false.  This property is ignored if the
<code>terrainProvider</code> does not provide a water mask.
         */
        showWaterEffect: Boolean;
        /**
         * True if primitives such as billboards, polylines, labels, etc. should be depth-tested
against the terrain surface, or false if such primitives should always be drawn on top
of terrain unless they're on the opposite side of the globe.  The disadvantage of depth
testing primitives against terrain is that slight numerical noise or terrain level-of-detail
switched can sometimes make a primitive that should be on the surface disappear underneath it.
         */
        depthTestAgainstTerrain: Boolean;
        /**
         * Determines whether the globe casts or receives shadows from each light source. Setting the globe
to cast shadows may impact performance since the terrain is rendered again from the light's perspective.
Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.
         */
        shadows: number;
        /**
         * Gets an ellipsoid describing the shape of this globe.
         */
        ellipsoid: Ellipsoid;
        /**
         * Gets the collection of image layers that will be rendered on this globe.
         */
        imageryLayers: ImageryLayerCollection;
        /**
         * Gets or sets the color of the globe when no imagery is available.
         */
        baseColor: number;
        /**
         * The terrain provider providing surface geometry for this globe.
         */
        terrainProvider: TerrainProvider;
        /**
         * Gets an event that's raised when the terrain provider is changed
         */
        terrainProviderChanged: Event;
        /**
         * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,
all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.
         */
        tileLoadProgressEvent: Event;
        /**
         * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.
         * @param ray  (Required) The ray to test for intersection.
         * @param scene  (Required) The scene.
         * @param result  (Optional) The object onto which to store the result.
         */
        pick(ray: Ray, scene: Scene, result?: Cartesian3): Cartesian3;
        /**
         * Get the height of the surface at a given cartographic.
         * @param cartographic  (Required) The cartographic for which to find the height.
         */
        getHeight(cartographic: Cartographic): number;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Provides tiled imagery using the Google Earth Imagery API.

Notes: This imagery provider does not work with the public Google Earth servers. It works with the
       Google Earth Enterprise Server.

       By default the Google Earth Enterprise server does not set the
       {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing} headers. You can either
       use a proxy server which adds these headers, or in the /opt/google/gehttpd/conf/gehttpd.conf
       and add the 'Header set Access-Control-Allow-Origin "*"' option to the '&lt;Directory /&gt;' and
       '&lt;Directory "/opt/google/gehttpd/htdocs"&gt;' directives.
     */
    class GoogleEarthImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery using the Google Earth Imagery API.

Notes: This imagery provider does not work with the public Google Earth servers. It works with the
       Google Earth Enterprise Server.

       By default the Google Earth Enterprise server does not set the
       {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing} headers. You can either
       use a proxy server which adds these headers, or in the /opt/google/gehttpd/conf/gehttpd.conf
       and add the 'Header set Access-Control-Allow-Origin "*"' option to the '&lt;Directory /&gt;' and
       '&lt;Directory "/opt/google/gehttpd/htdocs"&gt;' directives.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGoogleEarthImageryProviderOptions);
        /**
         * The default {@link ImageryLayer#gamma} to use for imagery layers created for this provider.
By default, this is set to 1.9.  Changing this value after creating an {@link ImageryLayer} for this provider will have
no effect.  Instead, set the layer's {@link ImageryLayer#gamma} property.
         */
        defaultGamma: number;
        /**
         * Gets the URL of the Google Earth MapServer.
         */
        url: string;
        /**
         * Gets the url path of the data on the Google Earth server.
         */
        path: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the imagery channel (id) currently being used.
         */
        channel: number;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the version of the data used by this provider.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        version: number;
        /**
         * Gets the type of data that is being requested from the provider.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        requestType: string;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link GoogleEarthImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * An {@link ImageryProvider} that draws a wireframe grid on every tile with controllable background and glow.
May be useful for custom rendering effects or debugging terrain.
     */
    class GridImageryProvider extends ImageryProvider{
        /**
         * An {@link ImageryProvider} that draws a wireframe grid on every tile with controllable background and glow.
May be useful for custom rendering effects or debugging terrain.
         * @param options  (Optional) Object with the following properties:
         * @param backgroundColor  (Optional) Background fill color.
         */
        constructor(options?: IGridImageryProviderOptions, backgroundColor?: number);
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link GridImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Draws a grid of lines into a canvas.
         */
        _drawGrid(): void;
        /**
         * Render a grid into a canvas with background and glow
         */
        _createGridCanvas(): void;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link GridImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * A ground primitive represents geometry draped over the terrain in the {@link Scene}.  The geometry must be from a single {@link GeometryInstance}.
Batching multiple geometries is not yet supported.
<p>
A primitive combines the geometry instance with an {@link Appearance} that describes the full shading, including
{@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
and match most of them and add a new geometry or appearance independently of each other. Only the {@link PerInstanceColorAppearance}
is supported at this time.
</p>
<p>
Because of the cutting edge nature of this feature in WebGL, it requires the EXT_frag_depth extension, which is currently only supported in Chrome,
Firefox, and Edge. Apple support is expected in iOS 9 and MacOS Safari 9. Android support varies by hardware and IE11 will most likely never support
it. You can use webglreport.com to verify support for your hardware.
</p>
<p>
Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.
</p>
     */
    class GroundPrimitive {
        /**
         * A ground primitive represents geometry draped over the terrain in the {@link Scene}.  The geometry must be from a single {@link GeometryInstance}.
Batching multiple geometries is not yet supported.
<p>
A primitive combines the geometry instance with an {@link Appearance} that describes the full shading, including
{@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
and match most of them and add a new geometry or appearance independently of each other. Only the {@link PerInstanceColorAppearance}
is supported at this time.
</p>
<p>
Because of the cutting edge nature of this feature in WebGL, it requires the EXT_frag_depth extension, which is currently only supported in Chrome,
Firefox, and Edge. Apple support is expected in iOS 9 and MacOS Safari 9. Android support varies by hardware and IE11 will most likely never support
it. You can use webglreport.com to verify support for your hardware.
</p>
<p>
Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IGroundPrimitiveOptions);
        /**
         * The geometry instance rendered with this primitive.  This may
be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
is <code>true</code> when the primitive is constructed.
<p>
Changing this property after the primitive is rendered has no effect.
</p>
<p>
Because of the rendering technique used, all geometry instances must be the same color.
If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown
on the first attempt to render.
</p>
         */
        geometryInstances: any[]|GeometryInstance;
        /**
         * Determines if the primitive will be shown.  This affects all geometry
instances in the primitive.
         */
        show: Boolean;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the shadow volume for each geometry in the primitive. Must be <code>true</code> on
creation for the volumes to be created before the geometry is released or releaseGeometryInstances
must be <code>false</code>
</p>
         */
        debugShowShadowVolume: Boolean;
        /**
         * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
         */
        vertexCacheOptimize: Boolean;
        /**
         * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
         */
        interleave: Boolean;
        /**
         * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
         */
        releaseGeometryInstances: Boolean;
        /**
         * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
         */
        allowPicking: Boolean;
        /**
         * Determines if the geometry instances will be created and batched on a web worker.
         */
        asynchronous: Boolean;
        /**
         * When <code>true</code>, geometry vertices are compressed, which will save memory.
         */
        compressVertices: Boolean;
        /**
         * Determines if the primitive is complete and ready to render.  If this property is
true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
is called.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves when the primitive is ready to render.
         */
        readyPromise: Promise<GroundPrimitive>;
        /**
         * Determines if GroundPrimitive rendering is supported.
         * @param scene  (Required) The scene.
         */
        static isSupported(scene: Scene): Boolean;
        /**
         * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the GroundPrimitive asynchronously.
         */
        static initializeTerrainHeights(): Promise<any>;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
         * @param id  (Required) The id of the {@link GeometryInstance}.
         */
        getGeometryInstanceAttributes(id: any): any;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<p>
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
</p>
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<p>
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
</p>
         */
        destroy(): void;
    }
    /**
     * An imagery layer that displays tiled image data from a single imagery provider
on a {@link Globe}.
     */
    class ImageryLayer {
        /**
         * An imagery layer that displays tiled image data from a single imagery provider
on a {@link Globe}.
         * @param imageryProvider  (Required) The imagery provider to use.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(imageryProvider: ImageryProvider, options?: IImageryLayerOptions);
        /**
         * The alpha blending value of this layer, with 0.0 representing fully transparent and
1.0 representing fully opaque.
         */
        alpha: number;
        /**
         * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0
makes the imagery darker while greater than 1.0 makes it brighter.
         */
        brightness: number;
        /**
         * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
the contrast while greater than 1.0 increases it.
         */
        contrast: number;
        /**
         * The hue of this layer in radians. 0.0 uses the unmodified imagery color.
         */
        hue: number;
        /**
         * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
saturation while greater than 1.0 increases it.
         */
        saturation: number;
        /**
         * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
         */
        gamma: number;
        /**
         * Determines if this layer is shown.
         */
        show: Boolean;
        /**
         * Gets the imagery provider for this layer.
         */
        imageryProvider: ImageryProvider;
        /**
         * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the
{@link ImageryProvider}, only a portion of the imagery provider is shown.
         */
        rectangle: Rectangle;
        /**
         * This value is used as the default brightness for the imagery layer if one is not provided during construction
or by the imagery provider. This value does not modify the brightness of the imagery.
         */
        DEFAULT_BRIGHTNESS: number;
        /**
         * This value is used as the default contrast for the imagery layer if one is not provided during construction
or by the imagery provider. This value does not modify the contrast of the imagery.
         */
        DEFAULT_CONTRAST: number;
        /**
         * This value is used as the default hue for the imagery layer if one is not provided during construction
or by the imagery provider. This value does not modify the hue of the imagery.
         */
        DEFAULT_HUE: number;
        /**
         * This value is used as the default saturation for the imagery layer if one is not provided during construction
or by the imagery provider. This value does not modify the saturation of the imagery.
         */
        DEFAULT_SATURATION: number;
        /**
         * This value is used as the default gamma for the imagery layer if one is not provided during construction
or by the imagery provider. This value does not modify the gamma of the imagery.
         */
        DEFAULT_GAMMA: number;
        /**
         * Gets a value indicating whether this layer is the base layer in the
{@link ImageryLayerCollection}.  The base layer is the one that underlies all
others.  It is special in that it is treated as if it has global rectangle, even if
it actually does not, by stretching the texels at the edges over the entire
globe.
         */
        isBaseLayer(): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
        /**
         * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,
producing the overall bounds of imagery that can be produced by this layer.
         */
        getViewableRectangle(): Promise<Rectangle>;
    }
    /**
     * An ordered collection of imagery layers.
     */
    class ImageryLayerCollection {
        /**
         * An ordered collection of imagery layers.
         */
        constructor();
        /**
         * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that
was added and the index at which it was added.
         */
        layerAdded: Event;
        /**
         * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that
was removed and the index from which it was removed.
         */
        layerRemoved: Event;
        /**
         * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that
was moved, its new index after the move, and its old index prior to the move.
         */
        layerMoved: Event;
        /**
         * An event that is raised when a layer is shown or hidden by setting the
{@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,
the index of the layer in the collection, and a flag that is true if the layer is now
shown or false if it is now hidden.
         */
        layerShownOrHidden: Event;
        /**
         * Gets the number of layers in this collection.
         */
        length: number;
        /**
         * Adds a layer to the collection.
         * @param layer  (Required) the layer to add.
         * @param index  (Optional) the index to add the layer at.  If omitted, the layer will
                        added on top of all existing layers.
         */
        add(layer: ImageryLayer, index?: number): void;
        /**
         * Creates a new layer using the given ImageryProvider and adds it to the collection.
         * @param imageryProvider  (Required) the imagery provider to create a new layer for.
         * @param index  (Optional) the index to add the layer at.  If omitted, the layer will
                        added on top of all existing layers.
         */
        addImageryProvider(imageryProvider: ImageryProvider, index?: number): ImageryLayer;
        /**
         * Removes a layer from this collection, if present.
         * @param layer  (Required) The layer to remove.
         * @param destroy  (Optional) whether to destroy the layers in addition to removing them.
         */
        remove(layer: ImageryLayer, destroy?: Boolean): Boolean;
        /**
         * Removes all layers from this collection.
         * @param destroy  (Optional) whether to destroy the layers in addition to removing them.
         */
        removeAll(destroy?: Boolean): void;
        /**
         * Checks to see if the collection contains a given layer.
         * @param layer  (Required) the layer to check for.
         */
        contains(layer: ImageryLayer): Boolean;
        /**
         * Determines the index of a given layer in the collection.
         * @param layer  (Required) The layer to find the index of.
         */
        indexOf(layer: ImageryLayer): number;
        /**
         * Gets a layer by index from the collection.
         * @param index  (Required) the index to retrieve.
         */
        get(index: number): ImageryLayer;
        /**
         * Raises a layer up one position in the collection.
         * @param layer  (Required) the layer to move.
         */
        raise(layer: ImageryLayer): void;
        /**
         * Lowers a layer down one position in the collection.
         * @param layer  (Required) the layer to move.
         */
        lower(layer: ImageryLayer): void;
        /**
         * Raises a layer to the top of the collection.
         * @param layer  (Required) the layer to move.
         */
        raiseToTop(layer: ImageryLayer): void;
        /**
         * Lowers a layer to the bottom of the collection.
         * @param layer  (Required) the layer to move.
         */
        lowerToBottom(layer: ImageryLayer): void;
        /**
         * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery
layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected
by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.
         * @param ray  (Required) The ray to test for intersection.
         * @param scene  (Required) The scene.
         */
        pickImageryLayerFeatures(ray: Ray, scene: Scene): Promise<Array<ImageryLayerFeatureInfo>>;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this
object allows for deterministic release of WebGL resources, instead of relying on the garbage
collector.
<br /><br />
Once this object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Describes a rasterized feature, such as a point, polygon, polyline, etc., in an imagery layer.
     */
    class ImageryLayerFeatureInfo {
        /**
         * Describes a rasterized feature, such as a point, polygon, polyline, etc., in an imagery layer.
         */
        constructor();
        /**
         * Gets or sets the name of the feature.
         */
        name: string;
        /**
         * Gets or sets an HTML description of the feature.  The HTML is not trusted and should
be sanitized before display to the user.
         */
        description: string;
        /**
         * Gets or sets the position of the feature, or undefined if the position is not known.
         */
        position: Cartographic;
        /**
         * Gets or sets the raw data describing the feature.  The raw data may be in any
number of formats, such as GeoJSON, KML, etc.
         */
        data: any;
        /**
         * Gets or sets the image layer of the feature.
         */
        imageryLayer: any;
        /**
         * Configures the name of this feature by selecting an appropriate property.  The name will be obtained from
one of the following sources, in this order: 1) the property with the name 'name', 2) the property with the name 'title',
3) the first property containing the word 'name', 4) the first property containing the word 'title'.  If
the name cannot be obtained from any of these sources, the existing name will be left unchanged.
         * @param properties  (Required) An object literal containing the properties of the feature.
         */
        configureNameFromProperties(properties: any): void;
        /**
         * Configures the description of this feature by creating an HTML table of properties and their values.
         * @param properties  (Required) An object literal containing the properties of the feature.
         */
        configureDescriptionFromProperties(properties: any): void;
    }
    /**
     * Provides imagery to be displayed on the surface of an ellipsoid.  This type describes an
interface and is not intended to be instantiated directly.
     */
    class ImageryProvider {
        /**
         * The default alpha blending value of this provider, with 0.0 representing fully transparent and
1.0 representing fully opaque.
         */
        defaultAlpha?: number;
        /**
         * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
makes the imagery darker while greater than 1.0 makes it brighter.
         */
        defaultBrightness?: number;
        /**
         * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
the contrast while greater than 1.0 increases it.
         */
        defaultContrast?: number;
        /**
         * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
         */
        defaultHue?: number;
        /**
         * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
saturation while greater than 1.0 increases it.
         */
        defaultSaturation?: number;
        /**
         * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
         */
        defaultGamma?: number;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the width of each tile, in pixels.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link ImageryProvider#ready} returns true. Generally,
a minimum level should only be used when the rectangle of the imagery is small
enough that the number of tiles at the minimum level is small.  An imagery
provider with more than a few tiles at the minimum level will lead to
rendering problems.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by the provider.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery. This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Asynchronously determines what features, if any, are located at a given longitude and latitude within
a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
This function is optional, so it may not exist on all ImageryProviders.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
        /**
         * Loads an image from a given URL.  If the server referenced by the URL already has
too many requests pending, this function will instead return undefined, indicating
that the request should be retried later.
         * @param url  (Required) The URL of the image.
         */
        static loadImage(url: string): Promise<HTMLImageElement|HTMLCanvasElement>;
    }
    /**
     * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor
should not be used directly, instead create labels by calling {@link LabelCollection#add}.
     */
    class Label {
        /**
         * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor
should not be used directly, instead create labels by calling {@link LabelCollection#add}.
         */
        constructor();
        /**
         * Determines if this label will be shown.  Use this to hide or show a label, instead
of removing it and re-adding it to the collection.
         */
        show: Boolean;
        /**
         * Gets or sets the Cartesian position of this label.
         */
        position: Cartesian3;
        /**
         * Gets or sets the height reference of this billboard.
         */
        heightReference: number;
        /**
         * Gets or sets the text of this label.
         */
        text: string;
        /**
         * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
         */
        font: string;
        /**
         * Gets or sets the fill color of this label.
         */
        fillColor: number;
        /**
         * Gets or sets the outline color of this label.
         */
        outlineColor: number;
        /**
         * Gets or sets the outline width of this label.
         */
        outlineWidth: number;
        /**
         * Gets or sets the style of this label.
         */
        style: number;
        /**
         * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
to align multiple labels and billboards at the same position, e.g., an image and text.  The
screen space origin is the top, left corner of the canvas; <code>x</code> increases from
left to right, and <code>y</code> increases from top to bottom.
<br /><br />
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><code>default</code><br/><img src='images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
<td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
</tr></table>
The label's origin is indicated by the yellow point.
</div>
         */
        pixelOffset: Cartesian2;
        /**
         * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
translucencyByDistance will be disabled.
         */
        translucencyByDistance: NearFarScalar;
        /**
         * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
pixelOffsetScaleByDistance will be disabled.
         */
        pixelOffsetScaleByDistance: NearFarScalar;
        /**
         * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
<code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
which is typically meters.
<br /><br />
An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
arrange a label above its corresponding 3D model.
<br /><br />
Below, the label is positioned at the center of the Earth but an eye offset makes it always
appear on top of the Earth regardless of the viewer's or Earth's orientation.
<br /><br />
<div align='center'>
<table border='0' cellpadding='5'><tr>
<td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
<td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
</tr></table>
<code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
</div>
         */
        eyeOffset: Cartesian3;
        /**
         * Gets or sets the horizontal origin of this label, which determines if the label is drawn
to the left, center, or right of its position.
<br /><br />
<div align='center'>
<img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
</div>
         */
        horizontalOrigin: number;
        /**
         * Gets or sets the vertical origin of this label, which determines if the label is
to the above, below, or at the center of its position.
<br /><br />
<div align='center'>
<img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
</div>
         */
        verticalOrigin: number;
        /**
         * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
A scale of <code>1.0</code> does not change the size of the label; a scale greater than
<code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
the label.
<br /><br />
Applying a large scale value may pixelate the label.  To make text larger without pixelation,
use a larger font size when calling {@link Label#font} instead.
<br /><br />
<div align='center'>
<img src='images/Label.setScale.png' width='400' height='300' /><br/>
From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
and <code>2.0</code>.
</div>
         */
        scale: number;
        /**
         * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
         */
        distanceDisplayCondition: DistanceDisplayCondition;
        /**
         * Gets or sets the user-defined object returned when the label is picked.
         */
        id: any;
        /**
         * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
left to right, and <code>y</code> increases from top to bottom.
         * @param scene  (Required) The scene the label is in.
         * @param result  (Optional) The object onto which to store the result.
         */
        computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
        /**
         * Determines if this label equals another label.  Labels are equal if all their properties
are equal.  Labels in different collections can be equal.
         * @param other  (Required) The label to compare for equality.
         */
        equals(other: Label): Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
    }
    /**
     * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
Each label can have a different font, color, scale, etc.
<br /><br />
<div align='center'>
<img src='images/Label.png' width='400' height='300' /><br />
Example labels
</div>
<br /><br />
Labels are added and removed from the collection using {@link LabelCollection#add}
and {@link LabelCollection#remove}.
     */
    class LabelCollection {
        /**
         * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
Each label can have a different font, color, scale, etc.
<br /><br />
<div align='center'>
<img src='images/Label.png' width='400' height='300' /><br />
Example labels
</div>
<br /><br />
Labels are added and removed from the collection using {@link LabelCollection#add}
and {@link LabelCollection#remove}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ILabelCollectionOptions);
        /**
         * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * Returns the number of labels in this collection.  This is commonly used with
{@link LabelCollection#get} to iterate over all the labels
in the collection.
         */
        length: number;
        /**
         * Creates and adds a label with the specified initial properties to the collection.
The added label is returned so it can be modified or removed from the collection later.
         * @param options  (Optional) A template describing the label's properties as shown in Example 1.
         */
        add(options?: any): Label;
        /**
         * Removes a label from the collection.  Once removed, a label is no longer usable.
         * @param label  (Required) The label to remove.
         */
        remove(label: Label): Boolean;
        /**
         * Removes all labels from the collection.
         */
        removeAll(): void;
        /**
         * Check whether this collection contains a given label.
         * @param label  (Required) The label to check for.
         */
        contains(label: Label): Boolean;
        /**
         * Returns the label in the collection at the specified index.  Indices are zero-based
and increase as labels are added.  Removing a label shifts all labels after
it to the left, changing their indices.  This function is commonly used with
{@link LabelCollection#length} to iterate over all the labels
in the collection.
         * @param index  (Required) The zero-based index of the billboard.
         */
        get(index: number): Label;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Provides tiled imagery hosted by Mapbox.
     */
    class MapboxImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery hosted by Mapbox.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IMapboxImageryProviderOptions);
        /**
         * Gets the URL of the Mapbox server.
         */
        url: string;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the width of each tile, in pixels.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true. Generally,
a minimum level should only be used when the rectangle of the imagery is small
enough that the number of tiles at the minimum level is small.  An imagery
provider with more than a few tiles at the minimum level will lead to
rendering problems.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by the provider.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery. This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link MapboxImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Asynchronously determines what features, if any, are located at a given longitude and latitude within
a tile.  This function should not be called before {@link MapboxImageryProvider#ready} returns true.
This function is optional, so it may not exist on all ImageryProviders.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * A Material defines surface appearance through a combination of diffuse, specular,
normal, emission, and alpha components. These values are specified using a
JSON schema called Fabric which gets parsed and assembled into glsl shader code
behind-the-scenes. Check out the {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|wiki page}
for more details on Fabric.
<br /><br />
<style type="text/css">
 #materialDescriptions code {
     font-weight: normal;
     font-family: Consolas, 'Lucida Console', Monaco, monospace;
     color: #A35A00;
 }
 #materialDescriptions ul, #materialDescriptions ul ul {
     list-style-type: none;
 }
 #materialDescriptions ul ul {
     margin-bottom: 10px;
 }
 #materialDescriptions ul ul li {
     font-weight: normal;
     color: #000000;
     text-indent: -2em;
     margin-left: 2em;
 }
 #materialDescriptions ul li {
     font-weight: bold;
     color: #0053CF;
 }
</style>

Base material types and their uniforms:
<div id='materialDescriptions'>
<ul>
 <li>Color</li>
 <ul>
     <li><code>color</code>:  rgba color object.</li>
 </ul>
 <li>Image</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>DiffuseMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>AlphaMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>SpecularMap</li>
 <ul>
     <li><code>image</code>: path to image.</li>
     <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>EmissionMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>BumpMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 </ul>
 <li>NormalMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 </ul>
 <li>Grid</li>
 <ul>
     <li><code>color</code>:  rgba color object for the whole material.</li>
     <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>
     <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
     <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>
     <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>
 </ul>
 <li>Stripe</li>
 <ul>
     <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
     <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>
     <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>
     <li><code>offset</code>:  number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>
     <li><code>repeat</code>:  number that controls the total number of stripes, half light and half dark.</li>
 </ul>
 <li>Checkerboard</li>
 <ul>
     <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
     <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 </ul>
 <li>Dot</li>
 <ul>
     <li><code>lightColor</code>:  rgba color object for the dot color.</li>
     <li><code>darkColor</code>:  rgba color object for the background color.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
 </ul>
 <li>Water</li>
 <ul>
     <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
     <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
     <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
     <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     <li><code>frequency</code>:  number that controls the number of waves.</li>
     <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     <li><code>animationSpeed</code>:  number that controls the animations speed of the water.</li>
     <li><code>amplitude</code>:  number that controls the amplitude of water waves.</li>
     <li><code>specularIntensity</code>:  number that controls the intensity of specular reflections.</li>
 </ul>
 <li>RimLighting</li>
 <ul>
     <li><code>color</code>:  diffuse color and alpha.</li>
     <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>
     <li><code>width</code>:  number that determines the rim's width.</li>
 </ul>
 <li>Fade</li>
 <ul>
     <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>
     <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>
     <li><code>maximumDistance</code>: number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>
     <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>
     <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>
     <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>
 </ul>
 <li>PolylineArrow</li>
 <ul>
     <li><code>color</code>: diffuse color and alpha.</li>
 </ul>
 <li>PolylineGlow</li>
 <ul>
     <li><code>color</code>: color and maximum alpha for the glow on the line.</li>
     <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>
 </ul>
 <li>PolylineOutline</li>
 <ul>
     <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>
     <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>
     <li><code>outlineWidth</code>: width of the outline in pixels.</li>
 </ul>
</ul>
</div>
     */
    class Material {
        /**
         * A Material defines surface appearance through a combination of diffuse, specular,
normal, emission, and alpha components. These values are specified using a
JSON schema called Fabric which gets parsed and assembled into glsl shader code
behind-the-scenes. Check out the {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|wiki page}
for more details on Fabric.
<br /><br />
<style type="text/css">
 #materialDescriptions code {
     font-weight: normal;
     font-family: Consolas, 'Lucida Console', Monaco, monospace;
     color: #A35A00;
 }
 #materialDescriptions ul, #materialDescriptions ul ul {
     list-style-type: none;
 }
 #materialDescriptions ul ul {
     margin-bottom: 10px;
 }
 #materialDescriptions ul ul li {
     font-weight: normal;
     color: #000000;
     text-indent: -2em;
     margin-left: 2em;
 }
 #materialDescriptions ul li {
     font-weight: bold;
     color: #0053CF;
 }
</style>

Base material types and their uniforms:
<div id='materialDescriptions'>
<ul>
 <li>Color</li>
 <ul>
     <li><code>color</code>:  rgba color object.</li>
 </ul>
 <li>Image</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>DiffuseMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>AlphaMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>SpecularMap</li>
 <ul>
     <li><code>image</code>: path to image.</li>
     <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>EmissionMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 </ul>
 <li>BumpMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 </ul>
 <li>NormalMap</li>
 <ul>
     <li><code>image</code>:  path to image.</li>
     <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
     <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 </ul>
 <li>Grid</li>
 <ul>
     <li><code>color</code>:  rgba color object for the whole material.</li>
     <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>
     <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
     <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>
     <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>
 </ul>
 <li>Stripe</li>
 <ul>
     <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
     <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>
     <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>
     <li><code>offset</code>:  number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>
     <li><code>repeat</code>:  number that controls the total number of stripes, half light and half dark.</li>
 </ul>
 <li>Checkerboard</li>
 <ul>
     <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
     <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 </ul>
 <li>Dot</li>
 <ul>
     <li><code>lightColor</code>:  rgba color object for the dot color.</li>
     <li><code>darkColor</code>:  rgba color object for the background color.</li>
     <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
 </ul>
 <li>Water</li>
 <ul>
     <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
     <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
     <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
     <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     <li><code>frequency</code>:  number that controls the number of waves.</li>
     <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
     <li><code>animationSpeed</code>:  number that controls the animations speed of the water.</li>
     <li><code>amplitude</code>:  number that controls the amplitude of water waves.</li>
     <li><code>specularIntensity</code>:  number that controls the intensity of specular reflections.</li>
 </ul>
 <li>RimLighting</li>
 <ul>
     <li><code>color</code>:  diffuse color and alpha.</li>
     <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>
     <li><code>width</code>:  number that determines the rim's width.</li>
 </ul>
 <li>Fade</li>
 <ul>
     <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>
     <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>
     <li><code>maximumDistance</code>: number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>
     <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>
     <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>
     <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>
 </ul>
 <li>PolylineArrow</li>
 <ul>
     <li><code>color</code>: diffuse color and alpha.</li>
 </ul>
 <li>PolylineGlow</li>
 <ul>
     <li><code>color</code>: color and maximum alpha for the glow on the line.</li>
     <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>
 </ul>
 <li>PolylineOutline</li>
 <ul>
     <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>
     <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>
     <li><code>outlineWidth</code>: width of the outline in pixels.</li>
 </ul>
</ul>
</div>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IMaterialOptions);
        /**
         * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
         */
        type: string;
        /**
         * The glsl shader source for this material.
         */
        shaderSource: string;
        /**
         * Maps sub-material names to Material objects.
         */
        materials: any;
        /**
         * Maps uniform names to their values.
         */
        uniforms: any;
        /**
         * When <code>true</code> or a function that returns <code>true</code>,
the geometry is expected to appear translucent.
         */
        translucent: Boolean|Function;
        /**
         * Creates a new material using an existing material type.
<br /><br />
Shorthand for: new Material({fabric : {type : type}});
         * @param type  (Required) The base material type.
         * @param uniforms  (Optional) Overrides for the default uniforms.
         */
        static fromType(type: string, uniforms?: any): Material;
        /**
         * Gets whether or not this material is translucent.
         */
        isTranslucent(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
        /**
         * Gets or sets the default texture uniform value.
         */
        DefaultImageId: string;
        /**
         * Gets or sets the default cube map texture uniform value.
         */
        DefaultCubeMapId: string;
        /**
         * Gets the name of the color material.
         */
        ColorType: string;
        /**
         * Gets the name of the image material.
         */
        ImageType: string;
        /**
         * Gets the name of the diffuce map material.
         */
        DiffuseMapType: string;
        /**
         * Gets the name of the alpha map material.
         */
        AlphaMapType: string;
        /**
         * Gets the name of the specular map material.
         */
        SpecularMapType: string;
        /**
         * Gets the name of the emmision map material.
         */
        EmissionMapType: string;
        /**
         * Gets the name of the bump map material.
         */
        BumpMapType: string;
        /**
         * Gets the name of the normal map material.
         */
        NormalMapType: string;
        /**
         * Gets the name of the grid material.
         */
        GridType: string;
        /**
         * Gets the name of the stripe material.
         */
        StripeType: string;
        /**
         * Gets the name of the checkerboard material.
         */
        CheckerboardType: string;
        /**
         * Gets the name of the dot material.
         */
        DotType: string;
        /**
         * Gets the name of the water material.
         */
        WaterType: string;
        /**
         * Gets the name of the rim lighting material.
         */
        RimLightingType: string;
        /**
         * Gets the name of the fade material.
         */
        FadeType: string;
        /**
         * Gets the name of the polyline arrow material.
         */
        PolylineArrowType: string;
        /**
         * Gets the name of the polyline glow material.
         */
        PolylineGlowType: string;
        /**
         * Gets the name of the polyline outline material.
         */
        PolylineOutlineType: string;
    }
    /**
     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
that supports shading with materials.
     */
    class MaterialAppearance {
        /**
         * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
that supports shading with materials.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IMaterialAppearanceOptions);
        /**
         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}
properties, this is not read-only, so an appearance's material can change on the fly.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.  The full fragment shader
source is built procedurally taking into account {@link MaterialAppearance#material},
{@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
<p>
The render state can be explicitly defined when constructing a {@link MaterialAppearance}
instance, or it is set implicitly via {@link MaterialAppearance#translucent}
and {@link MaterialAppearance#closed}.
</p>
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed so
{@link MaterialAppearance#renderState} has backface culling enabled.
If the viewer enters the geometry, it will not be visible.
         */
        closed: Boolean;
        /**
         * The type of materials supported by this instance.  This impacts the required
{@link VertexFormat} and the complexity of the vertex and fragment shaders.
         */
        materialSupport: number;
        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
A geometry can have more vertex attributes and still be compatible - at a
potential performance cost - but it can't have less.
         */
        vertexFormat: VertexFormat;
        /**
         * When <code>true</code>, flat shading is used in the fragment shader,
which means lighting is not taking into account.
         */
        flat: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal
as needed to ensure that the normal faces the viewer to avoid
dark spots.  This is useful when both sides of a geometry should be
shaded like {@link WallGeometry}.
         */
        faceForward: Boolean;
        /**
         * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},
this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},
{@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
<p>
Cesium includes support for geometry and materials, glTF animations, and glTF skinning.
In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable
with {@link Model#getNode}.  glTF cameras and lights are not currently supported.
</p>
<p>
An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be
created at runtime and passed to this constructor function.  In either case, the
{@link Model#readyPromise} is resolved when the model is ready to render, i.e.,
when the external binary, image, and shader files are downloaded and the WebGL
resources are created.
</p>
<p>
For high-precision rendering, Cesium supports the CESIUM_RTC extension, which introduces the
CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated
relative to a local origin.
</p>
     */
    class Model {
        /**
         * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
<p>
Cesium includes support for geometry and materials, glTF animations, and glTF skinning.
In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable
with {@link Model#getNode}.  glTF cameras and lights are not currently supported.
</p>
<p>
An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be
created at runtime and passed to this constructor function.  In either case, the
{@link Model#readyPromise} is resolved when the model is ready to render, i.e.,
when the external binary, image, and shader files are downloaded and the WebGL
resources are created.
</p>
<p>
For high-precision rendering, Cesium supports the CESIUM_RTC extension, which introduces the
CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated
relative to a local origin.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IModelOptions);
        /**
         * Determines if the model primitive will be shown.
         */
        show: Boolean;
        /**
         * The 4x4 transformation matrix that transforms the model from model to world coordinates.
When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * A uniform scale applied to this model before the {@link Model#modelMatrix}.
Values greater than <code>1.0</code> increase the size of the model; values
less than <code>1.0</code> decrease.
         */
        scale: number;
        /**
         * The approximate minimum pixel size of the model regardless of zoom.
This can be used to ensure that a model is visible even when the viewer
zooms out.  When <code>0.0</code>, no minimum size is enforced.
         */
        minimumPixelSize: number;
        /**
         * The maximum scale size for a model. This can be used to give
an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model
is never an unreasonable scale.
         */
        maximumScale: number;
        /**
         * User-defined object returned when the model is picked.
         */
        id: any;
        /**
         * The currently playing glTF animations.
         */
        activeAnimations: ModelAnimationCollection;
        /**
         * Determines whether the model casts or receives shadows from each light source.
         */
        shadows: number;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds
to one draw command.  A glTF mesh has an array of primitives, often of length one.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the model in wireframe.
</p>
         */
        debugWireframe: Boolean;
        /**
         * The object for the glTF JSON, including properties with default values omitted
from the JSON provided to this model.
         */
        gltf: any;
        /**
         * The base path that paths in the glTF JSON are relative to.  The base
path is the same path as the path containing the .gltf file
minus the .gltf file, when binary, image, and shader files are
in the same directory as the .gltf.  When this is <code>''</code>,
the app's base path is used.
         */
        basePath: string;
        /**
         * The model's bounding sphere in its local coordinate system.  This does not take into
account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.
         */
        boundingSphere: BoundingSphere;
        /**
         * When <code>true</code>, this model is ready to render, i.e., the external binary, image,
and shader files were downloaded and the WebGL resources were created.  This is set to
<code>true</code> right before {@link Model#readyPromise} is resolved.
         */
        ready: Boolean;
        /**
         * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,
and shader files were downloaded and the WebGL resources were created.
<p>
This promise is resolved at the end of the frame before the first frame the model is rendered in.
</p>
         */
        readyPromise: Promise<Model>;
        /**
         * Determines if model WebGL resource creation will be spread out over several frames or
block until completion once all glTF files are loaded.
         */
        asynchronous: Boolean;
        /**
         * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
         */
        allowPicking: Boolean;
        /**
         * Determine if textures may continue to stream in after the model is loaded.
         */
        incrementallyLoadTextures: Boolean;
        /**
         * Return the number of pending texture loads.
         */
        pendingTextureLoads: number;
        /**
         * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.
         */
        distanceDisplayCondition: DistanceDisplayCondition;
        /**
         * <p>
Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,
and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.
</p>
<p>
The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the
KHR_binary_glTF extension with a .glb extension.
</p>
<p>
For high-precision rendering, Cesium supports the CESIUM_RTC extension, which introduces the
CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated
relative to a local origin.
</p>
         * @param options  (Required) Object with the following properties:
         */
        static fromGltf(options: Model.IModelFromGltfOptions): Model;
        /**
         * Returns the glTF node with the given <code>name</code> property.  This is used to
modify a node's transform for animation outside of glTF animations.
         * @param name  (Required) The glTF name of the node.
         */
        getNode(name: string): ModelNode;
        /**
         * Returns the glTF mesh with the given <code>name</code> property.
         * @param name  (Required) The glTF name of the mesh.
         */
        getMesh(name: string): ModelMesh;
        /**
         * Returns the glTF material with the given <code>name</code> property.
         * @param name  (Required) The glTF name of the material.
         */
        getMaterial(name: string): ModelMaterial;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * An active glTF animation.  A glTF asset can contain animations.  An active animation
is an animation that is currently playing or scheduled to be played because it was
added to a model's {@link ModelAnimationCollection}.  An active animation is an
instance of an animation; for example, there can be multiple active animations
for the same glTF animation, each with a different start time.
<p>
Create this by calling {@link ModelAnimationCollection#add}.
</p>
     */
    class ModelAnimation {
        /**
         * An active glTF animation.  A glTF asset can contain animations.  An active animation
is an animation that is currently playing or scheduled to be played because it was
added to a model's {@link ModelAnimationCollection}.  An active animation is an
instance of an animation; for example, there can be multiple active animations
for the same glTF animation, each with a different start time.
<p>
Create this by calling {@link ModelAnimationCollection#add}.
</p>
         */
        constructor();
        /**
         * When <code>true</code>, the animation is removed after it stops playing.
This is slightly more efficient that not removing it, but if, for example,
time is reversed, the animation is not played again.
         */
        removeOnStop: Boolean;
        /**
         * The event fired when this animation is started.  This can be used, for
example, to play a sound or start a particle system, when the animation starts.
<p>
This event is fired at the end of the frame after the scene is rendered.
</p>
         */
        start: Event;
        /**
         * The event fired when on each frame when this animation is updated.  The
current time of the animation, relative to the glTF animation time span, is
passed to the event, which allows, for example, starting new animations at a
specific time relative to a playing animation.
<p>
This event is fired at the end of the frame after the scene is rendered.
</p>
         */
        update: Event;
        /**
         * The event fired when this animation is stopped.  This can be used, for
example, to play a sound or start a particle system, when the animation stops.
<p>
This event is fired at the end of the frame after the scene is rendered.
</p>
         */
        stop: Event;
        /**
         * The glTF animation name that identifies this animation.
         */
        name: string;
        /**
         * The scene time to start playing this animation.  When this is <code>undefined</code>,
the animation starts at the next frame.
         */
        startTime: JulianDate;
        /**
         * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.
         */
        delay: number;
        /**
         * The scene time to stop playing this animation.  When this is <code>undefined</code>,
the animation is played for its full duration and perhaps repeated depending on
{@link ModelAnimation#loop}.
         */
        stopTime: JulianDate;
        /**
         * Values greater than <code>1.0</code> increase the speed that the animation is played relative
to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of
<code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene
clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation
will play in one second even if <code>speedup</code> is <code>1.0</code>.
         */
        speedup: number;
        /**
         * When <code>true</code>, the animation is played in reverse.
         */
        reverse: Boolean;
        /**
         * Determines if and how the animation is looped.
         */
        loop: number;
    }
    /**
     * A collection of active model animations.  Access this using {@link Model#activeAnimations}.
     */
    class ModelAnimationCollection {
        /**
         * A collection of active model animations.  Access this using {@link Model#activeAnimations}.
         */
        constructor();
        /**
         * The event fired when an animation is added to the collection.  This can be used, for
example, to keep a UI in sync.
         */
        animationAdded: Event;
        /**
         * The event fired when an animation is removed from the collection.  This can be used, for
example, to keep a UI in sync.
         */
        animationRemoved: Event;
        /**
         * The number of animations in the collection.
         */
        length: number;
        /**
         * Creates and adds an animation with the specified initial properties to the collection.
<p>
This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.
</p>
         * @param options  (Required) Object with the following properties:
         */
        add(options: ModelAnimationCollection.IModelAnimationCollectionAddOptions): ModelAnimation;
        /**
         * Creates and adds an animation with the specified initial properties to the collection
for each animation in the model.
<p>
This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        addAll(options?: ModelAnimationCollection.IModelAnimationCollectionAddAllOptions): ModelAnimation[];
        /**
         * Removes an animation from the collection.
<p>
This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.
</p>
<p>
An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to
<code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.
</p>
         * @param animation  (Required) The animation to remove.
         */
        remove(animation: ModelAnimation): Boolean;
        /**
         * Removes all animations from the collection.
<p>
This raises the {@link ModelAnimationCollection#animationRemoved} event for each
animation so, for example, a UI can stay in sync.
</p>
         */
        removeAll(): void;
        /**
         * Determines whether this collection contains a given animation.
         * @param animation  (Required) The animation to check for.
         */
        contains(animation: ModelAnimation): Boolean;
        /**
         * Returns the animation in the collection at the specified index.  Indices are zero-based
and increase as animations are added.  Removing an animation shifts all animations after
it to the left, changing their indices.  This function is commonly used to iterate over
all the animations in the collection.
         * @param index  (Required) The zero-based index of the animation.
         */
        get(index: number): ModelAnimation;
    }
    /**
     * A model's material with modifiable parameters.  A glTF material
contains parameters defined by the material's technique with values
defined by the technique and potentially overridden by the material.
This class allows changing these values at runtime.
<p>
Use {@link Model#getMaterial} to create an instance.
</p>
     */
    class ModelMaterial {
        /**
         * A model's material with modifiable parameters.  A glTF material
contains parameters defined by the material's technique with values
defined by the technique and potentially overridden by the material.
This class allows changing these values at runtime.
<p>
Use {@link Model#getMaterial} to create an instance.
</p>
         */
        constructor();
        /**
         * The value of the <code>name</code> property of this material.  This is the
name assigned by the artist when the asset is created.  This can be
different than the name of the material property ({@link ModelMaterial#id}),
which is internal to glTF.
         */
        name: string;
        /**
         * The name of the glTF JSON property for this material.  This is guaranteed
to be unique among all materials.  It may not match the material's <code>
name</code> property (@link ModelMaterial#name), which is assigned by
the artist when the asset is created.
         */
        id: string;
        /**
         * Assigns a value to a material parameter.  The type for <code>value</code>
depends on the glTF type of the parameter.  It will be a floating-point
number, Cartesian, or matrix.
         * @param name  (Required) The name of the parameter.
         * @param value  (Optional) The value to assign to the parameter.
         */
        setValue(name: string, value?: any): void;
        /**
         * Returns the value of the parameter with the given <code>name</code>.  The type of the
returned object depends on the glTF type of the parameter.  It will be a floating-point
number, Cartesian, or matrix.
         * @param name  (Required) The name of the parameter.
         */
        getValue(name: string): any;
    }
    /**
     * A model's mesh and its materials.
<p>
Use {@link Model#getMesh} to create an instance.
</p>
     */
    class ModelMesh {
        /**
         * A model's mesh and its materials.
<p>
Use {@link Model#getMesh} to create an instance.
</p>
         */
        constructor();
        /**
         * The value of the <code>name</code> property of this mesh.  This is the
name assigned by the artist when the asset is created.  This can be
different than the name of the mesh property ({@link ModelMesh#id}),
which is internal to glTF.
         */
        name: string;
        /**
         * The name of the glTF JSON property for this mesh.  This is guaranteed
to be unique among all meshes.  It may not match the mesh's <code>
name</code> property (@link ModelMesh#name), which is assigned by
the artist when the asset is created.
         */
        id: string;
        /**
         * An array of {@link ModelMaterial} instances indexed by the mesh's
primitive indices.
         */
        materials: ModelMaterial[];
    }
    /**
     * A model node with a transform for user-defined animations.  A glTF asset can
contain animations that target a node's transform.  This class allows
changing a node's transform externally so animation can be driven by another
source, not just an animation in the glTF asset.
<p>
Use {@link Model#getNode} to create an instance.
</p>
     */
    class ModelNode {
        /**
         * A model node with a transform for user-defined animations.  A glTF asset can
contain animations that target a node's transform.  This class allows
changing a node's transform externally so animation can be driven by another
source, not just an animation in the glTF asset.
<p>
Use {@link Model#getNode} to create an instance.
</p>
         */
        constructor();
        /**
         * The value of the <code>name</code> property of this node.  This is the
name assigned by the artist when the asset is created.  This can be
different than the name of the node property ({@link ModelNode#id}),
which is internal to glTF.
         */
        name: string;
        /**
         * The name of the glTF JSON property for this node.  This is guaranteed
to be unique among all nodes.  It may not match the node's <code>
name</code> property (@link ModelNode#name), which is assigned by
the artist when the asset is created.
         */
        id: string;
        /**
         * Determines if this node and its children will be shown.
         */
        show: Boolean;
        /**
         * The node's 4x4 matrix transform from its local coordinates to
its parent's.
<p>
For changes to take effect, this property must be assigned to;
setting individual elements of the matrix will not work.
</p>
         */
        matrix: Matrix4;
    }
    /**
     * Draws the Moon in 3D.
     */
    class Moon {
        /**
         * Draws the Moon in 3D.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IMoonOptions);
        /**
         * Determines if the moon will be shown.
         */
        show: Boolean;
        /**
         * The moon texture.
         */
        textureUrl: string;
        /**
         * Use the sun as the only light source.
         */
        onlySunLighting: Boolean;
        /**
         * Get the ellipsoid that defines the shape of the moon.
         */
        ellipsoid: Ellipsoid;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * A {@link TileDiscardPolicy} specifying that tile images should never be discard.
     */
    class NeverTileDiscardPolicy {
        /**
         * A {@link TileDiscardPolicy} specifying that tile images should never be discard.
         */
        constructor();
        /**
         * Determines if the discard policy is ready to process images.
         */
        isReady(): Boolean;
        /**
         * Given a tile image, decide whether to discard that image.
         * @param image  (Required) An image to test.
         */
        shouldDiscardImage(image: HTMLImageElement): Boolean;
    }
    /**
     * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
     */
    class OrthographicFrustum {
        /**
         * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
         */
        constructor();
        /**
         * The left clipping plane.
         */
        left: number;
        /**
         * The right clipping plane.
         */
        right: number;
        /**
         * The top clipping plane.
         */
        top: number;
        /**
         * The bottom clipping plane.
         */
        bottom: number;
        /**
         * The distance of the near plane.
         */
        near: number;
        /**
         * The distance of the far plane.
         */
        far: number;
        /**
         * Gets the orthographic projection matrix computed from the view frustum.
         */
        projectionMatrix: Matrix4;
        /**
         * Creates a culling volume for this frustum.
         * @param position  (Required) The eye position.
         * @param direction  (Required) The view direction.
         * @param up  (Required) The up direction.
         */
        computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
        /**
         * Returns the pixel's width and height in meters.
         * @param drawingBufferWidth  (Required) The width of the drawing buffer.
         * @param drawingBufferHeight  (Required) The height of the drawing buffer.
         * @param distance  (Required) The distance to the near plane in meters.
         * @param result  (Required) The object onto which to store the result.
         */
        getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;
        /**
         * Returns a duplicate of a OrthographicFrustum instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: OrthographicFrustum): OrthographicFrustum;
        /**
         * Compares the provided OrthographicFrustum componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The right hand side OrthographicFrustum.
         */
        equals(other?: OrthographicFrustum): Boolean;
    }
    /**
     * An appearance for {@link GeometryInstance} instances with color attributes.
This allows several geometry instances, each with a different color, to
be drawn with the same {@link Primitive} as shown in the second example below.
     */
    class PerInstanceColorAppearance {
        /**
         * An appearance for {@link GeometryInstance} instances with color attributes.
This allows several geometry instances, each with a different color, to
be drawn with the same {@link Primitive} as shown in the second example below.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPerInstanceColorAppearanceOptions);
        /**
         * This property is part of the {@link Appearance} interface, but is not
used by {@link PerInstanceColorAppearance} since a fully custom fragment shader is used.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so
{@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
<p>
The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
and {@link PerInstanceColorAppearance#closed}.
</p>
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed so
{@link PerInstanceColorAppearance#renderState} has backface culling enabled.
If the viewer enters the geometry, it will not be visible.
         */
        closed: Boolean;
        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
A geometry can have more vertex attributes and still be compatible - at a
potential performance cost - but it can't have less.
         */
        vertexFormat: VertexFormat;
        /**
         * When <code>true</code>, flat shading is used in the fragment shader,
which means lighting is not taking into account.
         */
        flat: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal
as needed to ensure that the normal faces the viewer to avoid
dark spots.  This is useful when both sides of a geometry should be
shaded like {@link WallGeometry}.
         */
        faceForward: Boolean;
        /**
         * Procedurally creates the full GLSL fragment shader source.  For {@link PerInstanceColorAppearance},
this is derived from {@link PerInstanceColorAppearance#fragmentShaderSource}, {@link PerInstanceColorAppearance#flat},
and {@link PerInstanceColorAppearance#faceForward}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link PerInstanceColorAppearance#translucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
     */
    class PerspectiveFrustum {
        /**
         * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
         */
        constructor();
        /**
         * The angle of the field of view (FOV), in radians.  This angle will be used
as the horizontal FOV if the width is greater than the height, otherwise
it will be the vertical FOV.
         */
        fov: number;
        /**
         * The aspect ratio of the frustum's width to it's height.
         */
        aspectRatio: number;
        /**
         * The distance of the near plane.
         */
        near: number;
        /**
         * The distance of the far plane.
         */
        far: number;
        /**
         * Offsets the frustum in the x direction.
         */
        xOffset: number;
        /**
         * Offsets the frustum in the y direction.
         */
        yOffset: number;
        /**
         * Gets the perspective projection matrix computed from the view frustum.
         */
        projectionMatrix: Matrix4;
        /**
         * The perspective projection matrix computed from the view frustum with an infinite far plane.
         */
        infiniteProjectionMatrix: Matrix4;
        /**
         * Gets the angle of the vertical field of view, in radians.
         */
        fovy: number;
        /**
         * Creates a culling volume for this frustum.
         * @param position  (Required) The eye position.
         * @param direction  (Required) The view direction.
         * @param up  (Required) The up direction.
         */
        computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
        /**
         * Returns the pixel's width and height in meters.
         * @param drawingBufferWidth  (Required) The width of the drawing buffer.
         * @param drawingBufferHeight  (Required) The height of the drawing buffer.
         * @param distance  (Required) The distance to the near plane in meters.
         * @param result  (Required) The object onto which to store the result.
         */
        getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;
        /**
         * Returns a duplicate of a PerspectiveFrustum instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PerspectiveFrustum): PerspectiveFrustum;
        /**
         * Compares the provided PerspectiveFrustum componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The right hand side PerspectiveFrustum.
         */
        equals(other?: PerspectiveFrustum): Boolean;
    }
    /**
     * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
     */
    class PerspectiveOffCenterFrustum {
        /**
         * The viewing frustum is defined by 6 planes.
Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
define the unit vector normal to the plane, and the w component is the distance of the
plane from the origin/camera position.
         */
        constructor();
        /**
         * Defines the left clipping plane.
         */
        left: number;
        /**
         * Defines the right clipping plane.
         */
        right: number;
        /**
         * Defines the top clipping plane.
         */
        top: number;
        /**
         * Defines the bottom clipping plane.
         */
        bottom: number;
        /**
         * The distance of the near plane.
         */
        near: number;
        /**
         * The distance of the far plane.
         */
        far: number;
        /**
         * Gets the perspective projection matrix computed from the view frustum.
         */
        projectionMatrix: Matrix4;
        /**
         * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
         */
        infiniteProjectionMatrix: Matrix4;
        /**
         * Creates a culling volume for this frustum.
         * @param position  (Required) The eye position.
         * @param direction  (Required) The view direction.
         * @param up  (Required) The up direction.
         */
        computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
        /**
         * Returns the pixel's width and height in meters.
         * @param drawingBufferWidth  (Required) The width of the drawing buffer.
         * @param drawingBufferHeight  (Required) The height of the drawing buffer.
         * @param distance  (Required) The distance to the near plane in meters.
         * @param result  (Required) The object onto which to store the result.
         */
        getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;
        /**
         * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
         * @param result  (Optional) The object onto which to store the result.
         */
        clone(result?: PerspectiveOffCenterFrustum): PerspectiveOffCenterFrustum;
        /**
         * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
<code>true</code> if they are equal, <code>false</code> otherwise.
         * @param other  (Optional) The right hand side PerspectiveOffCenterFrustum.
         */
        equals(other?: PerspectiveOffCenterFrustum): Boolean;
    }
    /**
     * A graphical point positioned in the 3D scene, that is created
and rendered using a {@link PointPrimitiveCollection}.  A point is created and its initial
properties are set by calling {@link PointPrimitiveCollection#add}.
     */
    class PointPrimitive {
        /**
         * A graphical point positioned in the 3D scene, that is created
and rendered using a {@link PointPrimitiveCollection}.  A point is created and its initial
properties are set by calling {@link PointPrimitiveCollection#add}.
         */
        constructor();
        /**
         * Determines if this point will be shown.  Use this to hide or show a point, instead
of removing it and re-adding it to the collection.
         */
        show: Boolean;
        /**
         * Gets or sets the Cartesian position of this point.
         */
        position: Cartesian3;
        /**
         * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
scaleByDistance will be disabled.
         */
        scaleByDistance: NearFarScalar;
        /**
         * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
{@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
translucencyByDistance will be disabled.
         */
        translucencyByDistance: NearFarScalar;
        /**
         * Gets or sets the inner size of the point in pixels.
         */
        pixelSize: number;
        /**
         * Gets or sets the inner color of the point.
The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
<code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
(no intensity) to <code>1.0</code> (full intensity).
         */
        color: number;
        /**
         * Gets or sets the outline color of the point.
         */
        outlineColor: number;
        /**
         * Gets or sets the outline width in pixels.  This width adds to pixelSize,
increasing the total size of the point.
         */
        outlineWidth: number;
        /**
         * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
         */
        distanceDisplayCondition: DistanceDisplayCondition;
        /**
         * Gets or sets the user-defined object returned when the point is picked.
         */
        id: any;
        /**
         * Computes the screen-space position of the point's origin.
The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
left to right, and <code>y</code> increases from top to bottom.
         * @param scene  (Required) The scene.
         * @param result  (Optional) The object onto which to store the result.
         */
        computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
        /**
         * Determines if this point equals another point.  Points are equal if all their properties
are equal.  Points in different collections can be equal.
         * @param other  (Required) The point to compare for equality.
         */
        equals(other: PointPrimitive): Boolean;
    }
    /**
     * A renderable collection of points.
<br /><br />
Points are added and removed from the collection using {@link PointPrimitiveCollection#add}
and {@link PointPrimitiveCollection#remove}.
     */
    class PointPrimitiveCollection {
        /**
         * A renderable collection of points.
<br /><br />
Points are added and removed from the collection using {@link PointPrimitiveCollection#add}
and {@link PointPrimitiveCollection#remove}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPointPrimitiveCollectionOptions);
        /**
         * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.
When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * Returns the number of points in this collection.  This is commonly used with
{@link PointPrimitiveCollection#get} to iterate over all the points
in the collection.
         */
        length: number;
        /**
         * Creates and adds a point with the specified initial properties to the collection.
The added point is returned so it can be modified or removed from the collection later.
         * @param pointPrimitive  (Optional) A template describing the point's properties as shown in Example 1.
         */
        add(pointPrimitive?: any): PointPrimitive;
        /**
         * Removes a point from the collection.
         * @param pointPrimitive  (Required) The point to remove.
         */
        remove(pointPrimitive: PointPrimitive): Boolean;
        /**
         * Removes all points from the collection.
         */
        removeAll(): void;
        /**
         * Check whether this collection contains a given point.
         * @param pointPrimitive  (Optional) The point to check for.
         */
        contains(pointPrimitive?: PointPrimitive): Boolean;
        /**
         * Returns the point in the collection at the specified index.  Indices are zero-based
and increase as points are added.  Removing a point shifts all points after
it to the left, changing their indices.  This function is commonly used with
{@link PointPrimitiveCollection#length} to iterate over all the points
in the collection.
         * @param index  (Required) The zero-based index of the point.
         */
        get(index: number): PointPrimitive;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * A renderable polyline. Create this by calling {@link PolylineCollection#add}
     */
    class Polyline {
        /**
         * A renderable polyline. Create this by calling {@link PolylineCollection#add}
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineOptions);
        /**
         * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead
of removing it and re-adding it to the collection.
         */
        show: Boolean;
        /**
         * Gets or sets the positions of the polyline.
         */
        positions: Cartesian3[];
        /**
         * Gets or sets the surface appearance of the polyline.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
{@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.
         */
        material: Material;
        /**
         * Gets or sets the width of the polyline.
         */
        width: number;
        /**
         * Gets or sets whether a line segment will be added between the first and last polyline positions.
         */
        loop: Boolean;
        /**
         * Gets or sets the user-defined object returned when the polyline is picked.
         */
        id: any;
        /**
         * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.
         */
        distanceDisplayCondition: DistanceDisplayCondition;
    }
    /**
     * A renderable collection of polylines.
<br /><br />
<div align="center">
<img src="images/Polyline.png" width="400" height="300" /><br />
Example polylines
</div>
<br /><br />
Polylines are added and removed from the collection using {@link PolylineCollection#add}
and {@link PolylineCollection#remove}.
     */
    class PolylineCollection {
        /**
         * A renderable collection of polylines.
<br /><br />
<div align="center">
<img src="images/Polyline.png" width="400" height="300" /><br />
Example polylines
</div>
<br /><br />
Polylines are added and removed from the collection using {@link PolylineCollection#add}
and {@link PolylineCollection#remove}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineCollectionOptions);
        /**
         * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.
When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.
         */
        modelMatrix: Matrix4;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * Returns the number of polylines in this collection.  This is commonly used with
{@link PolylineCollection#get} to iterate over all the polylines
in the collection.
         */
        length: number;
        /**
         * Creates and adds a polyline with the specified initial properties to the collection.
The added polyline is returned so it can be modified or removed from the collection later.
         * @param polyline  (Optional) A template describing the polyline's properties as shown in Example 1.
         */
        add(polyline?: any): Polyline;
        /**
         * Removes a polyline from the collection.
         * @param polyline  (Required) The polyline to remove.
         */
        remove(polyline: Polyline): Boolean;
        /**
         * Removes all polylines from the collection.
         */
        removeAll(): void;
        /**
         * Determines if this collection contains the specified polyline.
         * @param polyline  (Required) The polyline to check for.
         */
        contains(polyline: Polyline): Boolean;
        /**
         * Returns the polyline in the collection at the specified index.  Indices are zero-based
and increase as polylines are added.  Removing a polyline shifts all polylines after
it to the left, changing their indices.  This function is commonly used with
{@link PolylineCollection#length} to iterate over all the polylines
in the collection.
         * @param index  (Required) The zero-based index of the polyline.
         */
        get(index: number): Polyline;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * An appearance for {@link GeometryInstance} instances with color attributes and {@link PolylineGeometry}.
This allows several geometry instances, each with a different color, to
be drawn with the same {@link Primitive}.
     */
    class PolylineColorAppearance {
        /**
         * An appearance for {@link GeometryInstance} instances with color attributes and {@link PolylineGeometry}.
This allows several geometry instances, each with a different color, to
be drawn with the same {@link Primitive}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineColorAppearanceOptions);
        /**
         * This property is part of the {@link Appearance} interface, but is not
used by {@link PolylineColorAppearance} since a fully custom fragment shader is used.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so
{@link PolylineColorAppearance#renderState} has alpha blending enabled.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
<p>
The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
</p>
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed so
{@link PolylineColorAppearance#renderState} has backface culling enabled.
This is always <code>false</code> for <code>PolylineColorAppearance</code>.
         */
        closed: Boolean;
        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
A geometry can have more vertex attributes and still be compatible - at a
potential performance cost - but it can't have less.
         */
        vertexFormat: VertexFormat;
        /**
         * Procedurally creates the full GLSL fragment shader source.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link PolylineColorAppearance#translucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * An appearance for {@link PolylineGeometry} that supports shading with materials.
     */
    class PolylineMaterialAppearance {
        /**
         * An appearance for {@link PolylineGeometry} that supports shading with materials.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPolylineMaterialAppearanceOptions);
        /**
         * The material used to determine the fragment color.  Unlike other {@link PolylineMaterialAppearance}
properties, this is not read-only, so an appearance's material can change on the fly.
         */
        material: Material;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so
{@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
         */
        translucent: Boolean;
        /**
         * The GLSL source code for the vertex shader.
         */
        vertexShaderSource: string;
        /**
         * The GLSL source code for the fragment shader.
         */
        fragmentShaderSource: string;
        /**
         * The WebGL fixed-function state to use when rendering the geometry.
<p>
The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
and {@link PolylineMaterialAppearance#closed}.
</p>
         */
        renderState: any;
        /**
         * When <code>true</code>, the geometry is expected to be closed so
{@link PolylineMaterialAppearance#renderState} has backface culling enabled.
This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
         */
        closed: Boolean;
        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
A geometry can have more vertex attributes and still be compatible - at a
potential performance cost - but it can't have less.
         */
        vertexFormat: VertexFormat;
        /**
         * Procedurally creates the full GLSL fragment shader source.  For {@link PolylineMaterialAppearance},
this is derived from {@link PolylineMaterialAppearance#fragmentShaderSource} and {@link PolylineMaterialAppearance#material}.
         */
        getFragmentShaderSource(): string;
        /**
         * Determines if the geometry is translucent based on {@link PolylineMaterialAppearance#translucent} and {@link Material#isTranslucent}.
         */
        isTranslucent(): Boolean;
        /**
         * Creates a render state.  This is not the final render state instance; instead,
it can contain a subset of render state properties identical to the render state
created in the context.
         */
        getRenderState(): any;
    }
    /**
     * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}
as shown in example 1 below, or from an array of instances, even if the geometry is from different
geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.
<p>
A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
{@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
and match most of them and add a new geometry or appearance independently of each other.
</p>
<p>
Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.
Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using
per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.
</p>
<p>
{@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples
show geometry that will be created on a web worker by using the descriptions of the geometry. The third example
shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.
</p>
     */
    class Primitive {
        /**
         * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}
as shown in example 1 below, or from an array of instances, even if the geometry is from different
geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.
<p>
A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
{@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
and match most of them and add a new geometry or appearance independently of each other.
</p>
<p>
Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.
Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using
per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.
</p>
<p>
{@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples
show geometry that will be created on a web worker by using the descriptions of the geometry. The third example
shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPrimitiveOptions);
        /**
         * The geometry instances rendered with this primitive.  This may
be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
is <code>true</code> when the primitive is constructed.
<p>
Changing this property after the primitive is rendered has no effect.
</p>
         */
        geometryInstances: GeometryInstance[]|GeometryInstance;
        /**
         * The {@link Appearance} used to shade this primitive.  Each geometry
instance is shaded with the same appearance.  Some appearances, like
{@link PerInstanceColorAppearance} allow giving each instance unique
properties.
         */
        appearance: Appearance;
        /**
         * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
Local reference frames can be used by providing a different transformation matrix, like that returned
by {@link Transforms.eastNorthUpToFixedFrame}.

<p>
This property is only supported in 3D mode.
</p>
         */
        modelMatrix: Matrix4;
        /**
         * Determines if the primitive will be shown.  This affects all geometry
instances in the primitive.
         */
        show: Boolean;
        /**
         * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands
based on their bounding volume.  Set this to <code>false</code> for a small performance gain
if you are manually culling the primitive.
         */
        cull: Boolean;
        /**
         * This property is for debugging only; it is not for production use nor is it optimized.
<p>
Draws the bounding sphere for each draw command in the primitive.
</p>
         */
        debugShowBoundingVolume: Boolean;
        /**
         * Determines whether this primitive casts or receives shadows from each light source.
         */
        shadows: number;
        /**
         * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
         */
        vertexCacheOptimize: Boolean;
        /**
         * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
         */
        interleave: Boolean;
        /**
         * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
         */
        releaseGeometryInstances: Boolean;
        /**
         * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
         */
        allowPicking: Boolean;
        /**
         * Determines if the geometry instances will be created and batched on a web worker.
         */
        asynchronous: Boolean;
        /**
         * When <code>true</code>, geometry vertices are compressed, which will save memory.
         */
        compressVertices: Boolean;
        /**
         * Determines if the primitive is complete and ready to render.  If this property is
true, the primitive will be rendered the next time that {@link Primitive#update}
is called.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves when the primitive is ready to render.
         */
        readyPromise: Promise<Primitive>;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
         * @param id  (Required) The id of the {@link GeometryInstance}.
         */
        getGeometryInstanceAttributes(id: any): any;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<p>
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
</p>
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<p>
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
</p>
         */
        destroy(): void;
    }
    /**
     * A collection of primitives.  This is most often used with {@link Scene#primitives},
but <code>PrimitiveCollection</code> is also a primitive itself so collections can
be added to collections forming a hierarchy.
     */
    class PrimitiveCollection {
        /**
         * A collection of primitives.  This is most often used with {@link Scene#primitives},
but <code>PrimitiveCollection</code> is also a primitive itself so collections can
be added to collections forming a hierarchy.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPrimitiveCollectionOptions);
        /**
         * Determines if primitives in this collection will be shown.
         */
        show: Boolean;
        /**
         * Determines if primitives in the collection are destroyed when they are removed by
{@link PrimitiveCollection#destroy} or  {@link PrimitiveCollection#remove} or implicitly
by {@link PrimitiveCollection#removeAll}.
         */
        destroyPrimitives: Boolean;
        /**
         * Gets the number of primitives in the collection.
         */
        length: number;
        /**
         * Adds a primitive to the collection.
         * @param primitive  (Required) The primitive to add.
         */
        add(primitive: any): any;
        /**
         * Removes a primitive from the collection.
         * @param primitive  (Optional) The primitive to remove.
         */
        remove(primitive?: any): Boolean;
        /**
         * Removes all primitives in the collection.
         */
        removeAll(): void;
        /**
         * Determines if this collection contains a primitive.
         * @param primitive  (Optional) The primitive to check for.
         */
        contains(primitive?: any): Boolean;
        /**
         * Raises a primitive "up one" in the collection.  If all primitives in the collection are drawn
on the globe surface, this visually moves the primitive up one.
         * @param primitive  (Optional) The primitive to raise.
         */
        raise(primitive?: any): void;
        /**
         * Raises a primitive to the "top" of the collection.  If all primitives in the collection are drawn
on the globe surface, this visually moves the primitive to the top.
         * @param primitive  (Optional) The primitive to raise the top.
         */
        raiseToTop(primitive?: any): void;
        /**
         * Lowers a primitive "down one" in the collection.  If all primitives in the collection are drawn
on the globe surface, this visually moves the primitive down one.
         * @param primitive  (Optional) The primitive to lower.
         */
        lower(primitive?: any): void;
        /**
         * Lowers a primitive to the "bottom" of the collection.  If all primitives in the collection are drawn
on the globe surface, this visually moves the primitive to the bottom.
         * @param primitive  (Optional) The primitive to lower to the bottom.
         */
        lowerToBottom(primitive?: any): void;
        /**
         * Returns the primitive in the collection at the specified index.
         * @param index  (Required) The zero-based index of the primitive to return.
         */
        get(index: number): any;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this
collection allows for deterministic release of WebGL resources, instead of relying on the garbage
collector to destroy this collection.
<br /><br />
Since destroying a collection destroys all the contained primitives, only destroy a collection
when you are sure no other code is still using any of the contained primitives.
<br /><br />
Once this collection is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,
a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.
<p>
<em><code>contextOptions</code> parameter details:</em>
</p>
<p>
The default values are:
<code>
{
  webgl : {
    alpha : false,
    depth : true,
    stencil : false,
    antialias : true,
    premultipliedAlpha : true,
    preserveDrawingBuffer : false,
    failIfMajorPerformanceCaveat : false
  },
  allowTextureFilterAnisotropic : true
}
</code>
</p>
<p>
The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
object used to create the WebGL context.
</p>
<p>
<code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default
of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set
<code>webgl.alpha</code> to true.
</p>
<p>
The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.
</p>
<p>
<code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the
WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.
</p>
     */
    class Scene {
        /**
         * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,
a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.
<p>
<em><code>contextOptions</code> parameter details:</em>
</p>
<p>
The default values are:
<code>
{
  webgl : {
    alpha : false,
    depth : true,
    stencil : false,
    antialias : true,
    premultipliedAlpha : true,
    preserveDrawingBuffer : false,
    failIfMajorPerformanceCaveat : false
  },
  allowTextureFilterAnisotropic : true
}
</code>
</p>
<p>
The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
object used to create the WebGL context.
</p>
<p>
<code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default
of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set
<code>webgl.alpha</code> to true.
</p>
<p>
The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.
</p>
<p>
<code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the
WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.
</p>
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ISceneOptions);
        /**
         * Exceptions occurring in <code>render</code> are always caught in order to raise the
<code>renderError</code> event.  If this property is true, the error is rethrown
after the event is raised.  If this property is false, the <code>render</code> function
returns normally after raising the event.
         */
        rethrowRenderErrors: Boolean;
        /**
         * Determines whether or not to instantly complete the
scene transition animation on user input.
         */
        completeMorphOnUserInput: Boolean;
        /**
         * The event fired at the beginning of a scene transition.
         */
        morphStart: Event;
        /**
         * The event fired at the completion of a scene transition.
         */
        morphComplete: Event;
        /**
         * The {@link SkyBox} used to draw the stars.
         */
        skyBox: SkyBox;
        /**
         * The sky atmosphere drawn around the globe.
         */
        skyAtmosphere: SkyAtmosphere;
        /**
         * The {@link Sun}.
         */
        sun: Sun;
        /**
         * Uses a bloom filter on the sun when enabled.
         */
        sunBloom: Boolean;
        /**
         * The {@link Moon}
         */
        moon: Moon;
        /**
         * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.
         */
        backgroundColor: number;
        /**
         * The current morph transition time between 2D/Columbus View and 3D,
with 0.0 being 2D or Columbus View and 1.0 being 3D.
         */
        morphTime: number;
        /**
         * The far-to-near ratio of the multi-frustum. The default is 1,000.0.
         */
        farToNearRatio: number;
        /**
         * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close
to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the
other hand, increasing this will increase performance but may cause z-fighting among primitives close to thesurface.
         */
        nearToFarDistance2D: number;
        /**
         * This property is for debugging only; it is not for production use.
<p>
A function that determines what commands are executed.  As shown in the examples below,
the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the
command should be executed.
</p>
<p>
The default is <code>undefined</code>, indicating that all commands are executed.
</p>
         */
        debugCommandFilter: Function;
        /**
         * This property is for debugging only; it is not for production use.
<p>
When <code>true</code>, commands are randomly shaded.  This is useful
for performance analysis to see what parts of a scene or model are
command-dense and could benefit from batching.
</p>
         */
        debugShowCommands: Boolean;
        /**
         * This property is for debugging only; it is not for production use.
<p>
When <code>true</code>, commands are shaded based on the frustums they
overlap.  Commands in the closest frustum are tinted red, commands in
the next closest are green, and commands in the farthest frustum are
blue.  If a command overlaps more than one frustum, the color components
are combined, e.g., a command overlapping the first two frustums is tinted
yellow.
</p>
         */
        debugShowFrustums: Boolean;
        /**
         * This property is for debugging only; it is not for production use.
<p>
Displays frames per second and time between frames.
</p>
         */
        debugShowFramesPerSecond: Boolean;
        /**
         * This property is for debugging only; it is not for production use.
<p>
Displays depth information for the indicated frustum.
</p>
         */
        debugShowGlobeDepth: Boolean;
        /**
         * This property is for debugging only; it is not for production use.
<p>
Indicates which frustum will have depth information displayed.
</p>
         */
        debugShowDepthFrustum: number;
        /**
         * When <code>true</code>, enables Fast Approximate Anti-aliasing even when order independent translucency
is unsupported.
         */
        fxaa: Boolean;
        /**
         * When <code>true</code>, enables picking using the depth buffer.
         */
        useDepthPicking: Boolean;
        /**
         * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
performance improvements by rendering less geometry and dispatching less terrain requests.
         */
        fog: Fog;
        /**
         * The shadow map in the scene. When enabled, models, primitives, and the globe may cast and receive shadows.
By default the light source of the shadow map is the sun.
         */
        shadowMap: ShadowMap;
        /**
         * Gets the canvas element to which this scene is bound.
         */
        canvas: HTMLCanvasElement;
        /**
         * The drawingBufferWidth of the underlying GL context.
         */
        drawingBufferHeight: number;
        /**
         * The drawingBufferHeight of the underlying GL context.
         */
        drawingBufferWidth: number;
        /**
         * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
         */
        maximumAliasedLineWidth: number;
        /**
         * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.
         */
        maximumCubeMapSize: number;
        /**
         * Returns true if the pickPosition function is supported.
         */
        pickPositionSupported: Boolean;
        /**
         * Gets or sets the depth-test ellipsoid.
         */
        globe: Globe;
        /**
         * Gets the collection of primitives.
         */
        primitives: PrimitiveCollection;
        /**
         * Gets the collection of ground primitives.
         */
        groundPrimitives: PrimitiveCollection;
        /**
         * Gets the camera.
         */
        camera: Camera;
        /**
         * Gets the controller for camera input handling.
         */
        screenSpaceCameraController: ScreenSpaceCameraController;
        /**
         * Get the map projection to use in 2D and Columbus View modes.
         */
        mapProjection: MapProjection;
        /**
         * Gets the collection of image layers that will be rendered on the globe.
         */
        imageryLayers: ImageryLayerCollection;
        /**
         * The terrain provider providing surface geometry for the globe.
         */
        terrainProvider: TerrainProvider;
        /**
         * Gets an event that's raised when the terrain provider is changed
         */
        terrainProviderChanged: Event;
        /**
         * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.
The Scene instance and the thrown error are the only two parameters passed to the event handler.
By default, errors are not rethrown after this event is raised, but that can be changed by setting
the <code>rethrowRenderErrors</code> property.
         */
        renderError: Event;
        /**
         * Gets the event that will be raised at the start of each call to <code>render</code>.  Subscribers to the event
receive the Scene instance as the first parameter and the current time as the second parameter.
         */
        preRender: Event;
        /**
         * Gets the event that will be raised at the end of each call to <code>render</code>.  Subscribers to the event
receive the Scene instance as the first parameter and the current time as the second parameter.
         */
        postRender: Event;
        /**
         * This property is for debugging only; it is not for production use.
<p>
When {@link Scene.debugShowFrustums} is <code>true</code>, this contains
properties with statistics about the number of command execute per frustum.
<code>totalCommands</code> is the total number of commands executed, ignoring
overlap. <code>commandsInFrustums</code> is an array with the number of times
commands are executed redundantly, e.g., how many commands overlap two or
three frustums.
</p>
         */
        debugFrustumStatistics: any;
        /**
         * Gets whether or not the scene is optimized for 3D only viewing.
         */
        scene3DOnly: Boolean;
        /**
         * Gets whether or not the scene has order independent translucency enabled.
Note that this only reflects the original construction option, and there are
other factors that could prevent OIT from functioning on a given system configuration.
         */
        orderIndependentTranslucency: Boolean;
        /**
         * Gets the unique identifier for this scene.
         */
        id: string;
        /**
         * Gets or sets the current mode of the scene.
         */
        mode: number;
        /**
         * Gets the scalar used to exaggerate the terrain.
         */
        terrainExaggeration: number;
        /**
         * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.
Used for cardboard and WebVR.
         */
        useWebVR: Boolean;
        /**
         * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
         */
        mapMode2D: Boolean;
        /**
         * Returns an object with a `primitive` property that contains the first (top) primitive in the scene
at a particular window coordinate or undefined if nothing is at the location. Other properties may
potentially be set depending on the type of primitive.
         * @param windowPosition  (Required) Window coordinates to perform picking on.
         */
        pick(windowPosition: Cartesian2): any;
        /**
         * Returns the cartesian position reconstructed from the depth buffer and window position.
         * @param windowPosition  (Required) Window coordinates to perform picking on.
         * @param result  (Optional) The object on which to restore the result.
         */
        pickPosition(windowPosition: Cartesian2, result?: Cartesian3): Cartesian3;
        /**
         * Returns a list of objects, each containing a `primitive` property, for all primitives at
a particular window coordinate position. Other properties may also be set depending on the
type of primitive. The primitives in the list are ordered by their visual order in the
scene (front to back).
         * @param windowPosition  (Required) Window coordinates to perform picking on.
         * @param limit  (Optional) If supplied, stop drilling after collecting this many picks.
         */
        drillPick(windowPosition: Cartesian2, limit?: number): any[];
        /**
         * Instantly completes an active transition.
         */
        completeMorph(): void;
        /**
         * Asynchronously transitions the scene to 2D.
         * @param duration  (Optional) The amount of time, in seconds, for transition animations to complete.
         */
        morphTo2D(duration?: number): void;
        /**
         * Asynchronously transitions the scene to Columbus View.
         * @param duration  (Optional) The amount of time, in seconds, for transition animations to complete.
         */
        morphToColumbusView(duration?: number): void;
        /**
         * Asynchronously transitions the scene to 3D.
         * @param duration  (Optional) The amount of time, in seconds, for transition animations to complete.
         */
        morphTo3D(duration?: number): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Modifies the camera position and orientation based on mouse input to a canvas.
     */
    class ScreenSpaceCameraController {
        /**
         * Modifies the camera position and orientation based on mouse input to a canvas.
         * @param scene  (Required) The scene.
         */
        constructor(scene: Scene);
        /**
         * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,
enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.

NOTE: This setting is for temporary use cases, such as camera flights and
drag-selection of regions (see Picking demo).  It is typically set to false at the
start of such events, and set true on completion.  To keep inputs disabled
past the end of camera flights, you must use the other booleans (enableTranslate,
enableZoom, enableRotate, enableTilt, and enableLook).
         */
        enableInputs: Boolean;
        /**
         * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.
This flag only applies in 2D and Columbus view modes.
         */
        enableTranslate: Boolean;
        /**
         * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.
         */
        enableZoom: Boolean;
        /**
         * If true, allows the user to rotate the camera.  If false, the camera is locked to the current heading.
This flag only applies in 2D and 3D.
         */
        enableRotate: Boolean;
        /**
         * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.
This flag only applies in 3D and Columbus view.
         */
        enableTilt: Boolean;
        /**
         * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating
or rotating. This flag only applies in 3D and Columbus view modes.
         */
        enableLook: Boolean;
        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
the camera will continue to spin because of inertia.
With value of zero, the camera will have no inertia.
         */
        inertiaSpin: number;
        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
the camera will continue to translate because of inertia.
With value of zero, the camera will have no inertia.
         */
        inertiaTranslate: number;
        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
the camera will continue to zoom because of inertia.
With value of zero, the camera will have no inertia.
         */
        inertiaZoom: number;
        /**
         * A parameter in the range <code>[0, 1)</code> used to limit the range
of various user inputs to a percentage of the window width/height per animation frame.
This helps keep the camera under control in low-frame-rate situations.
         */
        maximumMovementRatio: number;
        /**
         * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.
         */
        bounceAnimationTime: number;
        /**
         * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 20.0.
         */
        minimumZoomDistance: number;
        /**
         * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.
         */
        maximumZoomDistance: number;
        /**
         * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.
<p>
The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
or an array of any of the preceding.
</p>
         */
        translateEventTypes: number|any[];
        /**
         * The input that allows the user to zoom in/out.
<p>
The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
or an array of any of the preceding.
</p>
         */
        zoomEventTypes: number|any[];
        /**
         * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.
<p>
The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
or an array of any of the preceding.
</p>
         */
        rotateEventTypes: number|any[];
        /**
         * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.
<p>
The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
or an array of any of the preceding.
</p>
         */
        tiltEventTypes: number|any[];
        /**
         * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.
<p>
The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
or an array of any of the preceding.
</p>
         */
        lookEventTypes: number|any[];
        /**
         * The minimum height the camera must be before picking the terrain instead of the ellipsoid.
         */
        minimumPickingTerrainHeight: number;
        /**
         * The minimum height the camera must be before testing for collision with terrain.
         */
        minimumCollisionTerrainHeight: number;
        /**
         * The minimum height the camera must be before switching from rotating a track ball to
free look when clicks originate on the sky on in space.
         */
        minimumTrackBallHeight: number;
        /**
         * Enables or disables camera collision detection with terrain.
         */
        enableCollisionDetection: Boolean;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Removes mouse listeners held by this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Creates a shadow map from the provided light camera.

The normalOffset bias pushes the shadows forward slightly, and may be disabled
for applications that require ultra precise shadows.
     */
    class ShadowMap {
        /**
         * Creates a shadow map from the provided light camera.

The normalOffset bias pushes the shadows forward slightly, and may be disabled
for applications that require ultra precise shadows.
         * @param options  (Required) An object containing the following properties:
         */
        constructor(options: IShadowMapOptions);
        /**
         * Determines the darkness of the shadows.
         */
        darkness: number;
        /**
         * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.
         */
        maximumDistance: number;
        /**
         * Determines if the shadow map will be shown.
         */
        enabled: Boolean;
        /**
         * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.
         */
        softShadows: Boolean;
        /**
         * The width and height, in pixels, of each shadow map.
         */
        size: number;
    }
    /**
     * Provides a single, top-level imagery tile.  The single image is assumed to use a
{@link GeographicTilingScheme}.
     */
    class SingleTileImageryProvider extends ImageryProvider{
        /**
         * Provides a single, top-level imagery tile.  The single image is assumed to use a
{@link GeographicTilingScheme}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ISingleTileImageryProviderOptions);
        /**
         * Gets the URL of the single, top-level imagery tile.
         */
        url: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link SingleTileImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * An atmosphere drawn around the limb of the provided ellipsoid.  Based on
{@link http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}
in GPU Gems 2.
<p>
This is only supported in 3D.  atmosphere is faded out when morphing to 2D or Columbus view.
</p>
     */
    class SkyAtmosphere {
        /**
         * An atmosphere drawn around the limb of the provided ellipsoid.  Based on
{@link http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}
in GPU Gems 2.
<p>
This is only supported in 3D.  atmosphere is faded out when morphing to 2D or Columbus view.
</p>
         * @param ellipsoid  (Optional) The ellipsoid that the atmosphere is drawn around.
         */
        constructor(ellipsoid?: Ellipsoid);
        /**
         * Determines if the atmosphere is shown.
         */
        show: Boolean;
        /**
         * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
A hue shift of 1.0 indicates a complete rotation of the hues available.
         */
        hueShift: number;
        /**
         * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
A saturation shift of -1.0 is monochrome.
         */
        saturationShift: number;
        /**
         * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
A brightness shift of -1.0 is complete darkness, which will let space show through.
         */
        brightnessShift: number;
        /**
         * Gets the ellipsoid the atmosphere is drawn around.
         */
        ellipsoid: Ellipsoid;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
<p>
This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of
the sky box must not exceed {@link Scene#maximumCubeMapSize}.
</p>
     */
    class SkyBox {
        /**
         * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
<p>
This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of
the sky box must not exceed {@link Scene#maximumCubeMapSize}.
</p>
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: ISkyBoxOptions);
        /**
         * The sources used to create the cube map faces: an object
with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,
<code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.
These can be either URLs or <code>Image</code> objects.
         */
        sources: any;
        /**
         * Determines if the sky box will be shown.
         */
        show: Boolean;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Draws a sun billboard.
<p>This is only supported in 3D and Columbus view.</p>
     */
    class Sun {
        /**
         * Draws a sun billboard.
<p>This is only supported in 3D and Columbus view.</p>
         */
        constructor();
        /**
         * Determines if the sun will be shown.
         */
        show: Boolean;
        /**
         * Gets or sets a number that controls how "bright" the Sun's lens flare appears
to be.  Zero shows just the Sun's disc without any flare.
Use larger values for a more pronounced flare around the Sun.
         */
        glowFactor: number;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws
a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for
debugging terrain and imagery rendering problems.
     */
    class TileCoordinatesImageryProvider extends ImageryProvider{
        /**
         * An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws
a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for
debugging terrain and imagery rendering problems.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: ITileCoordinatesImageryProviderOptions);
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
and texture upload time.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * A policy for discarding tile images according to some criteria.  This type describes an
interface and is not intended to be instantiated directly.
     */
    class TileDiscardPolicy {
        /**
         * A policy for discarding tile images according to some criteria.  This type describes an
interface and is not intended to be instantiated directly.
         */
        constructor();
        /**
         * Determines if the discard policy is ready to process images.
         */
        isReady(): Boolean;
        /**
         * Given a tile image, decide whether to discard that image.
         * @param image  (Required) An image to test.
         */
        shouldDiscardImage(image: HTMLImageElement): Boolean;
    }
    /**
     * Provides imagery by requesting tiles using a specified URL template.
     */
    class UrlTemplateImageryProvider extends ImageryProvider{
        /**
         * Provides imagery by requesting tiles using a specified URL template.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IUrlTemplateImageryProviderOptions);
        /**
         * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link UrlTemplateImageryProvider#pickFeatures} will
request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
{@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
features) without communicating with the server.  Set this property to false if you know your data
source does not support picking features or if you don't want this provider's features to be pickable.
         */
        enablePickFeatures: Boolean;
        /**
         * Gets the URL template to use to request tiles.  It has the following keywords:
<ul>
 <li> <code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
 <li> <code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
 <li> <code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
 <li> <code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
 <li> <code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
 <li> <code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
 <li> <code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
 <li> <code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
 <li> <code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
 <li> <code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
 <li> <code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
 <li> <code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
 <li> <code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
 <li> <code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
 <li> <code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
 <li> <code>{width}</code>: The width of each tile in pixels.</li>
 <li> <code>{height}</code>: The height of each tile in pixels.</li>
</ul>
         */
        url: string;
        /**
         * Gets the URL scheme zero padding for each tile coordinate. The format is '000' where each coordinate will be padded on
the left with zeros to match the width of the passed string of zeros. e.g. Setting:
urlSchemeZeroPadding : { '{x}' : '0000'}
will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
It has the following keywords:
<ul>
 <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
 <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
 <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
 <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
 <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
 <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
</ul>
         */
        urlSchemeZeroPadding: any;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested, or undefined if there is no limit.
This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.  This function should
not be called before {@link ImageryProvider#ready} returns true.
         */
        hasAlphaChannel: Boolean;
        /**
         * Reinitializes this instance.  Reinitializing an instance already in use is supported, but it is not
recommended because existing tiles provided by the imagery provider will not be updated.
         * @param options  (Required) Any of the options that may be passed to the {@link UrlTemplateImageryProvider} constructor.
         */
        reinitialize(options: Promise<any>|any): void;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link UrlTemplateImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Asynchronously determines what features, if any, are located at a given longitude and latitude within
a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * A viewport aligned quad.
     */
    class ViewportQuad {
        /**
         * A viewport aligned quad.
         * @param rectangle  (Optional) The {@link BoundingRectangle} defining the quad's position within the viewport.
         * @param material  (Optional) The {@link Material} defining the surface appearance of the viewport quad.
         */
        constructor(rectangle?: BoundingRectangle, material?: Material);
        /**
         * Determines if the viewport quad primitive will be shown.
         */
        show: Boolean;
        /**
         * The BoundingRectangle defining the quad's position within the viewport.
         */
        rectangle: BoundingRectangle;
        /**
         * The surface appearance of the viewport quad.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
{@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.
<p>
The default material is <code>Material.ColorType</code>.
</p>
         */
        material: Material;
        /**
         * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
get the draw commands needed to render this primitive.
<p>
Do not call this function directly.  This is documented just to
list the exceptions that may be propagated when the scene is rendered:
</p>
         */
        update(): void;
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
release of WebGL resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        destroy(): void;
    }
    /**
     * Provides tiled imagery hosted by a Web Map Service (WMS) server.
     */
    class WebMapServiceImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery hosted by a Web Map Service (WMS) server.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IWebMapServiceImageryProviderOptions);
        /**
         * Gets the URL of the WMS server.
         */
        url: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the names of the WMS layers, separated by commas.
         */
        layers: string;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link WebMapServiceImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Asynchronously determines what features, if any, are located at a given longitude and latitude within
a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.
This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.
     */
    class WebMapTileServiceImageryProvider extends ImageryProvider{
        /**
         * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.
This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IWebMapTileServiceImageryProviderOptions);
        /**
         * Gets the URL of the service hosting the imagery.
         */
        url: string;
        /**
         * Gets the proxy used by this provider.
         */
        proxy: Proxy;
        /**
         * Gets the width of each tile, in pixels. This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        tileWidth: number;
        /**
         * Gets the height of each tile, in pixels.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        tileHeight: number;
        /**
         * Gets the maximum level-of-detail that can be requested.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        maximumLevel: number;
        /**
         * Gets the minimum level-of-detail that can be requested.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        minimumLevel: number;
        /**
         * Gets the tiling scheme used by this provider.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        tilingScheme: TilingScheme;
        /**
         * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        rectangle: Rectangle;
        /**
         * Gets the tile discard policy.  If not undefined, the discard policy is responsible
for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
returns undefined, no tiles are filtered.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        tileDiscardPolicy: TileDiscardPolicy;
        /**
         * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
to the event, you will be notified of the error and can potentially recover from it.  Event listeners
are passed an instance of {@link TileProviderError}.
         */
        errorEvent: Event;
        /**
         * Gets the mime type of images returned by this imagery provider.
         */
        format: string;
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         */
        ready: Boolean;
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         */
        readyPromise: Promise<Boolean>;
        /**
         * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
the source of the imagery.  This function should not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         */
        credit: Credit;
        /**
         * Gets a value indicating whether or not the images provided by this imagery provider
include an alpha channel.  If this property is false, an alpha channel, if present, will
be ignored.  If this property is true, any images without an alpha channel will be treated
as if their alpha is 1.0 everywhere.  When this property is false, memory usage
and texture upload time are reduced.
         */
        hasAlphaChannel: Boolean;
        /**
         * Gets the credits to be displayed when a given tile is displayed.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level;
         */
        getTileCredits(x: number, y: number, level: number): Credit[];
        /**
         * Requests the image for a given tile.  This function should
not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         */
        requestImage(x: number, y: number, level: number): Promise<HTMLImageElement|HTMLCanvasElement>;
        /**
         * Picking features is not currently supported by this imagery provider, so this function simply returns
undefined.
         * @param x  (Required) The tile X coordinate.
         * @param y  (Required) The tile Y coordinate.
         * @param level  (Required) The tile level.
         * @param longitude  (Required) The longitude at which to pick features.
         * @param latitude  (Required) The latitude at which to pick features.
         */
        pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<Array<ImageryLayerFeatureInfo>>;
    }
    /**
     * <span style="display: block; text-align: center;">
<img src="images/AnimationWidget.png" width="211" height="142" alt="" />
<br />Animation widget
</span>
<br /><br />
The Animation widget provides buttons for play, pause, and reverse, along with the
current time and date, surrounded by a "shuttle ring" for controlling the speed of animation.
<br /><br />
The "shuttle ring" concept is borrowed from video editing, where typically a
"jog wheel" can be rotated to move past individual animation frames very slowly, and
a surrounding shuttle ring can be twisted to control direction and speed of fast playback.
Cesium typically treats time as continuous (not broken into pre-defined animation frames),
so this widget offers no jog wheel.  Instead, the shuttle ring is capable of both fast and
very slow playback.  Click and drag the shuttle ring pointer itself (shown above in green),
or click in the rest of the ring area to nudge the pointer to the next preset speed in that direction.
<br /><br />
The Animation widget also provides a "realtime" button (in the upper-left) that keeps
animation time in sync with the end user's system clock, typically displaying
"today" or "right now."  This mode is not available in {@link ClockRange.CLAMPED} or
{@link ClockRange.LOOP_STOP} mode if the current time is outside of {@link Clock}'s startTime and endTime.
     */
    class Animation {
        /**
         * <span style="display: block; text-align: center;">
<img src="images/AnimationWidget.png" width="211" height="142" alt="" />
<br />Animation widget
</span>
<br /><br />
The Animation widget provides buttons for play, pause, and reverse, along with the
current time and date, surrounded by a "shuttle ring" for controlling the speed of animation.
<br /><br />
The "shuttle ring" concept is borrowed from video editing, where typically a
"jog wheel" can be rotated to move past individual animation frames very slowly, and
a surrounding shuttle ring can be twisted to control direction and speed of fast playback.
Cesium typically treats time as continuous (not broken into pre-defined animation frames),
so this widget offers no jog wheel.  Instead, the shuttle ring is capable of both fast and
very slow playback.  Click and drag the shuttle ring pointer itself (shown above in green),
or click in the rest of the ring area to nudge the pointer to the next preset speed in that direction.
<br /><br />
The Animation widget also provides a "realtime" button (in the upper-left) that keeps
animation time in sync with the end user's system clock, typically displaying
"today" or "right now."  This mode is not available in {@link ClockRange.CLAMPED} or
{@link ClockRange.LOOP_STOP} mode if the current time is outside of {@link Clock}'s startTime and endTime.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param viewModel  (Required) The view model used by this widget.
         */
        constructor(container: Element|string, viewModel: AnimationViewModel);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: AnimationViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the animation widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
        /**
         * Resizes the widget to match the container size.
This function should be called whenever the container size is changed.
         */
        resize(): void;
        /**
         * Updates the widget to reflect any modified CSS rules for theming.
         */
        applyThemeChanges(): void;
    }
    /**
     * The view model for the {@link Animation} widget.
     */
    class AnimationViewModel {
        /**
         * The view model for the {@link Animation} widget.
         * @param clockViewModel  (Required) The ClockViewModel instance to use.
         */
        constructor(clockViewModel: ClockViewModel);
        /**
         * Gets or sets whether the shuttle ring is currently being dragged.  This property is observable.
         */
        shuttleRingDragging: Boolean;
        /**
         * Gets or sets whether dragging the shuttle ring should cause the multiplier
to snap to the defined tick values rather than interpolating between them.
This property is observable.
         */
        snapToTicks: Boolean;
        /**
         * Gets the string representation of the current time.  This property is observable.
         */
        timeLabel: string;
        /**
         * Gets the string representation of the current date.  This property is observable.
         */
        dateLabel: string;
        /**
         * Gets the string representation of the current multiplier.  This property is observable.
         */
        multiplierLabel: string;
        /**
         * Gets or sets the current shuttle ring angle.  This property is observable.
         */
        shuttleRingAngle: number;
        /**
         * Gets or sets the default date formatter used by new instances.
         */
        defaultDateFormatter: AnimationViewModel.DateFormatter;
        /**
         * Gets or sets the default array of known clock multipliers associated with new instances of the shuttle ring.
         */
        defaultTicks: number[];
        /**
         * Gets or sets the default time formatter used by new instances.
         */
        defaultTimeFormatter: AnimationViewModel.TimeFormatter;
        /**
         * Gets a copy of the array of positive known clock multipliers to associate with the shuttle ring.
         */
        getShuttleRingTicks(): number[];
        /**
         * Sets the array of positive known clock multipliers to associate with the shuttle ring.
These values will have negative equivalents created for them and sets both the minimum
and maximum range of values for the shuttle ring as well as the values that are snapped
to when a single click is made.  The values need not be in order, as they will be sorted
automatically, and duplicate values will be removed.
         * @param positiveTicks  (Required) The list of known positive clock multipliers to associate with the shuttle ring.
         */
        setShuttleRingTicks(positiveTicks: number[]): void;
        /**
         * Gets a command that decreases the speed of animation.
         */
        slower: Command;
        /**
         * Gets a command that increases the speed of animation.
         */
        faster: Command;
        /**
         * Gets the clock view model.
         */
        clockViewModel: ClockViewModel;
        /**
         * Gets the pause toggle button view model.
         */
        pauseViewModel: ToggleButtonViewModel;
        /**
         * Gets the reverse toggle button view model.
         */
        playReverseViewModel: ToggleButtonViewModel;
        /**
         * Gets the play toggle button view model.
         */
        playForwardViewModel: ToggleButtonViewModel;
        /**
         * Gets the realtime toggle button view model.
         */
        playRealtimeViewModel: ToggleButtonViewModel;
        /**
         * Gets or sets the function which formats a date for display.
         */
        dateFormatter: AnimationViewModel.DateFormatter;
        /**
         * Gets or sets the function which formats a time for display.
         */
        timeFormatter: AnimationViewModel.TimeFormatter;
    }
    /**
     * <span style="display: block; text-align: center;">
<img src="images/BaseLayerPicker.png" width="264" height="287" alt="" />
<br />BaseLayerPicker with its drop-panel open.
</span>
<br /><br />
The BaseLayerPicker is a single button widget that displays a panel of available imagery and
terrain providers.  When imagery is selected, the corresponding imagery layer is created and inserted
as the base layer of the imagery collection; removing the existing base.  When terrain is selected,
it replaces the current terrain provider.  Each item in the available providers list contains a name,
a representative icon, and a tooltip to display more information when hovered. The list is initially
empty, and must be configured before use, as illustrated in the below example.
     */
    class BaseLayerPicker {
        /**
         * <span style="display: block; text-align: center;">
<img src="images/BaseLayerPicker.png" width="264" height="287" alt="" />
<br />BaseLayerPicker with its drop-panel open.
</span>
<br /><br />
The BaseLayerPicker is a single button widget that displays a panel of available imagery and
terrain providers.  When imagery is selected, the corresponding imagery layer is created and inserted
as the base layer of the imagery collection; removing the existing base.  When terrain is selected,
it replaces the current terrain provider.  Each item in the available providers list contains a name,
a representative icon, and a tooltip to display more information when hovered. The list is initially
empty, and must be configured before use, as illustrated in the below example.
         * @param container  (Required) The parent HTML container node or ID for this widget.
         * @param options  (Required) Object with the following properties:
         */
        constructor(container: Element|string, options: IBaseLayerPickerOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: BaseLayerPickerViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link BaseLayerPicker}.
     */
    class BaseLayerPickerViewModel {
        /**
         * The view model for {@link BaseLayerPicker}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IBaseLayerPickerViewModelOptions);
        /**
         * Gets or sets an array of ProviderViewModel instances available for imagery selection.
This property is observable.
         */
        imageryProviderViewModels: ProviderViewModel[];
        /**
         * Gets or sets an array of ProviderViewModel instances available for terrain selection.
This property is observable.
         */
        terrainProviderViewModels: ProviderViewModel[];
        /**
         * Gets or sets whether the imagery selection drop-down is currently visible.
         */
        dropDownVisible: Boolean;
        /**
         * Gets the button tooltip.  This property is observable.
         */
        buttonTooltip: string;
        /**
         * Gets the button background image.  This property is observable.
         */
        buttonImageUrl: string;
        /**
         * Gets or sets the currently selected imagery.  This property is observable.
         */
        selectedImagery: ProviderViewModel;
        /**
         * Gets or sets the currently selected terrain.  This property is observable.
         */
        selectedTerrain: ProviderViewModel;
        /**
         * Gets the command to toggle the visibility of the drop down.
         */
        toggleDropDown: Command;
        /**
         * Gets the globe.
         */
        globe: Globe;
    }
    /**
     * A view model that represents each item in the {@link BaseLayerPicker}.
     */
    class ProviderViewModel {
        /**
         * A view model that represents each item in the {@link BaseLayerPicker}.
         * @param options  (Required) The object containing all parameters.
         */
        constructor(options: IProviderViewModelOptions);
        /**
         * Gets the display name.  This property is observable.
         */
        name: string;
        /**
         * Gets the tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets the icon.  This property is observable.
         */
        iconUrl: string;
        /**
         * Gets the Command that creates one or more providers which will be added to
the globe when this item is selected.
         */
        creationCommand: Command;
    }
    /**
     * Inspector widget to aid in debugging
     */
    class CesiumInspector {
        /**
         * Inspector widget to aid in debugging
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param scene  (Required) The Scene instance to use.
         */
        constructor(container: Element|string, scene: Scene);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: CesiumInspectorViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link CesiumInspector}.
     */
    class CesiumInspectorViewModel {
        /**
         * The view model for {@link CesiumInspector}.
         * @param scene  (Required) The scene instance to use.
         */
        constructor(scene: Scene);
        /**
         * Gets or sets the show frustums state.  This property is observable.
         */
        frustums: Boolean;
        /**
         * Gets or sets the show performance display state.  This property is observable.
         */
        performance: Boolean;
        /**
         * Gets or sets the shader cache text.  This property is observable.
         */
        shaderCacheText: string;
        /**
         * Gets or sets the show primitive bounding sphere state.  This property is observable.
         */
        primitiveBoundingSphere: Boolean;
        /**
         * Gets or sets the show primitive reference frame state.  This property is observable.
         */
        primitiveReferenceFrame: Boolean;
        /**
         * Gets or sets the filter primitive state.  This property is observable.
         */
        filterPrimitive: Boolean;
        /**
         * Gets or sets the show tile bounding sphere state.  This property is observable.
         */
        tileBoundingSphere: Boolean;
        /**
         * Gets or sets the filter tile state.  This property is observable.
         */
        filterTile: Boolean;
        /**
         * Gets or sets the show wireframe state.  This property is observable.
         */
        wireframe: Boolean;
        /**
         * Gets or sets the show globe depth state.  This property is observable.
         */
        globeDepth: Boolean;
        /**
         * Gets or sets the show pick depth state.  This property is observable.
         */
        pickDepth: Boolean;
        /**
         * Gets or sets the index of the depth frustum to display.  This property is observable.
         */
        depthFrustum: number;
        /**
         * Gets or sets the index of the depth frustum text.  This property is observable.
         */
        depthFrustumText: string;
        /**
         * Gets or sets the suspend updates state.  This property is observable.
         */
        suspendUpdates: Boolean;
        /**
         * Gets or sets the show tile coordinates state.  This property is observable.
         */
        tileCoordinates: Boolean;
        /**
         * Gets or sets the frustum statistic text.  This property is observable.
         */
        frustumStatisticText: string;
        /**
         * Gets or sets the selected tile information text.  This property is observable.
         */
        tileText: string;
        /**
         * Gets if a primitive has been selected.  This property is observable.
         */
        hasPickedPrimitive: Boolean;
        /**
         * Gets if a tile has been selected.  This property is observable
         */
        hasPickedTile: Boolean;
        /**
         * Gets if the picking primitive command is active.  This property is observable.
         */
        pickPimitiveActive: Boolean;
        /**
         * Gets if the picking tile command is active.  This property is observable.
         */
        pickTileActive: Boolean;
        /**
         * Gets or sets if the cesium inspector drop down is visible.  This property is observable.
         */
        dropDownVisible: Boolean;
        /**
         * Gets or sets if the general section is visible.  This property is observable.
         */
        generalVisible: Boolean;
        /**
         * Gets or sets if the primitive section is visible.  This property is observable.
         */
        primitivesVisible: Boolean;
        /**
         * Gets or sets if the terrain section is visible.  This property is observable.
         */
        terrainVisible: Boolean;
        /**
         * Gets or sets if the text on the general section expand button.  This property is observable.
         */
        generalSwitchText: string;
        /**
         * Gets or sets if the text on the primitive section expand button.  This property is observable.
         */
        primitivesSwitchText: string;
        /**
         * Gets or sets if the text on the terrain section expand button.  This property is observable.
         */
        terrainSwitchText: string;
        /**
         * Gets the scene to control.
         */
        scene: Scene;
        /**
         * Gets the container of the PerformanceDisplay
         */
        performanceContainer: Element;
        /**
         * Gets the command to toggle the visibility of the drop down.
         */
        toggleDropDown: Command;
        /**
         * Gets the command to toggle {@link Scene.debugShowFrustums}
         */
        showFrustums: Command;
        /**
         * Gets the command to toggle the visibility of the performance display.
         */
        showPerformance: Command;
        /**
         * Gets the command to toggle the visibility of a BoundingSphere for a primitive
         */
        showPrimitiveBoundingSphere: Command;
        /**
         * Gets the command to toggle the visibility of a {@link DebugModelMatrixPrimitive} for the model matrix of a primitive
         */
        showPrimitiveReferenceFrame: Command;
        /**
         * Gets the command to toggle a filter that renders only a selected primitive
         */
        doFilterPrimitive: Command;
        /**
         * Gets the command to toggle the view of the Globe as a wireframe
         */
        showWireframe: Command;
        /**
         * Gets the command to toggle the view of the Globe depth buffer
         */
        showGlobeDepth: Command;
        /**
         * Gets the command to toggle the view of the pick depth buffer
         */
        showPickDepth: Command;
        /**
         * Gets the command to increment the depth frustum index to be shown
         */
        incrementDepthFrustum: Command;
        /**
         * Gets the command to decrement the depth frustum index to be shown
         */
        decrementDepthFrustum: Command;
        /**
         * Gets the command to toggle whether to suspend tile updates
         */
        doSuspendUpdates: Command;
        /**
         * Gets the command to toggle the visibility of tile coordinates
         */
        showTileCoordinates: Command;
        /**
         * Gets the command to toggle the visibility of a BoundingSphere for a selected tile
         */
        showTileBoundingSphere: Command;
        /**
         * Gets the command to toggle a filter that renders only a selected tile
         */
        doFilterTile: Command;
        /**
         * Gets the command to expand and collapse the general section
         */
        toggleGeneral: Command;
        /**
         * Gets the command to expand and collapse the primitives section
         */
        togglePrimitives: Command;
        /**
         * Gets the command to expand and collapse the terrain section
         */
        toggleTerrain: Command;
        /**
         * Gets the command to pick a primitive
         */
        pickPrimitive: Command;
        /**
         * Gets the command to pick a tile
         */
        pickTile: Command;
        /**
         * Gets the command to pick a tile
         */
        selectParent: Command;
        /**
         * Gets the command to pick a tile
         */
        selectNW: Command;
        /**
         * Gets the command to pick a tile
         */
        selectNE: Command;
        /**
         * Gets the command to pick a tile
         */
        selectSW: Command;
        /**
         * Gets the command to pick a tile
         */
        selectSE: Command;
        /**
         * Gets or sets the current selected primitive
         */
        primitive: Command;
        /**
         * Gets or sets the current selected tile
         */
        tile: Command;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * A widget containing a Cesium scene.
     */
    class CesiumWidget {
        /**
         * A widget containing a Cesium scene.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(container: Element|string, options?: ICesiumWidgetOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the canvas.
         */
        canvas: HTMLCanvasElement;
        /**
         * Gets the credit container.
         */
        creditContainer: Element;
        /**
         * Gets the scene.
         */
        scene: Scene;
        /**
         * Gets the collection of image layers that will be rendered on the globe.
         */
        imageryLayers: ImageryLayerCollection;
        /**
         * The terrain provider providing surface geometry for the globe.
         */
        terrainProvider: TerrainProvider;
        /**
         * Gets the camera.
         */
        camera: Camera;
        /**
         * Gets the clock.
         */
        clock: Clock;
        /**
         * Gets the screen space event handler.
         */
        screenSpaceEventHandler: ScreenSpaceEventHandler;
        /**
         * Gets or sets the target frame rate of the widget when <code>useDefaultRenderLoop</code>
is true. If undefined, the browser's {@link requestAnimationFrame} implementation
determines the frame rate.  If defined, this value must be greater than 0.  A value higher
than the underlying requestAnimationFrame implementation will have no effect.
         */
        targetFrameRate: number;
        /**
         * Gets or sets whether or not this widget should control the render loop.
If set to true the widget will use {@link requestAnimationFrame} to
perform rendering and resizing of the widget, as well as drive the
simulation clock. If set to false, you must manually call the
<code>resize</code>, <code>render</code> methods as part of a custom
render loop.  If an error occurs during rendering, {@link Scene}'s
<code>renderError</code> event will be raised and this property
will be set to false.  It must be set back to true to continue rendering
after the error.
         */
        useDefaultRenderLoop: Boolean;
        /**
         * Gets or sets a scaling factor for rendering resolution.  Values less than 1.0 can improve
performance on less powerful devices while values greater than 1.0 will render at a higher
resolution and then scale down, resulting in improved visual fidelity.
For example, if the widget is laid out at a size of 640x480, setting this value to 0.5
will cause the scene to be rendered at 320x240 and then scaled up while setting
it to 2.0 will cause the scene to be rendered at 1280x960 and then scaled down.
         */
        resolutionScale: number;
        /**
         * Show an error panel to the user containing a title and a longer error message,
which can be dismissed using an OK button.  This panel is displayed automatically
when a render loop error occurs, if showRenderLoopErrors was not false when the
widget was constructed.
         * @param title  (Required) The title to be displayed on the error panel.  This string is interpreted as text.
         * @param message  (Required) A helpful, user-facing message to display prior to the detailed error information.  This string is interpreted as HTML.
         * @param error  (Optional) The error to be displayed on the error panel.  This string is formatted using {@link formatError} and then displayed as text.
         */
        showErrorPanel(title: string, message: string, error?: string): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
        /**
         * Updates the canvas size, camera aspect ratio, and viewport size.
This function is called automatically as needed unless
<code>useDefaultRenderLoop</code> is set to false.
         */
        resize(): void;
        /**
         * Renders the scene.  This function is called automatically
unless <code>useDefaultRenderLoop</code> is set to false;
         */
        render(): void;
    }
    /**
     * A view model which exposes a {@link Clock} for user interfaces.
     */
    class ClockViewModel {
        /**
         * A view model which exposes a {@link Clock} for user interfaces.
         * @param clock  (Optional) The clock object wrapped by this view model, if undefined a new instance will be created.
         */
        constructor(clock?: Clock);
        /**
         * Gets the current system time.
This property is observable.
         */
        systemTime: JulianDate;
        /**
         * Gets or sets the start time of the clock.
See {@link Clock#startTime}.
This property is observable.
         */
        startTime: JulianDate;
        /**
         * Gets or sets the stop time of the clock.
See {@link Clock#stopTime}.
This property is observable.
         */
        stopTime: JulianDate;
        /**
         * Gets or sets the current time.
See {@link Clock#currentTime}.
This property is observable.
         */
        currentTime: JulianDate;
        /**
         * Gets or sets the clock multiplier.
See {@link Clock#multiplier}.
This property is observable.
         */
        multiplier: number;
        /**
         * Gets or sets the clock step setting.
See {@link Clock#clockStep}.
This property is observable.
         */
        clockStep: number;
        /**
         * Gets or sets the clock range setting.
See {@link Clock#clockRange}.
This property is observable.
         */
        clockRange: number;
        /**
         * Gets or sets whether the clock can animate.
See {@link Clock#canAnimate}.
This property is observable.
         */
        canAnimate: Boolean;
        /**
         * Gets or sets whether the clock should animate.
See {@link Clock#shouldAnimate}.
This property is observable.
         */
        shouldAnimate: Boolean;
        /**
         * Gets the underlying Clock.
         */
        clock: Clock;
        /**
         * Updates the view model with the contents of the underlying clock.
Can be called to force an update of the viewModel if the underlying
clock has changed and <code>Clock.tick</code> has not yet been called.
         */
        synchronize(): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the view model.  Should be called to
properly clean up the view model when it is no longer needed.
         */
        destroy(): void;
    }
    /**
     * A Command is a function with an extra <code>canExecute</code> observable property to determine
whether the command can be executed.  When executed, a Command function will check the
value of <code>canExecute</code> and throw if false.

This type describes an interface and is not intended to be instantiated directly.
See {@link createCommand} to create a command from a function.
     */
    class Command {
        /**
         * A Command is a function with an extra <code>canExecute</code> observable property to determine
whether the command can be executed.  When executed, a Command function will check the
value of <code>canExecute</code> and throw if false.

This type describes an interface and is not intended to be instantiated directly.
See {@link createCommand} to create a command from a function.
         */
        constructor();
        /**
         * Gets whether this command can currently be executed.  This property is observable.
         */
        canExecute: Boolean;
        /**
         * Gets an event which is raised before the command executes, the event
is raised with an object containing two properties: a <code>cancel</code> property,
which if set to false by the listener will prevent the command from being executed, and
an <code>args</code> property, which is the array of arguments being passed to the command.
         */
        beforeExecute: Event;
        /**
         * Gets an event which is raised after the command executes, the event
is raised with the return value of the command as its only parameter.
         */
        afterExecute: Event;
    }
    /**
     * A single button widget for toggling fullscreen mode.
     */
    class FullscreenButton {
        /**
         * A single button widget for toggling fullscreen mode.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param fullscreenElement  (Optional) The element or id to be placed into fullscreen mode.
         */
        constructor(container: Element|string, fullscreenElement?: Element|string);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: FullscreenButtonViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link FullscreenButton}.
     */
    class FullscreenButtonViewModel {
        /**
         * The view model for {@link FullscreenButton}.
         * @param fullscreenElement  (Optional) The element or id to be placed into fullscreen mode.
         */
        constructor(fullscreenElement?: Element|string);
        /**
         * Gets whether or not fullscreen mode is active.  This property is observable.
         */
        isFullscreen: Boolean;
        /**
         * Gets or sets whether or not fullscreen functionality should be enabled.  This property is observable.
         */
        isFullscreenEnabled: Boolean;
        /**
         * Gets the tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets or sets the HTML element to place into fullscreen mode when the
corresponding button is pressed.
         */
        fullscreenElement: Element;
        /**
         * Gets the Command to toggle fullscreen mode.
         */
        command: Command;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the view model.  Should be called to
properly clean up the view model when it is no longer needed.
         */
        destroy(): void;
    }
    /**
     * A widget for finding addresses and landmarks, and flying the camera to them.  Geocoding is
performed using the {@link http://msdn.microsoft.com/en-us/library/ff701715.aspx|Bing Maps Locations API}.
     */
    class Geocoder {
        /**
         * A widget for finding addresses and landmarks, and flying the camera to them.  Geocoding is
performed using the {@link http://msdn.microsoft.com/en-us/library/ff701715.aspx|Bing Maps Locations API}.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGeocoderOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: GeocoderViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for the {@link Geocoder} widget.
     */
    class GeocoderViewModel {
        /**
         * The view model for the {@link Geocoder} widget.
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: IGeocoderViewModelOptions);
        /**
         * Gets or sets a value indicating if this instance should always show its text input field.
         */
        keepExpanded: Boolean;
        /**
         * Gets a value indicating whether a search is currently in progress.  This property is observable.
         */
        isSearchInProgress: Boolean;
        /**
         * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,
and optional height, where longitude and latitude are in degrees and height is in meters.
         */
        searchText: string;
        /**
         * Gets or sets the the duration of the camera flight in seconds.
A value of zero causes the camera to instantly switch to the geocoding location.
The duration will be computed based on the distance when undefined.
         */
        flightDuration: number;
        /**
         * Gets the Bing maps url.
         */
        url: string;
        /**
         * Gets the Bing maps key.
         */
        key: string;
        /**
         * Gets the event triggered on flight completion.
         */
        complete: Event;
        /**
         * Gets the scene to control.
         */
        scene: Scene;
        /**
         * Gets the Command that is executed when the button is clicked.
         */
        search: Command;
    }
    /**
     * A single button widget for returning to the default camera view of the current scene.
     */
    class HomeButton {
        /**
         * A single button widget for returning to the default camera view of the current scene.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param scene  (Required) The Scene instance to use.
         * @param duration  (Optional) The time, in seconds, it takes to complete the camera flight home.
         */
        constructor(container: Element|string, scene: Scene, duration?: number);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: HomeButtonViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link HomeButton}.
     */
    class HomeButtonViewModel {
        /**
         * The view model for {@link HomeButton}.
         * @param scene  (Required) The scene instance to use.
         * @param duration  (Optional) The duration of the camera flight in seconds.
         */
        constructor(scene: Scene, duration?: number);
        /**
         * Gets or sets the tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets the scene to control.
         */
        scene: Scene;
        /**
         * Gets the Command that is executed when the button is clicked.
         */
        command: Command;
        /**
         * Gets or sets the the duration of the camera flight in seconds.
A value of zero causes the camera to instantly switch to home view.
The duration will be computed based on the distance when undefined.
         */
        duration: number;
    }
    /**
     * A widget for displaying information or a description.
     */
    class InfoBox {
        /**
         * A widget for displaying information or a description.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         */
        constructor(container: Element|string);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: InfoBoxViewModel;
        /**
         * Gets the iframe used to display the description.
         */
        frame: HTMLIFrameElement;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link InfoBox}.
     */
    class InfoBoxViewModel {
        /**
         * The view model for {@link InfoBox}.
         */
        constructor();
        /**
         * Gets or sets the maximum height of the info box in pixels.  This property is observable.
         */
        maxHeight: number;
        /**
         * Gets or sets whether the camera tracking icon is enabled.
         */
        enableCamera: Boolean;
        /**
         * Gets or sets the status of current camera tracking of the selected object.
         */
        isCameraTracking: Boolean;
        /**
         * Gets or sets the visibility of the info box.
         */
        showInfo: Boolean;
        /**
         * Gets or sets the title text in the info box.
         */
        titleText: string;
        /**
         * Gets or sets the description HTML for the info box.
         */
        description: string;
        /**
         * Gets the SVG path of the camera icon, which can change to be "crossed out" or not.
         */
        cameraIconPath: string;
        /**
         * Gets the maximum height of sections within the info box, minus an offset, in CSS-ready form.
         * @param offset  (Required) The offset in pixels.
         */
        maxHeightOffset(offset: number): string;
        /**
         * Gets an {@link Event} that is fired when the user clicks the camera icon.
         */
        cameraClicked: Event;
        /**
         * Gets an {@link Event} that is fired when the user closes the info box.
         */
        closeClicked: Event;
    }
    /**
     * <p>The NavigationHelpButton is a single button widget for displaying instructions for
navigating the globe with the mouse.</p><p style="clear: both;"></p><br/>
     */
    class NavigationHelpButton {
        /**
         * <p>The NavigationHelpButton is a single button widget for displaying instructions for
navigating the globe with the mouse.</p><p style="clear: both;"></p><br/>
         * @param options  (Required) Object with the following properties:
         */
        constructor(options: INavigationHelpButtonOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: NavigationHelpButtonViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link NavigationHelpButton}.
     */
    class NavigationHelpButtonViewModel {
        /**
         * The view model for {@link NavigationHelpButton}.
         */
        constructor();
        /**
         * Gets or sets whether the instructions are currently shown.  This property is observable.
         */
        showInstructions: Boolean;
        /**
         * Gets or sets the tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets the Command that is executed when the button is clicked.
         */
        command: Command;
        /**
         * Gets the Command that is executed when the mouse instructions should be shown.
         */
        showClick: Command;
        /**
         * Gets the Command that is executed when the touch instructions should be shown.
         */
        showTouch: Command;
    }
    /**
     * Monitors performance of the application and displays a message if poor performance is detected.
     */
    class PerformanceWatchdog {
        /**
         * Monitors performance of the application and displays a message if poor performance is detected.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPerformanceWatchdogOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: PerformanceWatchdogViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link PerformanceWatchdog}.
     */
    class PerformanceWatchdogViewModel {
        /**
         * The view model for {@link PerformanceWatchdog}.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(options?: IPerformanceWatchdogViewModelOptions);
        /**
         * Gets or sets the message to display when a low frame rate is detected.  This string will be interpreted as HTML.
         */
        lowFrameRateMessage: string;
        /**
         * Gets or sets a value indicating whether the low frame rate message has previously been dismissed by the user.  If it has
been dismissed, the message will not be redisplayed, no matter the frame rate.
         */
        lowFrameRateMessageDismissed: Boolean;
        /**
         * Gets or sets a value indicating whether the low frame rate message is currently being displayed.
         */
        showingLowFrameRateMessage: Boolean;
        /**
         * Gets the {@link Scene} instance for which to monitor performance.
         */
        scene: Scene;
        /**
         * Gets a command that dismisses the low frame rate message.  Once it is dismissed, the message
will not be redisplayed.
         */
        dismissMessage: Command;
    }
    /**
     * <img src="images/sceneModePicker.png" style="float: left; margin-right: 10px;" width="44" height="116" />
<p>The SceneModePicker is a single button widget for switching between scene modes;
shown to the left in its expanded state. Programatic switching of scene modes will
be automatically reflected in the widget as long as the specified Scene
is used to perform the change.</p><p style="clear: both;"></p><br/>
     */
    class SceneModePicker {
        /**
         * <img src="images/sceneModePicker.png" style="float: left; margin-right: 10px;" width="44" height="116" />
<p>The SceneModePicker is a single button widget for switching between scene modes;
shown to the left in its expanded state. Programatic switching of scene modes will
be automatically reflected in the widget as long as the specified Scene
is used to perform the change.</p><p style="clear: both;"></p><br/>
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param scene  (Required) The Scene instance to use.
         * @param duration  (Optional) The time, in seconds, it takes for the scene to transition.
         */
        constructor(container: Element|string, scene: Scene, duration?: number);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: SceneModePickerViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link SceneModePicker}.
     */
    class SceneModePickerViewModel {
        /**
         * The view model for {@link SceneModePicker}.
         * @param scene  (Required) The Scene to morph
         * @param duration  (Optional) The duration of scene morph animations, in seconds
         */
        constructor(scene: Scene, duration?: number);
        /**
         * Gets or sets the current SceneMode.  This property is observable.
         */
        sceneMode: number;
        /**
         * Gets or sets whether the button drop-down is currently visible.  This property is observable.
         */
        dropDownVisible: Boolean;
        /**
         * Gets or sets the 2D tooltip.  This property is observable.
         */
        tooltip2D: string;
        /**
         * Gets or sets the 3D tooltip.  This property is observable.
         */
        tooltip3D: string;
        /**
         * Gets or sets the Columbus View tooltip.  This property is observable.
         */
        tooltipColumbusView: string;
        /**
         * Gets the currently active tooltip.  This property is observable.
         */
        selectedTooltip: string;
        /**
         * Gets the scene
         */
        scene: Scene;
        /**
         * Gets or sets the the duration of scene mode transition animations in seconds.
A value of zero causes the scene to instantly change modes.
         */
        duration: number;
        /**
         * Gets the command to toggle the drop down box.
         */
        toggleDropDown: Command;
        /**
         * Gets the command to morph to 2D.
         */
        morphTo2D: Command;
        /**
         * Gets the command to morph to 3D.
         */
        morphTo3D: Command;
        /**
         * Gets the command to morph to Columbus View.
         */
        morphToColumbusView: Command;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the view model.
         */
        destroy(): void;
    }
    /**
     * A widget for displaying an indicator on a selected object.
     */
    class SelectionIndicator {
        /**
         * A widget for displaying an indicator on a selected object.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param scene  (Required) The Scene instance to use.
         */
        constructor(container: Element|string, scene: Scene);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: SelectionIndicatorViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link SelectionIndicator}.
     */
    class SelectionIndicatorViewModel {
        /**
         * The view model for {@link SelectionIndicator}.
         * @param scene  (Required) The scene instance to use for screen-space coordinate conversion.
         * @param selectionIndicatorElement  (Required) The element containing all elements that make up the selection indicator.
         * @param container  (Required) The DOM element that contains the widget.
         */
        constructor(scene: Scene, selectionIndicatorElement: Element, container: Element);
        /**
         * Gets or sets the world position of the object for which to display the selection indicator.
         */
        position: Cartesian3;
        /**
         * Gets or sets the visibility of the selection indicator.
         */
        showSelection: Boolean;
        /**
         * Gets the visibility of the position indicator.  This can be false even if an
object is selected, when the selected object has no position.
         */
        isVisible: Boolean;
        /**
         * Gets or sets the function for converting the world position of the object to the screen space position.
         */
        computeScreenSpacePosition: SelectionIndicatorViewModel.ComputeScreenSpacePosition;
        /**
         * Updates the view of the selection indicator to match the position and content properties of the view model.
This function should be called as part of the render loop.
         */
        update(): void;
        /**
         * Animate the indicator to draw attention to the selection.
         */
        animateAppear(): void;
        /**
         * Animate the indicator to release the selection.
         */
        animateDepart(): void;
        /**
         * Gets the HTML element containing the selection indicator.
         */
        container: Element;
        /**
         * Gets the HTML element that holds the selection indicator.
         */
        selectionIndicatorElement: Element;
        /**
         * Gets the scene being used.
         */
        scene: Scene;
    }
    /**
     * The Timeline is a widget for displaying and controlling the current scene time.
     */
    class Timeline {
        /**
         * The Timeline is a widget for displaying and controlling the current scene time.
         * @param container  (Required) The parent HTML container node for this widget.
         * @param clock  (Required) The clock to use.
         */
        constructor(container: Element, clock: Clock);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
        /**
         * Sets the view to the provided times.
         * @param startTime  (Required) The start time.
         * @param stopTime  (Required) The stop time.
         */
        zoomTo(startTime: JulianDate, stopTime: JulianDate): void;
        /**
         * Resizes the widget to match the container size.
         */
        resize(): void;
    }
    /**
     * A view model which exposes the properties of a toggle button.
     */
    class ToggleButtonViewModel {
        /**
         * A view model which exposes the properties of a toggle button.
         * @param command  (Required) The command which will be executed when the button is toggled.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(command: Command, options?: IToggleButtonViewModelOptions);
        /**
         * Gets or sets whether the button is currently toggled.  This property is observable.
         */
        toggled: Boolean;
        /**
         * Gets or sets the button's tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets the command which will be executed when the button is toggled.
         */
        command: Command;
    }
    /**
     * A base widget for building applications.  It composites all of the standard Cesium widgets into one reusable package.
The widget can always be extended by using mixins, which add functionality useful for a variety of applications.
     */
    class Viewer {
        /**
         * A base widget for building applications.  It composites all of the standard Cesium widgets into one reusable package.
The widget can always be extended by using mixins, which add functionality useful for a variety of applications.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param options  (Optional) Object with the following properties:
         */
        constructor(container: Element|string, options?: IViewerOptions);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the DOM element for the area at the bottom of the window containing the
{@link CreditDisplay} and potentially other things.
         */
        bottomContainer: Element;
        /**
         * Gets the CesiumWidget.
         */
        cesiumWidget: CesiumWidget;
        /**
         * Gets the selection indicator.
         */
        selectionIndicator: SelectionIndicator;
        /**
         * Gets the info box.
         */
        infoBox: InfoBox;
        /**
         * Gets the Geocoder.
         */
        geocoder: Geocoder;
        /**
         * Gets the HomeButton.
         */
        homeButton: HomeButton;
        /**
         * Gets the SceneModePicker.
         */
        sceneModePicker: SceneModePicker;
        /**
         * Gets the BaseLayerPicker.
         */
        baseLayerPicker: BaseLayerPicker;
        /**
         * Gets the NavigationHelpButton.
         */
        navigationHelpButton: NavigationHelpButton;
        /**
         * Gets the Animation widget.
         */
        animation: Animation;
        /**
         * Gets the Timeline widget.
         */
        timeline: Timeline;
        /**
         * Gets the FullscreenButton.
         */
        fullscreenButton: FullscreenButton;
        /**
         * Gets the VRButton.
         */
        vrButton: VRButton;
        /**
         * Gets the display used for {@link DataSource} visualization.
         */
        dataSourceDisplay: DataSourceDisplay;
        /**
         * Gets the collection of entities not tied to a particular data source.
This is a shortcut to [dataSourceDisplay.defaultDataSource.entities]{@link Viewer#dataSourceDisplay}.
         */
        entities: EntityCollection;
        /**
         * Gets the set of {@link DataSource} instances to be visualized.
         */
        dataSources: DataSourceCollection;
        /**
         * Gets the canvas.
         */
        canvas: HTMLCanvasElement;
        /**
         * Gets the Cesium logo element.
         */
        cesiumLogo: Element;
        /**
         * Gets the scene.
         */
        scene: Scene;
        /**
         * Determines if shadows are cast by the sun.
         */
        shadows: Boolean;
        /**
         * Determines if the terrain casts or shadows from the sun.
         */
        terrainShadows: number;
        /**
         * Get the scene's shadow map
         */
        shadowMap: ShadowMap;
        /**
         * Gets the collection of image layers that will be rendered on the globe.
         */
        imageryLayers: ImageryLayerCollection;
        /**
         * The terrain provider providing surface geometry for the globe.
         */
        terrainProvider: TerrainProvider;
        /**
         * Gets the camera.
         */
        camera: Camera;
        /**
         * Gets the clock.
         */
        clock: Clock;
        /**
         * Gets the screen space event handler.
         */
        screenSpaceEventHandler: ScreenSpaceEventHandler;
        /**
         * Gets or sets the target frame rate of the widget when <code>useDefaultRenderLoop</code>
is true. If undefined, the browser's {@link requestAnimationFrame} implementation
determines the frame rate.  If defined, this value must be greater than 0.  A value higher
than the underlying requestAnimationFrame implementation will have no effect.
         */
        targetFrameRate: number;
        /**
         * Gets or sets whether or not this widget should control the render loop.
If set to true the widget will use {@link requestAnimationFrame} to
perform rendering and resizing of the widget, as well as drive the
simulation clock. If set to false, you must manually call the
<code>resize</code>, <code>render</code> methods
as part of a custom render loop.  If an error occurs during rendering, {@link Scene}'s
<code>renderError</code> event will be raised and this property
will be set to false.  It must be set back to true to continue rendering
after the error.
         */
        useDefaultRenderLoop: Boolean;
        /**
         * Gets or sets a scaling factor for rendering resolution.  Values less than 1.0 can improve
performance on less powerful devices while values greater than 1.0 will render at a higher
resolution and then scale down, resulting in improved visual fidelity.
For example, if the widget is laid out at a size of 640x480, setting this value to 0.5
will cause the scene to be rendered at 320x240 and then scaled up while setting
it to 2.0 will cause the scene to be rendered at 1280x960 and then scaled down.
         */
        resolutionScale: number;
        /**
         * Gets or sets whether or not data sources can temporarily pause
animation in order to avoid showing an incomplete picture to the user.
For example, if asynchronous primitives are being processed in the
background, the clock will not advance until the geometry is ready.
         */
        allowDataSourcesToSuspendAnimation: Boolean;
        /**
         * Gets or sets the Entity instance currently being tracked by the camera.
         */
        trackedEntity: Entity;
        /**
         * Gets or sets the object instance for which to display a selection indicator.
         */
        selectedEntity: Entity;
        /**
         * Extends the base viewer functionality with the provided mixin.
A mixin may add additional properties, functions, or other behavior
to the provided viewer instance.
         * @param mixin  (Required) The Viewer mixin to add to this instance.
         * @param options  (Optional) The options object to be passed to the mixin function.
         */
        extend(mixin: Viewer.ViewerMixin, options?: any): void;
        /**
         * Resizes the widget to match the container size.
This function is called automatically as needed unless
<code>useDefaultRenderLoop</code> is set to false.
         */
        resize(): void;
        /**
         * This forces the widget to re-think its layout, including
widget sizes and credit placement.
         */
        forceResize(): void;
        /**
         * Renders the scene.  This function is called automatically
unless <code>useDefaultRenderLoop</code> is set to false;
         */
        render(): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
        /**
         * Asynchronously sets the camera to view the provided target
         */
        zoomTo(target: any, offset?: HeadingPitchRange): Promise<Boolean>;
        /**
         * Flies the camera to the provided target
         */
        flyTo(target: any, options?: Viewer.IViewerFlyToOptions): Promise<Boolean>;
    }
    /**
     * A single button widget for toggling vr mode.
     */
    class VRButton {
        /**
         * A single button widget for toggling vr mode.
         * @param container  (Required) The DOM element or ID that will contain the widget.
         * @param scene  (Required) The scene.
         * @param vrElement  (Optional) The element or id to be placed into vr mode.
         */
        constructor(container: Element|string, scene: Scene, vrElement?: Element|string);
        /**
         * Gets the parent container.
         */
        container: Element;
        /**
         * Gets the view model.
         */
        viewModel: VRButtonViewModel;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the widget.  Should be called if permanently
removing the widget from layout.
         */
        destroy(): void;
    }
    /**
     * The view model for {@link VRButton}.
     */
    class VRButtonViewModel {
        /**
         * The view model for {@link VRButton}.
         * @param scene  (Required) The scene.
         * @param vrElement  (Optional) The element or id to be placed into VR mode.
         */
        constructor(scene: Scene, vrElement?: Element|string);
        /**
         * Gets whether or not VR mode is active.
         */
        isVRMode: Boolean;
        /**
         * Gets or sets whether or not VR functionality should be enabled.
         */
        isVREnabled: Boolean;
        /**
         * Gets the tooltip.  This property is observable.
         */
        tooltip: string;
        /**
         * Gets or sets the HTML element to place into VR mode when the
corresponding button is pressed.
         */
        vrElement: Element;
        /**
         * Gets the Command to toggle VR mode.
         */
        command: Command;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        isDestroyed(): Boolean;
        /**
         * Destroys the view model.  Should be called to
properly clean up the view model when it is no longer needed.
         */
        destroy(): void;
    }
    interface IWriteTextToCanvasOptions {
        /**
         * The CSS font to use.
         */
        font?: string;
        /**
         * The baseline of the text.
         */
        textBaseline?: string;
        /**
         * Whether to fill the text.
         */
        fill?: Boolean;
        /**
         * Whether to stroke the text.
         */
        stroke?: Boolean;
        /**
         * The fill color.
         */
        fillColor?: number;
        /**
         * The stroke color.
         */
        strokeColor?: number;
        /**
         * The stroke width.
         */
        strokeWidth?: number;
        /**
         * The background color of the canvas.
         */
        backgroundColor?: number;
        /**
         * The pixel size of the padding to add around the text.
         */
        padding?: number;
    }
    interface IArcGisImageServerTerrainProviderOptions {
        /**
         * The URL of the ArcGIS ImageServer service.
         */
        url: string;
        /**
         * The authorization token to use to connect to the service.
         */
        token?: string;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: any;
        /**
         * The tiling scheme specifying how the terrain
                      is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
                      is used.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
                   this parameter is ignored and the tiling scheme's ellipsoid is used instead.
                   If neither parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The credit, which will is displayed on the canvas.
         */
        credit?: Credit|string;
    }
    interface IBoxGeometryOptions {
        /**
         * The minimum x, y, and z coordinates of the box.
         */
        minimum: Cartesian3;
        /**
         * The maximum x, y, and z coordinates of the box.
         */
        maximum: Cartesian3;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface IBoxOutlineGeometryOptions {
        /**
         * The minimum x, y, and z coordinates of the box.
         */
        minimum: Cartesian3;
        /**
         * The maximum x, y, and z coordinates of the box.
         */
        maximum: Cartesian3;
    }
    interface ICatmullRomSplineOptions {
        /**
         * An array of strictly increasing, unit-less, floating-point times at each point.
               The values are in no way connected to the clock time. They are the parameterization for the curve.
         */
        times: number[];
        /**
         * The array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
        /**
         * The tangent of the curve at the first control point.
                    If the tangent is not given, it will be estimated.
         */
        firstTangent?: Cartesian3;
        /**
         * The tangent of the curve at the last control point.
                    If the tangent is not given, it will be estimated.
         */
        lastTangent?: Cartesian3;
    }
    interface ICesiumTerrainProviderOptions {
        /**
         * The URL of the Cesium terrain server.
         */
        url: string;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: Proxy;
        /**
         * Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.
         */
        requestVertexNormals?: Boolean;
        /**
         * Flag that indicates if the client should request per tile water masks from the server,  if available.
         */
        requestWaterMask?: Boolean;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
    }
    interface ICircleGeometryOptions {
        /**
         * The circle's center point in the fixed frame.
         */
        center: Cartesian3;
        /**
         * The radius in meters.
         */
        radius: number;
        /**
         * The ellipsoid the circle will be on.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance in meters between the circle and the ellipsoid surface.
         */
        height?: number;
        /**
         * The angular distance between points on the circle in radians.
         */
        granularity?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * The distance in meters between the circle's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
         */
        stRotation?: number;
    }
    interface ICircleOutlineGeometryOptions {
        /**
         * The circle's center point in the fixed frame.
         */
        center: Cartesian3;
        /**
         * The radius in meters.
         */
        radius: number;
        /**
         * The ellipsoid the circle will be on.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance in meters between the circle and the ellipsoid surface.
         */
        height?: number;
        /**
         * The angular distance between points on the circle in radians.
         */
        granularity?: number;
        /**
         * The distance in meters between the circle's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * number of lines to draw between the top and bottom of an extruded circle.
         */
        numberOfVerticalLines?: number;
    }
    interface IClockOptions {
        /**
         * The start time of the clock.
         */
        startTime?: JulianDate;
        /**
         * The stop time of the clock.
         */
        stopTime?: JulianDate;
        /**
         * The current time.
         */
        currentTime?: JulianDate;
        /**
         * Determines how much time advances when {@link Clock#tick} is called, negative values allow for advancing backwards.
         */
        multiplier?: number;
        /**
         * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
         */
        clockStep?: number;
        /**
         * Determines how the clock should behave when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
         */
        clockRange?: number;
        /**
         * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
         */
        canAnimate?: Boolean;
        /**
         * Indicates whether {@link Clock#tick} should attempt to advance time.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
         */
        shouldAnimate?: Boolean;
    }
    interface ICorridorGeometryOptions {
        /**
         * An array of positions that define the center of the corridor.
         */
        positions: Cartesian3[];
        /**
         * The distance between the edges of the corridor in meters.
         */
        width: number;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The distance in meters between the ellipsoid surface and the positions.
         */
        height?: number;
        /**
         * The distance in meters between the ellipsoid surface and the extruded face.
         */
        extrudedHeight?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * Determines the style of the corners.
         */
        cornerType?: number;
    }
    interface ICorridorOutlineGeometryOptions {
        /**
         * An array of positions that define the center of the corridor outline.
         */
        positions: Cartesian3[];
        /**
         * The distance between the edges of the corridor outline.
         */
        width: number;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The distance in meters between the positions and the ellipsoid surface.
         */
        height?: number;
        /**
         * The distance in meters between the extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * Determines the style of the corners.
         */
        cornerType?: number;
    }
    interface ICylinderGeometryOptions {
        /**
         * The length of the cylinder.
         */
        length: number;
        /**
         * The radius of the top of the cylinder.
         */
        topRadius: number;
        /**
         * The radius of the bottom of the cylinder.
         */
        bottomRadius: number;
        /**
         * The number of edges around the perimeter of the cylinder.
         */
        slices?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface ICylinderOutlineGeometryOptions {
        /**
         * The length of the cylinder.
         */
        length: number;
        /**
         * The radius of the top of the cylinder.
         */
        topRadius: number;
        /**
         * The radius of the bottom of the cylinder.
         */
        bottomRadius: number;
        /**
         * The number of edges around the perimeter of the cylinder.
         */
        slices?: number;
        /**
         * number of lines to draw between the top and bottom surfaces of the cylinder.
         */
        numberOfVerticalLines?: number;
    }
    interface IEllipseGeometryOptions {
        /**
         * The ellipse's center point in the fixed frame.
         */
        center: Cartesian3;
        /**
         * The length of the ellipse's semi-major axis in meters.
         */
        semiMajorAxis: number;
        /**
         * The length of the ellipse's semi-minor axis in meters.
         */
        semiMinorAxis: number;
        /**
         * The ellipsoid the ellipse will be on.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance in meters between the ellipse and the ellipsoid surface.
         */
        height?: number;
        /**
         * The distance in meters between the ellipse's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * The angle of rotation counter-clockwise from north.
         */
        rotation?: number;
        /**
         * The rotation of the texture coordinates counter-clockwise from north.
         */
        stRotation?: number;
        /**
         * The angular distance between points on the ellipse in radians.
         */
        granularity?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface IEllipseOutlineGeometryOptions {
        /**
         * The ellipse's center point in the fixed frame.
         */
        center: Cartesian3;
        /**
         * The length of the ellipse's semi-major axis in meters.
         */
        semiMajorAxis: number;
        /**
         * The length of the ellipse's semi-minor axis in meters.
         */
        semiMinorAxis: number;
        /**
         * The ellipsoid the ellipse will be on.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance in meters between the ellipse and the ellipsoid surface.
         */
        height?: number;
        /**
         * The distance in meters between the ellipse's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * The angle from north (counter-clockwise) in radians.
         */
        rotation?: number;
        /**
         * The angular distance between points on the ellipse in radians.
         */
        granularity?: number;
        /**
         * number of lines to draw between the top and bottom surface of an extruded ellipse.
         */
        numberOfVerticalLines?: number;
    }
    interface IEllipsoidGeometryOptions {
        /**
         * The radii of the ellipsoid in the x, y, and z directions.
         */
        radii?: Cartesian3;
        /**
         * The number of times to partition the ellipsoid into stacks.
         */
        stackPartitions?: number;
        /**
         * The number of times to partition the ellipsoid into radial slices.
         */
        slicePartitions?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface IEllipsoidOutlineGeometryOptions {
        /**
         * The radii of the ellipsoid in the x, y, and z directions.
         */
        radii?: Cartesian3;
        /**
         * The count of stacks for the ellipsoid (1 greater than the number of parallel lines).
         */
        stackPartitions?: number;
        /**
         * The count of slices for the ellipsoid (Equal to the number of radial lines).
         */
        slicePartitions?: number;
        /**
         * The number of points per line, determining the granularity of the curvature.
         */
        subdivisions?: number;
    }
    interface IEllipsoidTerrainProviderOptions {
        /**
         * The tiling scheme specifying how the ellipsoidal
surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
is used.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
    }
    interface IGeographicTilingSchemeOptions {
        /**
         * The ellipsoid whose surface is being tiled. Defaults to
the WGS84 ellipsoid.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The rectangle, in radians, covered by the tiling scheme.
         */
        rectangle?: Rectangle;
        /**
         * The number of tiles in the X direction at level zero of
the tile tree.
         */
        numberOfLevelZeroTilesX?: number;
        /**
         * The number of tiles in the Y direction at level zero of
the tile tree.
         */
        numberOfLevelZeroTilesY?: number;
    }
    interface IGeometryOptions {
        /**
         * Attributes, which make up the geometry's vertices.
         */
        attributes: GeometryAttributes;
        /**
         * The type of primitives in the geometry.
         */
        primitiveType?: number;
        /**
         * Optional index data that determines the primitives in the geometry.
         */
        indices?: Uint16Array|Uint32Array;
        /**
         * An optional bounding sphere that fully enclosed the geometry.
         */
        boundingSphere?: BoundingSphere;
    }
    interface IGeometryAttributeOptions {
        /**
         * The datatype of each component in the attribute, e.g., individual elements in values.
         */
        componentDatatype?: number;
        /**
         * A number between 1 and 4 that defines the number of components in an attributes.
         */
        componentsPerAttribute?: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         */
        normalize?: Boolean;
        /**
         * The values for the attributes stored in a typed array.
         */
        values?: TypedArray;
    }
    interface IGeometryInstanceOptions {
        /**
         * The geometry to instance.
         */
        geometry: Geometry;
        /**
         * The model matrix that transforms to transform the geometry from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.
         */
        id?: any;
        /**
         * Per-instance attributes like a show or color attribute shown in the example below.
         */
        attributes?: any;
    }
    interface IGeometryInstanceAttributeOptions {
        /**
         * The datatype of each component in the attribute, e.g., individual elements in values.
         */
        componentDatatype?: number;
        /**
         * A number between 1 and 4 that defines the number of components in an attributes.
         */
        componentsPerAttribute?: number;
        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         */
        normalize?: Boolean;
        /**
         * The value for the attribute.
         */
        value?: number[];
    }
    interface IHeightmapTerrainDataOptions {
        /**
         * The buffer containing height data.
         */
        buffer: TypedArray;
        /**
         * The width (longitude direction) of the heightmap, in samples.
         */
        width: number;
        /**
         * The height (latitude direction) of the heightmap, in samples.
         */
        height: number;
        /**
         * A bit mask indicating which of this tile's four children exist.
                If a child's bit is set, geometry will be requested for that tile as well when it
                is needed.  If the bit is cleared, the child tile is not requested and geometry is
                instead upsampled from the parent.  The bit values are as follows:
                <table>
                 <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
                 <tr><td>0</td><td>1</td><td>Southwest</td></tr>
                 <tr><td>1</td><td>2</td><td>Southeast</td></tr>
                 <tr><td>2</td><td>4</td><td>Northwest</td></tr>
                 <tr><td>3</td><td>8</td><td>Northeast</td></tr>
                </table>
         */
        childTileMask?: number;
        /**
         * An object describing the structure of the height data.
         */
        structure?: any;
        /**
         * The factor by which to multiply height samples in order to obtain
                the height above the heightOffset, in meters.  The heightOffset is added to the resulting
                height after multiplying by the scale.
         */
        heightScale?: number;
        /**
         * The offset to add to the scaled height to obtain the final
                height in meters.  The offset is added after the height sample is multiplied by the
                heightScale.
         */
        heightOffset?: number;
        /**
         * The number of elements in the buffer that make up a single height
                sample.  This is usually 1, indicating that each element is a separate height sample.  If
                it is greater than 1, that number of elements together form the height sample, which is
                computed according to the structure.elementMultiplier and structure.isBigEndian properties.
         */
        elementsPerHeight?: number;
        /**
         * The number of elements to skip to get from the first element of
                one height to the first element of the next height.
         */
        stride?: number;
        /**
         * The multiplier used to compute the height value when the
                stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier
                is 256, the height is computed as follows:
                `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`
                This is assuming that the isBigEndian property is false.  If it is true, the order of the
                elements is reversed.
         */
        elementMultiplier?: number;
        /**
         * Indicates endianness of the elements in the buffer when the
                 stride property is greater than 1.  If this property is false, the first element is the
                 low-order element.  If it is true, the first element is the high-order element.
         */
        isBigEndian?: Boolean;
        /**
         * The lowest value that can be stored in the height buffer.  Any heights that are lower
                than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
                buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is
                not specified, no minimum value is enforced.
         */
        lowestEncodedHeight?: number;
        /**
         * The highest value that can be stored in the height buffer.  Any heights that are higher
                than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
                buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger
                than 65535.  If this parameter is not specified, no maximum value is enforced.
         */
        highestEncodedHeight?: number;
        /**
         * True if this instance was created by upsampling another instance;
                 otherwise, false.
         */
        createdByUpsampling?: Boolean;
    }
    interface IHermiteSplineOptions {
        /**
         * An array of strictly increasing, unit-less, floating-point times at each point.
               The values are in no way connected to the clock time. They are the parameterization for the curve.
         */
        times: number[];
        /**
         * The array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
        /**
         * The array of {@link Cartesian3} incoming tangents at each control point.
         */
        inTangents: Cartesian3[];
        /**
         * The array of {@link Cartesian3} outgoing tangents at each control point.
         */
        outTangents: Cartesian3[];
    }
    interface ILinearSplineOptions {
        /**
         * An array of strictly increasing, unit-less, floating-point times at each point.
               The values are in no way connected to the clock time. They are the parameterization for the curve.
         */
        times: number[];
        /**
         * The array of {@link Cartesian3} control points.
         */
        points: Cartesian3[];
    }
    interface IPolygonGeometryOptions {
        /**
         * A polygon hierarchy that can include holes.
         */
        polygonHierarchy: PolygonHierarchy;
        /**
         * The distance in meters between the polygon and the ellipsoid surface.
         */
        height?: number;
        /**
         * The distance in meters between the polygon's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
         */
        stRotation?: number;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * Use the height of options.positions for each position instead of using options.height to determine the height.
         */
        perPositionHeight?: Boolean;
        /**
         * When false, leaves off the top of an extruded polygon open.
         */
        closeTop?: Boolean;
        /**
         * When false, leaves off the bottom of an extruded polygon open.
         */
        closeBottom?: Boolean;
    }
    interface IPolygonOutlineGeometryOptions {
        /**
         * A polygon hierarchy that can include holes.
         */
        polygonHierarchy: PolygonHierarchy;
        /**
         * The distance in meters between the polygon and the ellipsoid surface.
         */
        height?: number;
        /**
         * The distance in meters between the polygon's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * Use the height of options.positions for each position instead of using options.height to determine the height.
         */
        perPositionHeight?: Boolean;
    }
    interface IPolylineGeometryOptions {
        /**
         * An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
         */
        positions: Cartesian3[];
        /**
         * The width in pixels.
         */
        width?: number;
        /**
         * An Array of {@link Color} defining the per vertex or per segment colors.
         */
        colors?: Color[];
        /**
         * A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
         */
        colorsPerVertex?: Boolean;
        /**
         * A boolean that determines whether positions will be adjusted to the surface of the ellipsoid via a great arc.
         */
        followSurface?: Boolean;
        /**
         * The distance, in radians, between each latitude and longitude if options.followSurface=true. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
    }
    interface IPolylineVolumeGeometryOptions {
        /**
         * An array of {@link Cartesain3} positions that define the center of the polyline volume.
         */
        polylinePositions: Cartesian3[];
        /**
         * An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline
         */
        shapePositions: Cartesian2[];
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * Determines the style of the corners.
         */
        cornerType?: number;
    }
    interface IPolylineVolumeOutlineGeometryOptions {
        /**
         * An array of positions that define the center of the polyline volume.
         */
        polylinePositions: Cartesian3[];
        /**
         * An array of positions that define the shape to be extruded along the polyline
         */
        shapePositions: Cartesian2[];
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * Determines the style of the corners.
         */
        cornerType?: number;
    }
    interface IQuantizedMeshTerrainDataOptions {
        /**
         * The buffer containing the quantized mesh.
         */
        quantizedVertices: Uint16Array;
        /**
         * The indices specifying how the quantized vertices are linked
                     together into triangles.  Each three indices specifies one triangle.
         */
        indices: Uint16Array|Uint32Array;
        /**
         * The minimum terrain height within the tile, in meters above the ellipsoid.
         */
        minimumHeight: number;
        /**
         * The maximum terrain height within the tile, in meters above the ellipsoid.
         */
        maximumHeight: number;
        /**
         * A sphere bounding all of the vertices in the mesh.
         */
        boundingSphere: BoundingSphere;
        /**
         * An OrientedBoundingBox bounding all of the vertices in the mesh.
         */
        orientedBoundingBox?: OrientedBoundingBox;
        /**
         * The horizon occlusion point of the mesh.  If this point
                     is below the horizon, the entire tile is assumed to be below the horizon as well.
                     The point is expressed in ellipsoid-scaled coordinates.
         */
        horizonOcclusionPoint: Cartesian3;
        /**
         * The indices of the vertices on the western edge of the tile.
         */
        westIndices: number[];
        /**
         * The indices of the vertices on the southern edge of the tile.
         */
        southIndices: number[];
        /**
         * The indices of the vertices on the eastern edge of the tile.
         */
        eastIndices: number[];
        /**
         * The indices of the vertices on the northern edge of the tile.
         */
        northIndices: number[];
        /**
         * The height of the skirt to add on the western edge of the tile.
         */
        westSkirtHeight: number;
        /**
         * The height of the skirt to add on the southern edge of the tile.
         */
        southSkirtHeight: number;
        /**
         * The height of the skirt to add on the eastern edge of the tile.
         */
        eastSkirtHeight: number;
        /**
         * The height of the skirt to add on the northern edge of the tile.
         */
        northSkirtHeight: number;
        /**
         * A bit mask indicating which of this tile's four children exist.
                If a child's bit is set, geometry will be requested for that tile as well when it
                is needed.  If the bit is cleared, the child tile is not requested and geometry is
                instead upsampled from the parent.  The bit values are as follows:
                <table>
                 <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
                 <tr><td>0</td><td>1</td><td>Southwest</td></tr>
                 <tr><td>1</td><td>2</td><td>Southeast</td></tr>
                 <tr><td>2</td><td>4</td><td>Northwest</td></tr>
                 <tr><td>3</td><td>8</td><td>Northeast</td></tr>
                </table>
         */
        childTileMask?: number;
        /**
         * True if this instance was created by upsampling another instance;
                 otherwise, false.
         */
        createdByUpsampling?: Boolean;
        /**
         * The buffer containing per vertex normals, encoded using 'oct' encoding
         */
        encodedNormals?: Uint8Array;
        /**
         * The buffer containing the watermask.
         */
        waterMask?: Uint8Array;
    }
    interface IQuaternionSplineOptions {
        /**
         * An array of strictly increasing, unit-less, floating-point times at each point.
               The values are in no way connected to the clock time. They are the parameterization for the curve.
         */
        times: number[];
        /**
         * The array of {@link Quaternion} control points.
         */
        points: Quaternion[];
        /**
         * The inner quadrangle of the curve at the first control point.
                    If the inner quadrangle is not given, it will be estimated.
         */
        firstInnerQuadrangle?: Quaternion;
        /**
         * The inner quadrangle of the curve at the last control point.
                    If the inner quadrangle is not given, it will be estimated.
         */
        lastInnerQuadrangle?: Quaternion;
    }
    interface IRectangleGeometryOptions {
        /**
         * A cartographic rectangle with north, south, east and west properties in radians.
         */
        rectangle: Rectangle;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
        /**
         * The ellipsoid on which the rectangle lies.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The distance in meters between the rectangle and the ellipsoid surface.
         */
        height?: number;
        /**
         * The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
         */
        rotation?: number;
        /**
         * The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
         */
        stRotation?: number;
        /**
         * The distance in meters between the rectangle's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
        /**
         * Specifies whether the rectangle has a top cover when extruded.
         */
        closeTop?: Boolean;
        /**
         * Specifies whether the rectangle has a bottom cover when extruded.
         */
        closeBottom?: Boolean;
    }
    interface IRectangleOutlineGeometryOptions {
        /**
         * A cartographic rectangle with north, south, east and west properties in radians.
         */
        rectangle: Rectangle;
        /**
         * The ellipsoid on which the rectangle lies.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The distance in meters between the rectangle and the ellipsoid surface.
         */
        height?: number;
        /**
         * The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
         */
        rotation?: number;
        /**
         * The distance in meters between the rectangle's extruded face and the ellipsoid surface.
         */
        extrudedHeight?: number;
    }
    interface ISimplePolylineGeometryOptions {
        /**
         * An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
         */
        positions: Cartesian3[];
        /**
         * An Array of {@link Color} defining the per vertex or per segment colors.
         */
        colors?: Color[];
        /**
         * A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
         */
        colorsPerVertex?: Boolean;
        /**
         * A boolean that determines whether positions will be adjusted to the surface of the ellipsoid via a great arc.
         */
        followSurface?: Boolean;
        /**
         * The distance, in radians, between each latitude and longitude if options.followSurface=true. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * The ellipsoid to be used as a reference.
         */
        ellipsoid?: Ellipsoid;
    }
    interface ISphereGeometryOptions {
        /**
         * The radius of the sphere.
         */
        radius?: number;
        /**
         * The number of times to partition the ellipsoid into stacks.
         */
        stackPartitions?: number;
        /**
         * The number of times to partition the ellipsoid into radial slices.
         */
        slicePartitions?: number;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface ISphereOutlineGeometryOptions {
        /**
         * The radius of the sphere.
         */
        radius?: number;
        /**
         * The count of stacks for the sphere (1 greater than the number of parallel lines).
         */
        stackPartitions?: number;
        /**
         * The count of slices for the sphere (Equal to the number of radial lines).
         */
        slicePartitions?: number;
        /**
         * The number of points per line, determining the granularity of the curvature .
         */
        subdivisions?: number;
    }
    interface ITimeIntervalOptions {
        /**
         * The start time of the interval.
         */
        start?: JulianDate;
        /**
         * The stop time of the interval.
         */
        stop?: JulianDate;
        /**
         * <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
         */
        isStartIncluded?: Boolean;
        /**
         * <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
         */
        isStopIncluded?: Boolean;
        /**
         * Arbitrary data associated with this interval.
         */
        data?: any;
    }
    interface IVideoSynchronizerOptions {
        /**
         * The clock instance used to drive the video.
         */
        clock?: Clock;
        /**
         * The video element to be synchronized.
         */
        element?: HTMLVideoElement;
        /**
         * The simulation time that marks the start of the video.
         */
        epoch?: JulianDate;
        /**
         * The maximum amount of time, in seconds, that the clock and video can diverge.
         */
        tolerance?: number;
    }
    interface IVRTheWorldTerrainProviderOptions {
        /**
         * The URL of the VR-TheWorld TileMap.
         */
        url: string;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: any;
        /**
         * The ellipsoid.  If this parameter is not
                   specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
    }
    interface IWallGeometryOptions {
        /**
         * An array of Cartesian objects, which are the points of the wall.
         */
        positions: Cartesian3[];
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * An array parallel to <code>positions</code> that give the maximum height of the
       wall at <code>positions</code>. If undefined, the height of each position in used.
         */
        maximumHeights?: number[];
        /**
         * An array parallel to <code>positions</code> that give the minimum height of the
       wall at <code>positions</code>. If undefined, the height at each position is 0.0.
         */
        minimumHeights?: number[];
        /**
         * The ellipsoid for coordinate manipulation
         */
        ellipsoid?: Ellipsoid;
        /**
         * The vertex attributes to be computed.
         */
        vertexFormat?: VertexFormat;
    }
    interface IWallOutlineGeometryOptions {
        /**
         * An array of Cartesian objects, which are the points of the wall.
         */
        positions: Cartesian3[];
        /**
         * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        granularity?: number;
        /**
         * An array parallel to <code>positions</code> that give the maximum height of the
       wall at <code>positions</code>. If undefined, the height of each position in used.
         */
        maximumHeights?: number[];
        /**
         * An array parallel to <code>positions</code> that give the minimum height of the
       wall at <code>positions</code>. If undefined, the height at each position is 0.0.
         */
        minimumHeights?: number[];
        /**
         * The ellipsoid for coordinate manipulation
         */
        ellipsoid?: Ellipsoid;
    }
    interface IWebMercatorTilingSchemeOptions {
        /**
         * The ellipsoid whose surface is being tiled. Defaults to
the WGS84 ellipsoid.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The number of tiles in the X direction at level zero of
       the tile tree.
         */
        numberOfLevelZeroTilesX?: number;
        /**
         * The number of tiles in the Y direction at level zero of
       the tile tree.
         */
        numberOfLevelZeroTilesY?: number;
        /**
         * The southwest corner of the rectangle covered by the
       tiling scheme, in meters.  If this parameter or rectangleNortheastInMeters is not specified, the entire
       globe is covered in the longitude direction and an equal distance is covered in the latitude
       direction, resulting in a square projection.
         */
        rectangleSouthwestInMeters?: Cartesian2;
        /**
         * The northeast corner of the rectangle covered by the
       tiling scheme, in meters.  If this parameter or rectangleSouthwestInMeters is not specified, the entire
       globe is covered in the longitude direction and an equal distance is covered in the latitude
       direction, resulting in a square projection.
         */
        rectangleNortheastInMeters?: Cartesian2;
    }
    interface IBillboardGraphicsOptions {
        /**
         * A Property specifying the Image, URI, or Canvas to use for the billboard.
         */
        image?: Property;
        /**
         * A boolean Property specifying the visibility of the billboard.
         */
        show?: Property;
        /**
         * A numeric Property specifying the scale to apply to the image size.
         */
        scale?: Property;
        /**
         * A Property specifying the {@link HorizontalOrigin}.
         */
        horizontalOrigin?: Property;
        /**
         * A Property specifying the {@link VerticalOrigin}.
         */
        verticalOrigin?: Property;
        /**
         * A {@link Cartesian3} Property specifying the eye offset.
         */
        eyeOffset?: Property;
        /**
         * A {@link Cartesian2} Property specifying the pixel offset.
         */
        pixelOffset?: Property;
        /**
         * A numeric Property specifying the rotation about the alignedAxis.
         */
        rotation?: Property;
        /**
         * A {@link Cartesian3} Property specifying the unit vector axis of rotation.
         */
        alignedAxis?: Property;
        /**
         * A numeric Property specifying the width of the billboard in pixels, overriding the native size.
         */
        width?: Property;
        /**
         * A numeric Property specifying the height of the billboard in pixels, overriding the native size.
         */
        height?: Property;
        /**
         * A Property specifying the tint {@link Color} of the image.
         */
        color?: Property;
        /**
         * A {@link NearFarScalar} Property used to scale the point based on distance from the camera.
         */
        scaleByDistance?: Property;
        /**
         * A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
         */
        translucencyByDistance?: Property;
        /**
         * A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
         */
        pixelOffsetScaleByDistance?: Property;
        /**
         * A Property specifying a {@link BoundingRectangle} that defines a sub-region of the image to use for the billboard, rather than the entire image, measured in pixels from the bottom-left.
         */
        imageSubRegion?: Property;
        /**
         * A boolean Property specifying whether this billboard's size should be measured in meters.
         */
        sizeInMeters?: Property;
        /**
         * A Property specifying what the height is relative to.
         */
        heightReference?: Property;
        /**
         * A Property specifying at what distance from the camera that this billboard will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IBoxGraphicsOptions {
        /**
         * A {@link Cartesian3} Property specifying the length, width, and height of the box.
         */
        dimensions?: Property;
        /**
         * A boolean Property specifying the visibility of the box.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the box is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the box.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the box is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * An enum Property specifying whether the box casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this box will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface ICheckerboardMaterialPropertyOptions {
        /**
         * A Property specifying the first {@link Color}.
         */
        evenColor?: Property;
        /**
         * A Property specifying the second {@link Color}.
         */
        oddColor?: Property;
        /**
         * A {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
         */
        repeat?: Property;
    }
    interface ICorridorGraphicsOptions {
        /**
         * A Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
         */
        positions?: Property;
        /**
         * A numeric Property specifying the distance between the edges of the corridor.
         */
        width?: Property;
        /**
         * A {@link CornerType} Property specifying the style of the corners.
         */
        cornerType?: Property;
        /**
         * A numeric Property specifying the altitude of the corridor relative to the ellipsoid surface.
         */
        height?: Property;
        /**
         * A numeric Property specifying the altitude of the corridor's extruded face relative to the ellipsoid surface.
         */
        extrudedHeight?: Property;
        /**
         * A boolean Property specifying the visibility of the corridor.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the corridor is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the corridor.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the corridor is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric Property specifying the distance between each latitude and longitude.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the corridor casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this corridor will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface ICylinderGraphicsOptions {
        /**
         * A numeric Property specifying the length of the cylinder.
         */
        length?: Property;
        /**
         * A numeric Property specifying the radius of the top of the cylinder.
         */
        topRadius?: Property;
        /**
         * A numeric Property specifying the radius of the bottom of the cylinder.
         */
        bottomRadius?: Property;
        /**
         * A boolean Property specifying the visibility of the cylinder.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the cylinder is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the cylinder.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the cylinder is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
         */
        numberOfVerticalLines?: Property;
        /**
         * The number of edges around the perimeter of the cylinder.
         */
        slices?: Property;
        /**
         * An enum Property specifying whether the cylinder casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this cylinder will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IDataSourceDisplayOptions {
        /**
         * The scene in which to display the data.
         */
        scene: Scene;
        /**
         * The data sources to display.
         */
        dataSourceCollection: DataSourceCollection;
        /**
         * A function which creates an array of visualizers used for visualization.
       If undefined, all standard visualizers are used.
         */
        visualizersCallback?: DataSourceDisplay.VisualizersCallback;
    }
    interface IEllipseGraphicsOptions {
        /**
         * The numeric Property specifying the semi-major axis.
         */
        semiMajorAxis?: Property;
        /**
         * The numeric Property specifying the semi-minor axis.
         */
        semiMinorAxis?: Property;
        /**
         * A numeric Property specifying the altitude of the ellipse relative to the ellipsoid surface.
         */
        height?: Property;
        /**
         * A numeric Property specifying the altitude of the ellipse's extruded face relative to the ellipsoid surface.
         */
        extrudedHeight?: Property;
        /**
         * A boolean Property specifying the visibility of the ellipse.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the ellipse is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the ellipse.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the ellipse is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
         */
        numberOfVerticalLines?: Property;
        /**
         * A numeric property specifying the rotation of the ellipse counter-clockwise from north.
         */
        rotation?: Property;
        /**
         * A numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
         */
        stRotation?: Property;
        /**
         * A numeric Property specifying the angular distance between points on the ellipse.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the ellipse casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this ellipse will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IEllipsoidGraphicsOptions {
        /**
         * A {@link Cartesian3} Property specifying the radii of the ellipsoid.
         */
        radii?: Property;
        /**
         * A boolean Property specifying the visibility of the ellipsoid.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the ellipsoid is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the ellipsoid.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the ellipsoid is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A Property specifying the number of samples per outline ring, determining the granularity of the curvature.
         */
        subdivisions?: Property;
        /**
         * A Property specifying the number of stacks.
         */
        stackPartitions?: Property;
        /**
         * A Property specifying the number of radial slices.
         */
        slicePartitions?: Property;
        /**
         * An enum Property specifying whether the ellipsoid casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this ellipsoid will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IEntityOptions {
        /**
         * A unique identifier for this object. If none is provided, a GUID is generated.
         */
        id?: string;
        /**
         * A human readable name to display to users. It does not have to be unique.
         */
        name?: string;
        /**
         * The availability, if any, associated with this object.
         */
        availability?: TimeIntervalCollection;
        /**
         * A boolean value indicating if the entity and its children are displayed.
         */
        show?: Boolean;
        /**
         * A string Property specifying an HTML description for this entity.
         */
        description?: Property;
        /**
         * A Property specifying the entity position.
         */
        position?: PositionProperty;
        /**
         * A Property specifying the entity orientation.
         */
        orientation?: Property;
        /**
         * A suggested initial offset for viewing this object.
         */
        viewFrom?: Property;
        /**
         * A parent entity to associate with this entity.
         */
        parent?: Entity;
        /**
         * A billboard to associate with this entity.
         */
        billboard?: BillboardGraphics;
        /**
         * A box to associate with this entity.
         */
        box?: BoxGraphics;
        /**
         * A corridor to associate with this entity.
         */
        corridor?: CorridorGraphics;
        /**
         * A cylinder to associate with this entity.
         */
        cylinder?: CylinderGraphics;
        /**
         * A ellipse to associate with this entity.
         */
        ellipse?: EllipseGraphics;
        /**
         * A ellipsoid to associate with this entity.
         */
        ellipsoid?: EllipsoidGraphics;
        /**
         * A options.label to associate with this entity.
         */
        label?: LabelGraphics;
        /**
         * A model to associate with this entity.
         */
        model?: ModelGraphics;
        /**
         * A path to associate with this entity.
         */
        path?: PathGraphics;
        /**
         * A point to associate with this entity.
         */
        point?: PointGraphics;
        /**
         * A polygon to associate with this entity.
         */
        polygon?: PolygonGraphics;
        /**
         * A polyline to associate with this entity.
         */
        polyline?: PolylineGraphics;
        /**
         * A polylineVolume to associate with this entity.
         */
        polylineVolume?: PolylineVolumeGraphics;
        /**
         * A rectangle to associate with this entity.
         */
        rectangle?: RectangleGraphics;
        /**
         * A wall to associate with this entity.
         */
        wall?: WallGraphics;
    }
    interface IEntityClusterOptions {
        /**
         * Whether or not to enable clustering.
         */
        enabled?: Boolean;
        /**
         * The pixel range to extend the screen space bounding box.
         */
        pixelRange?: number;
        /**
         * The minimum number of screen space objects that can be clustered.
         */
        minimumClusterSize?: number;
        /**
         * Whether or not to cluster the billboards of an entity.
         */
        clusterBillboards?: Boolean;
        /**
         * Whether or not to cluster the labels of an entity.
         */
        clusterLabels?: Boolean;
        /**
         * Whether or not to cluster the points of an entity.
         */
        clusterPoints?: Boolean;
    }
    interface IGridMaterialPropertyOptions {
        /**
         * A Property specifying the grid {@link Color}.
         */
        color?: Property;
        /**
         * A numeric Property specifying cell alpha values.
         */
        cellAlpha?: Property;
        /**
         * A {@link Cartesian2} Property specifying the number of grid lines along each axis.
         */
        lineCount?: Property;
        /**
         * A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
         */
        lineThickness?: Property;
        /**
         * A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
         */
        lineOffset?: Property;
    }
    interface IImageMaterialPropertyOptions {
        /**
         * A Property specifying the Image, URL, Canvas, or Video.
         */
        image?: Property;
        /**
         * A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
         */
        repeat?: Property;
        /**
         * The color applied to the image
         */
        color?: Property;
        /**
         * Set to true when the image has transparency (for example, when a png has transparent sections)
         */
        transparent?: Property;
    }
    interface IKmlDataSourceOptions {
        /**
         * The camera that is used for viewRefreshModes and sending camera properties to network links.
         */
        camera: Camera;
        /**
         * The canvas that is used for sending viewer properties to network links.
         */
        canvas: HTMLCanvasElement;
        /**
         * A proxy to be used for loading external data.
         */
        proxy?: DefaultProxy;
    }
    interface IKmlFeatureDataOptions {
        /**
         * Gets the name.
         */
        name: string;
        /**
         * Gets the URI.
         */
        uri: string;
        /**
         * Gets the email.
         */
        email: string;
    }
    interface ILabelGraphicsOptions {
        /**
         * A Property specifying the text.
         */
        text?: Property;
        /**
         * A Property specifying the CSS font.
         */
        font?: Property;
        /**
         * A Property specifying the {@link LabelStyle}.
         */
        style?: Property;
        /**
         * A Property specifying the fill {@link Color}.
         */
        fillColor?: Property;
        /**
         * A Property specifying the outline {@link Color}.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the outline width.
         */
        outlineWidth?: Property;
        /**
         * A boolean Property specifying the visibility of the label.
         */
        show?: Property;
        /**
         * A numeric Property specifying the scale to apply to the text.
         */
        scale?: Property;
        /**
         * A Property specifying the {@link HorizontalOrigin}.
         */
        horizontalOrigin?: Property;
        /**
         * A Property specifying the {@link VerticalOrigin}.
         */
        verticalOrigin?: Property;
        /**
         * A {@link Cartesian3} Property specifying the eye offset.
         */
        eyeOffset?: Property;
        /**
         * A {@link Cartesian2} Property specifying the pixel offset.
         */
        pixelOffset?: Property;
        /**
         * A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
         */
        translucencyByDistance?: Property;
        /**
         * A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
         */
        pixelOffsetScaleByDistance?: Property;
        /**
         * A Property specifying what the height is relative to.
         */
        heightReference?: Property;
        /**
         * A Property specifying at what distance from the camera that this label will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IModelGraphicsOptions {
        /**
         * A string Property specifying the URI of the glTF asset.
         */
        uri?: Property;
        /**
         * A boolean Property specifying the visibility of the model.
         */
        show?: Property;
        /**
         * A numeric Property specifying a uniform linear scale.
         */
        scale?: Property;
        /**
         * A numeric Property specifying the approximate minimum pixel size of the model regardless of zoom.
         */
        minimumPixelSize?: Property;
        /**
         * The maximum scale size of a model. An upper limit for minimumPixelSize.
         */
        maximumScale?: Property;
        /**
         * Determine if textures may continue to stream in after the model is loaded.
         */
        incrementallyLoadTextures?: Property;
        /**
         * A boolean Property specifying if glTF animations specified in the model should be started.
         */
        runAnimations?: Property;
        /**
         * An object, where keys are names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
         */
        nodeTransformations?: Property;
        /**
         * An enum Property specifying whether the model casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying what the height is relative to.
         */
        heightReference?: Property;
        /**
         * A Property specifying at what distance from the camera that this model will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface INodeTransformationPropertyOptions {
        /**
         * A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
         */
        translation?: Property;
        /**
         * A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
         */
        rotation?: Property;
        /**
         * A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
         */
        scale?: Property;
    }
    interface IPathGraphicsOptions {
        /**
         * A Property specifying the number of seconds behind the object to show.
         */
        leadTime?: Property;
        /**
         * A Property specifying the number of seconds in front of the object to show.
         */
        trailTime?: Property;
        /**
         * A boolean Property specifying the visibility of the path.
         */
        show?: Property;
        /**
         * A numeric Property specifying the width in pixels.
         */
        width?: Property;
        /**
         * A Property specifying the material used to draw the path.
         */
        material?: MaterialProperty;
        /**
         * A numeric Property specifying the maximum number of seconds to step when sampling the position.
         */
        resolution?: Property;
        /**
         * A Property specifying at what distance from the camera that this path will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IPointGraphicsOptions {
        /**
         * A Property specifying the {@link Color} of the point.
         */
        color?: Property;
        /**
         * A numeric Property specifying the size in pixels.
         */
        pixelSize?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the the outline width in pixels.
         */
        outlineWidth?: Property;
        /**
         * A boolean Property specifying the visibility of the point.
         */
        show?: Property;
        /**
         * A {@link NearFarScalar} Property used to scale the point based on distance.
         */
        scaleByDistance?: Property;
        /**
         * A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
         */
        translucencyByDistance?: Property;
        /**
         * A Property specifying what the height is relative to.
         */
        heightReference?: Property;
        /**
         * A Property specifying at what distance from the camera that this point will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IPolygonGraphicsOptions {
        /**
         * A Property specifying the {@link PolygonHierarchy}.
         */
        hierarchy?: Property;
        /**
         * A numeric Property specifying the altitude of the polygon relative to the ellipsoid surface.
         */
        height?: Property;
        /**
         * A numeric Property specifying the altitude of the polygon's extruded face relative to the ellipsoid surface.
         */
        extrudedHeight?: Property;
        /**
         * A boolean Property specifying the visibility of the polygon.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the polygon is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the polygon.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the polygon is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric property specifying the rotation of the polygon texture counter-clockwise from north.
         */
        stRotation?: Property;
        /**
         * A numeric Property specifying the angular distance between each latitude and longitude point.
         */
        granularity?: Property;
        /**
         * A boolean specifying whether or not the the height of each position is used.
         */
        perPositionHeight?: Property;
        /**
         * When false, leaves off the top of an extruded polygon open.
         */
        closeTop?: Boolean;
        /**
         * When false, leaves off the bottom of an extruded polygon open.
         */
        closeBottom?: Boolean;
        /**
         * An enum Property specifying whether the polygon casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this polygon will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IPolylineGlowMaterialPropertyOptions {
        /**
         * A Property specifying the {@link Color} of the line.
         */
        color?: Property;
        /**
         * A numeric Property specifying the strength of the glow, as a percentage of the total line width.
         */
        glowPower?: Property;
    }
    interface IPolylineGraphicsOptions {
        /**
         * A Property specifying the array of {@link Cartesian3} positions that define the line strip.
         */
        positions?: Property;
        /**
         * A boolean Property specifying whether the line segments should be great arcs or linearly connected.
         */
        followSurface?: Property;
        /**
         * A numeric Property specifying the width in pixels.
         */
        width?: Property;
        /**
         * A boolean Property specifying the visibility of the polyline.
         */
        show?: Property;
        /**
         * A Property specifying the material used to draw the polyline.
         */
        material?: MaterialProperty;
        /**
         * A numeric Property specifying the angular distance between each latitude and longitude if followSurface is true.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the polyline casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this polyline will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IPolylineOutlineMaterialPropertyOptions {
        /**
         * A Property specifying the {@link Color} of the line.
         */
        color?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline, in pixels.
         */
        outlineWidth?: Property;
    }
    interface IPolylineVolumeGraphicsOptions {
        /**
         * A Property specifying the array of {@link Cartesian3} positions which define the line strip.
         */
        positions?: Property;
        /**
         * A Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
         */
        shape?: Property;
        /**
         * A {@link CornerType} Property specifying the style of the corners.
         */
        cornerType?: Property;
        /**
         * A boolean Property specifying the visibility of the volume.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the volume is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the volume.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the volume is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric Property specifying the angular distance between each latitude and longitude point.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the volume casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this volume will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IRectangleGraphicsOptions {
        /**
         * The Property specifying the {@link Rectangle}.
         */
        coordinates?: Property;
        /**
         * A numeric Property specifying the altitude of the rectangle relative to the ellipsoid surface.
         */
        height?: Property;
        /**
         * A numeric Property specifying the altitude of the rectangle's extruded face relative to the ellipsoid surface.
         */
        extrudedHeight?: Property;
        /**
         * A boolean Property specifying whether the rectangle has a top cover when extruded
         */
        closeTop?: Property;
        /**
         * A boolean Property specifying whether the rectangle has a bottom cover when extruded.
         */
        closeBottom?: Property;
        /**
         * A boolean Property specifying the visibility of the rectangle.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the rectangle is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the rectangle.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the rectangle is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric property specifying the rotation of the rectangle clockwise from north.
         */
        rotation?: Property;
        /**
         * A numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
         */
        stRotation?: Property;
        /**
         * A numeric Property specifying the angular distance between points on the rectangle.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the rectangle casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this rectangle will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IStripeMaterialPropertyOptions {
        /**
         * A Property specifying the first {@link Color}.
         */
        evenColor?: Property;
        /**
         * A Property specifying the second {@link Color}.
         */
        oddColor?: Property;
        /**
         * A numeric Property specifying how many times the stripes repeat.
         */
        repeat?: Property;
        /**
         * A numeric Property specifying how far into the pattern to start the material.
         */
        offset?: Property;
        /**
         * A Property specifying the {@link StripeOrientation}.
         */
        orientation?: Property;
    }
    interface IWallGraphicsOptions {
        /**
         * A Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
         */
        positions?: Property;
        /**
         * A Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
         */
        maximumHeights?: Property;
        /**
         * A Property specifying an array of heights to be used for the bottom of the wall instead of the globe surface.
         */
        minimumHeights?: Property;
        /**
         * A boolean Property specifying the visibility of the wall.
         */
        show?: Property;
        /**
         * A boolean Property specifying whether the wall is filled with the provided material.
         */
        fill?: Property;
        /**
         * A Property specifying the material used to fill the wall.
         */
        material?: MaterialProperty;
        /**
         * A boolean Property specifying whether the wall is outlined.
         */
        outline?: Property;
        /**
         * A Property specifying the {@link Color} of the outline.
         */
        outlineColor?: Property;
        /**
         * A numeric Property specifying the width of the outline.
         */
        outlineWidth?: Property;
        /**
         * A numeric Property specifying the angular distance between each latitude and longitude point.
         */
        granularity?: Property;
        /**
         * An enum Property specifying whether the wall casts or receives shadows from each light source.
         */
        shadows?: Property;
        /**
         * A Property specifying at what distance from the camera that this wall will be displayed.
         */
        distanceDisplayCondition?: Property;
    }
    interface IAppearanceOptions {
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.
         */
        closed?: Boolean;
        /**
         * The material used to determine the fragment color.
         */
        material?: Material;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IArcGisMapServerImageryProviderOptions {
        /**
         * The URL of the ArcGIS MapServer service.
         */
        url: string;
        /**
         * The ArcGIS token used to authenticate with the ArcGIS MapServer service.
         */
        token?: string;
        /**
         * The policy that determines if a tile
       is invalid and should be discarded.  If this value is not specified, a default
       {@link DiscardMissingTileImagePolicy} is used for tiled map servers, and a
       {@link NeverTileDiscardPolicy} is used for non-tiled map servers.  In the former case,
       we request tile 0,0 at the maximum tile level and check pixels (0,0), (200,20), (20,200),
       (80,110), and (160, 130).  If all of these pixels are transparent, the discard check is
       disabled and no tiles are discarded.  If any of them have a non-transparent color, any
       tile that has the same values in these pixel locations is discarded.  The end result of
       these defaults should be correct tile discarding for a standard ArcGIS Server.  To ensure
       that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
       parameter.
         */
        tileDiscardPolicy?: TileDiscardPolicy;
        /**
         * A proxy to use for requests. This object is
       expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: Proxy;
        /**
         * If true, the server's pre-cached
       tiles are used if they are available.  If false, any pre-cached tiles are ignored and the
       'export' service is used.
         */
        usePreCachedTilesIfAvailable?: Boolean;
        /**
         * A comma-separated list of the layers to show, or undefined if all layers should be shown.
         */
        layers?: string;
        /**
         * If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will invoke
       the Identify service on the MapServer and return the features included in the response.  If false,
       {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
       without communicating with the server.  Set this property to false if you don't want this provider's features to
       be pickable. Can be overridden by setting the {@link ArcGisMapServerImageryProvider#enablePickFeatures} property on the object.
         */
        enablePickFeatures?: Boolean;
        /**
         * The rectangle of the layer.  This parameter is ignored when accessing
                   a tiled layer.
         */
        rectangle?: Rectangle;
        /**
         * The tiling scheme to use to divide the world into tiles.
                      This parameter is ignored when accessing a tiled server.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified and used,
                   this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
                   parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The width of each tile in pixels.  This parameter is ignored when accessing a tiled server.
         */
        tileWidth?: number;
        /**
         * The height of each tile in pixels.  This parameter is ignored when accessing a tiled server.
         */
        tileHeight?: number;
        /**
         * The maximum tile level to request, or undefined if there is no maximum.  This parameter is ignored when accessing
                                       a tiled server.
         */
        maximumLevel?: number;
    }
    interface IBillboardCollectionOptions {
        /**
         * The 4x4 transformation matrix that transforms each billboard from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
        /**
         * Must be passed in for billboards that use the height reference property or will be depth tested against the globe.
         */
        scene?: Scene;
    }
    interface IBingMapsImageryProviderOptions {
        /**
         * The url of the Bing Maps server hosting the imagery.
         */
        url: string;
        /**
         * The Bing Maps key for your application, which can be
       created at {@link https://www.bingmapsportal.com/}.
       If this parameter is not provided, {@link BingMapsApi.defaultKey} is used.
       If {@link BingMapsApi.defaultKey} is undefined as well, a message is
       written to the console reminding you that you must create and supply a Bing Maps
       key as soon as possible.  Please do not deploy an application that uses
       Bing Maps imagery without creating a separate key for your application.
         */
        key?: string;
        /**
         * The protocol to use when loading tiles, e.g. 'http:' or 'https:'.
       By default, tiles are loaded using the same protocol as the page.
         */
        tileProtocol?: string;
        /**
         * The type of Bing Maps
       imagery to load.
         */
        mapStyle?: string;
        /**
         * The culture to use when requesting Bing Maps imagery. Not
       all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
       for information on the supported cultures.
         */
        culture?: string;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The policy that determines if a tile
       is invalid and should be discarded.  If this value is not specified, a default
       {@link DiscardMissingTileImagePolicy} is used which requests
       tile 0,0 at the maximum tile level and checks pixels (0,0), (120,140), (130,160),
       (200,50), and (200,200).  If all of these pixels are transparent, the discard check is
       disabled and no tiles are discarded.  If any of them have a non-transparent color, any
       tile that has the same values in these pixel locations is discarded.  The end result of
       these defaults should be correct tile discarding for a standard Bing Maps server.  To ensure
       that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
       parameter.
         */
        tileDiscardPolicy?: TileDiscardPolicy;
        /**
         * A proxy to use for requests. This object is
       expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: Proxy;
    }
    interface IDebugAppearanceOptions {
        /**
         * The name of the attribute to visualize.
         */
        attributeName: string;
        /**
         * Boolean that determines whether this attribute is a per-instance geometry attribute.
         */
        perInstanceAttribute: Boolean;
        /**
         * The GLSL datatype of the attribute.  Supported datatypes are <code>float</code>, <code>vec2</code>, <code>vec3</code>, and <code>vec4</code>.
         */
        glslDatatype?: string;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IDebugCameraPrimitiveOptions {
        /**
         * The camera.
         */
        camera: Camera;
        /**
         * The color of the debug outline.
         */
        color?: number;
        /**
         * Whether the primitive updates when the underlying camera changes.
         */
        updateOnChange?: Boolean;
        /**
         * Determines if this primitive will be shown.
         */
        show?: Boolean;
        /**
         * A user-defined object to return when the instance is picked with {@link Scene#pick}.
         */
        id?: any;
    }
    interface IDebugModelMatrixPrimitiveOptions {
        /**
         * The length of the axes in meters.
         */
        length?: number;
        /**
         * The width of the axes in pixels.
         */
        width?: number;
        /**
         * The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
         */
        modelMatrix?: Matrix4;
        /**
         * Determines if this primitive will be shown.
         */
        show?: Boolean;
        /**
         * A user-defined object to return when the instance is picked with {@link Scene#pick}
         */
        id?: any;
    }
    interface IDiscardMissingTileImagePolicyOptions {
        /**
         * The URL of the known missing image.
         */
        missingImageUrl: string;
        /**
         * An array of {@link Cartesian2} pixel positions to
       compare against the missing image.
         */
        pixelsToCheck: Cartesian2[];
        /**
         * If true, the discard check will be disabled
                 if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the
                 discard check will proceed no matter the values of the pixelsToCheck.
         */
        disableCheckIfAllPixelsAreTransparent?: Boolean;
    }
    interface IEllipsoidSurfaceAppearanceOptions {
        /**
         * When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
         */
        flat?: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
         */
        faceForward?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link EllipsoidSurfaceAppearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to be on the ellipsoid's surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
         */
        aboveGround?: Boolean;
        /**
         * The material used to determine the fragment color.
         */
        material?: Material;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IFrameRateMonitorOptions {
        /**
         * The Scene instance for which to monitor performance.
         */
        scene: Scene;
        /**
         * The length of the sliding window over which to compute the average frame rate, in seconds.
         */
        samplingWindow?: number;
        /**
         * The length of time to wait at startup and each time the page becomes visible (i.e. when the user
       switches back to the tab) before starting to measure performance, in seconds.
         */
        quietPeriod?: number;
        /**
         * The length of the warmup period, in seconds.  During the warmup period, a separate
       (usually lower) frame rate is required.
         */
        warmupPeriod?: number;
        /**
         * The minimum frames-per-second that are required for acceptable performance during
       the warmup period.  If the frame rate averages less than this during any samplingWindow during the warmupPeriod, the
       lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
         */
        minimumFrameRateDuringWarmup?: number;
        /**
         * The minimum frames-per-second that are required for acceptable performance after
       the end of the warmup period.  If the frame rate averages less than this during any samplingWindow after the warmupPeriod, the
       lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
         */
        minimumFrameRateAfterWarmup?: number;
    }
    interface IGoogleEarthImageryProviderOptions {
        /**
         * The url of the Google Earth server hosting the imagery.
         */
        url: string;
        /**
         * The channel (id) to be used when requesting data from the server.
       The channel number can be found by looking at the json file located at:
       earth.localdomain/default_map/query?request=Json&vars=geeServerDefs The /default_map path may
       differ depending on your Google Earth Enterprise server configuration. Look for the "id" that
       is associated with a "ImageryMaps" requestType. There may be more than one id available.
       Example:
       {
         layers: [
           {
             id: 1002,
             requestType: "ImageryMaps"
           },
           {
             id: 1007,
             requestType: "VectorMapsRaster"
           }
         ]
       }
         */
        channel: number;
        /**
         * The path of the Google Earth server hosting the imagery.
         */
        path?: string;
        /**
         * The maximum level-of-detail supported by the Google Earth
       Enterprise server, or undefined if there is no limit.
         */
        maximumLevel?: number;
        /**
         * The policy that determines if a tile
       is invalid and should be discarded. To ensure that no tiles are discarded, construct and pass
       a {@link NeverTileDiscardPolicy} for this parameter.
         */
        tileDiscardPolicy?: TileDiscardPolicy;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * A proxy to use for requests. This object is
       expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: Proxy;
    }
    interface IGridImageryProviderOptions {
        /**
         * The tiling scheme for which to draw tiles.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
                   this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
                   parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The number of grids cells.
         */
        cells?: number;
        /**
         * The color to draw grid lines.
         */
        color?: number;
        /**
         * The color to draw glow for grid lines.
         */
        glowColor?: number;
        /**
         * The width of lines used for rendering the line glow effect.
         */
        glowWidth?: number;
        /**
         * The width of the tile for level-of-detail selection purposes.
         */
        tileWidth?: number;
        /**
         * The height of the tile for level-of-detail selection purposes.
         */
        tileHeight?: number;
        /**
         * The size of the canvas used for rendering.
         */
        canvasSize?: number;
    }
    interface IGroundPrimitiveOptions {
        /**
         * The geometry instances to render.
         */
        geometryInstances?: any[]|GeometryInstance;
        /**
         * Determines if this primitive will be shown.
         */
        show?: Boolean;
        /**
         * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
         */
        vertexCacheOptimize?: Boolean;
        /**
         * When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
         */
        interleave?: Boolean;
        /**
         * When <code>true</code>, the geometry vertices are compressed, which will save memory.
         */
        compressVertices?: Boolean;
        /**
         * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
         */
        releaseGeometryInstances?: Boolean;
        /**
         * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
         */
        allowPicking?: Boolean;
        /**
         * Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
         */
        asynchronous?: Boolean;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
        /**
         * For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
                 creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
         */
        debugShowShadowVolume?: Boolean;
    }
    interface IImageryLayerOptions {
        /**
         * The rectangle of the layer.  This rectangle
       can limit the visible portion of the imagery provider.
         */
        rectangle?: Rectangle;
        /**
         * The alpha blending value of this layer, from 0.0 to 1.0.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates of the
                         imagery tile for which the alpha is required, and it is expected to return
                         the alpha value to use for the tile.
         */
        alpha?: number|Function;
        /**
         * The brightness of this layer.  1.0 uses the unmodified imagery
                         color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates of the
                         imagery tile for which the brightness is required, and it is expected to return
                         the brightness value to use for the tile.  The function is executed for every
                         frame and for every tile, so it must be fast.
         */
        brightness?: number|Function;
        /**
         * The contrast of this layer.  1.0 uses the unmodified imagery color.
                         Less than 1.0 reduces the contrast while greater than 1.0 increases it.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates of the
                         imagery tile for which the contrast is required, and it is expected to return
                         the contrast value to use for the tile.  The function is executed for every
                         frame and for every tile, so it must be fast.
         */
        contrast?: number|Function;
        /**
         * The hue of this layer.  0.0 uses the unmodified imagery color.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates
                         of the imagery tile for which the hue is required, and it is expected to return
                         the contrast value to use for the tile.  The function is executed for every
                         frame and for every tile, so it must be fast.
         */
        hue?: number|Function;
        /**
         * The saturation of this layer.  1.0 uses the unmodified imagery color.
                         Less than 1.0 reduces the saturation while greater than 1.0 increases it.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates
                         of the imagery tile for which the saturation is required, and it is expected to return
                         the contrast value to use for the tile.  The function is executed for every
                         frame and for every tile, so it must be fast.
         */
        saturation?: number|Function;
        /**
         * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
                         This can either be a simple number or a function with the signature
                         <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
                         current frame state, this layer, and the x, y, and level coordinates of the
                         imagery tile for which the gamma is required, and it is expected to return
                         the gamma value to use for the tile.  The function is executed for every
                         frame and for every tile, so it must be fast.
         */
        gamma?: number|Function;
        /**
         * True if the layer is shown; otherwise, false.
         */
        show?: Boolean;
        /**
         * The maximum anisotropy level to use
       for texture filtering.  If this parameter is not specified, the maximum anisotropy supported
       by the WebGL stack will be used.  Larger values make the imagery look better in horizon
       views.
         */
        maximumAnisotropy?: number;
        /**
         * The minimum terrain level-of-detail at which to show this imagery layer,
                or undefined to show it at all levels.  Level zero is the least-detailed level.
         */
        minimumTerrainLevel?: number;
        /**
         * The maximum terrain level-of-detail at which to show this imagery layer,
                or undefined to show it at all levels.  Level zero is the least-detailed level.
         */
        maximumTerrainLevel?: number;
    }
    interface ILabelCollectionOptions {
        /**
         * The 4x4 transformation matrix that transforms each label from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
        /**
         * Must be passed in for labels that use the height reference property or will be depth tested against the globe.
         */
        scene?: Scene;
    }
    interface IMapboxImageryProviderOptions {
        /**
         * The Mapbox server url.
         */
        url?: string;
        /**
         * The Mapbox Map ID.
         */
        mapId: string;
        /**
         * The public access token for the imagery.
         */
        accessToken?: string;
        /**
         * The format of the image request.
         */
        format?: string;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
         */
        proxy?: any;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The minimum level-of-detail supported by the imagery provider.  Take care when specifying
                this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
                to result in rendering problems.
         */
        minimumLevel?: number;
        /**
         * The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
         */
        maximumLevel?: number;
        /**
         * The rectangle, in radians, covered by the image.
         */
        rectangle?: Rectangle;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
    }
    interface IMaterialOptions {
        /**
         * Throws errors for issues that would normally be ignored, including unused uniforms or materials.
         */
        strict?: Boolean;
        /**
         * When <code>true</code> or a function that returns <code>true</code>, the geometry
                          with this material is expected to appear translucent.
         */
        translucent?: Boolean|Function;
        /**
         * The fabric JSON used to generate the material.
         */
        fabric: any;
    }
    interface IMaterialAppearanceOptions {
        /**
         * When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
         */
        flat?: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
         */
        faceForward?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.
         */
        closed?: Boolean;
        /**
         * The type of materials that will be supported.
         */
        materialSupport?: number;
        /**
         * The material used to determine the fragment color.
         */
        material?: Material;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IModelOptions {
        /**
         * The object for the glTF JSON or an arraybuffer of Binary glTF defined by the KHR_binary_glTF extension.
         */
        gltf?: any|ArrayBuffer|Uint8Array;
        /**
         * The base path that paths in the glTF JSON are relative to.
         */
        basePath?: string;
        /**
         * Determines if the model primitive will be shown.
         */
        show?: Boolean;
        /**
         * The 4x4 transformation matrix that transforms the model from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * A uniform scale applied to this model.
         */
        scale?: number;
        /**
         * The approximate minimum pixel size of the model regardless of zoom.
         */
        minimumPixelSize?: number;
        /**
         * The maximum scale size of a model. An upper limit for minimumPixelSize.
         */
        maximumScale?: number;
        /**
         * A user-defined object to return when the model is picked with {@link Scene#pick}.
         */
        id?: any;
        /**
         * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.
         */
        allowPicking?: Boolean;
        /**
         * Determine if textures may continue to stream in after the model is loaded.
         */
        incrementallyLoadTextures?: Boolean;
        /**
         * Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.
         */
        asynchronous?: Boolean;
        /**
         * Determines whether the model casts or receives shadows from each light source.
         */
        shadows?: number;
        /**
         * For debugging only. Draws the bounding sphere for each draw command in the model.
         */
        debugShowBoundingVolume?: Boolean;
        /**
         * For debugging only. Draws the model in wireframe.
         */
        debugWireframe?: Boolean;
        /**
         * Determines how the model is drawn relative to terrain.
         */
        heightReference?: number;
        /**
         * Must be passed in for models that use the height reference property.
         */
        scene?: Scene;
        /**
         * The condition specifying at what distance from the camera that this model will be displayed.
         */
        istanceDisplayCondition?: DistanceDisplayCondition;
    }
    interface IMoonOptions {
        /**
         * Determines whether the moon will be rendered.
         */
        show?: Boolean;
        /**
         * The moon texture.
         */
        textureUrl?: string;
        /**
         * The moon ellipsoid.
         */
        ellipsoid?: Ellipsoid;
        /**
         * Use the sun as the only light source.
         */
        onlySunLighting?: Boolean;
    }
    interface IPerInstanceColorAppearanceOptions {
        /**
         * When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
         */
        flat?: Boolean;
        /**
         * When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
         */
        faceForward?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * When <code>true</code>, the geometry is expected to be closed so {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
         */
        closed?: Boolean;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IPointPrimitiveCollectionOptions {
        /**
         * The 4x4 transformation matrix that transforms each point from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
    }
    interface IPolylineOptions {
        /**
         * <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.
         */
        show?: Boolean;
        /**
         * The width of the polyline in pixels.
         */
        width?: number;
        /**
         * Whether a line segment will be added between the last and first line positions to make this line a loop.
         */
        loop?: Boolean;
        /**
         * The material.
         */
        material?: Material;
        /**
         * The positions.
         */
        positions?: Cartesian3[];
        /**
         * The user-defined object to be returned when this polyline is picked.
         */
        id?: any;
        /**
         * The condition specifying at what distance from the camera that this polyline will be displayed.
         */
        distanceDisplayCondition?: DistanceDisplayCondition;
    }
    interface IPolylineCollectionOptions {
        /**
         * The 4x4 transformation matrix that transforms each polyline from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
    }
    interface IPolylineColorAppearanceOptions {
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineColorAppearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IPolylineMaterialAppearanceOptions {
        /**
         * When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
         */
        translucent?: Boolean;
        /**
         * The material used to determine the fragment color.
         */
        material?: Material;
        /**
         * Optional GLSL vertex shader source to override the default vertex shader.
         */
        vertexShaderSource?: string;
        /**
         * Optional GLSL fragment shader source to override the default fragment shader.
         */
        fragmentShaderSource?: string;
        /**
         * Optional render state to override the default render state.
         */
        renderState?: number;
    }
    interface IPrimitiveOptions {
        /**
         * The geometry instances - or a single geometry instance - to render.
         */
        geometryInstances?: GeometryInstance[]|GeometryInstance;
        /**
         * The appearance used to render the primitive.
         */
        appearance?: Appearance;
        /**
         * Determines if this primitive will be shown.
         */
        show?: Boolean;
        /**
         * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
         */
        modelMatrix?: Matrix4;
        /**
         * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
         */
        vertexCacheOptimize?: Boolean;
        /**
         * When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
         */
        interleave?: Boolean;
        /**
         * When <code>true</code>, the geometry vertices are compressed, which will save memory.
         */
        compressVertices?: Boolean;
        /**
         * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
         */
        releaseGeometryInstances?: Boolean;
        /**
         * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
         */
        allowPicking?: Boolean;
        /**
         * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.
         */
        cull?: Boolean;
        /**
         * Determines if the primitive will be created asynchronously or block until ready.
         */
        asynchronous?: Boolean;
        /**
         * For debugging only. Determines if this primitive's commands' bounding spheres are shown.
         */
        debugShowBoundingVolume?: Boolean;
        /**
         * Determines whether this primitive casts or receives shadows from each light source.
         */
        shadows?: number;
    }
    interface IPrimitiveCollectionOptions {
        /**
         * Determines if the primitives in the collection will be shown.
         */
        show?: Boolean;
        /**
         * Determines if primitives in the collection are destroyed when they are removed.
         */
        destroyPrimitives?: Boolean;
    }
    interface ISceneOptions {
        /**
         * The HTML canvas element to create the scene for.
         */
        canvas: HTMLCanvasElement;
        /**
         * Context and WebGL creation properties.  See details above.
         */
        contextOptions?: any;
        /**
         * The HTML element in which the credits will be displayed.
         */
        creditContainer?: Element;
        /**
         * The map projection to use in 2D and Columbus View modes.
         */
        mapProjection?: MapProjection;
        /**
         * If true and the configuration supports it, use order independent translucency.
         */
        orderIndependentTranslucency?: Boolean;
        /**
         * If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.
         */
        scene3DOnly?: Boolean;
        /**
         * A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
         */
        terrainExaggeration?: number;
        /**
         * Determines if shadows are cast by the sun.
         */
        shadows?: Boolean;
        /**
         * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
         */
        mapMode2D?: number;
    }
    interface IShadowMapOptions {
        /**
         * The context in which to create the shadow map.
         */
        context: Context;
        /**
         * A camera representing the light source.
         */
        lightCamera: Camera;
        /**
         * Whether the shadow map is enabled.
         */
        enabled?: Boolean;
        /**
         * Whether the light source is a point light. Point light shadows do not use cascades.
         */
        isPointLight?: Boolean;
        /**
         * Radius of the point light.
         */
        pointLightRadius?: Boolean;
        /**
         * Use multiple shadow maps to cover different partitions of the view frustum.
         */
        cascadesEnabled?: Boolean;
        /**
         * The number of cascades to use for the shadow map. Supported values are one and four.
         */
        numberOfCascades?: number;
        /**
         * The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.
         */
        maximumDistance?: number;
        /**
         * The width and height, in pixels, of each shadow map.
         */
        size?: number;
        /**
         * Whether percentage-closer-filtering is enabled for producing softer shadows.
         */
        softShadows?: Boolean;
        /**
         * The shadow darkness.
         */
        darkness?: number;
    }
    interface ISingleTileImageryProviderOptions {
        /**
         * The url for the tile.
         */
        url: string;
        /**
         * The rectangle, in radians, covered by the image.
         */
        rectangle?: Rectangle;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: any;
    }
    interface ISkyBoxOptions {
        /**
         * The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.
         */
        sources?: any;
        /**
         * Determines if this primitive will be shown.
         */
        show?: Boolean;
    }
    interface ITileCoordinatesImageryProviderOptions {
        /**
         * The tiling scheme for which to draw tiles.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
                   this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
                   parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The color to draw the tile box and label.
         */
        color?: number;
        /**
         * The width of the tile for level-of-detail selection purposes.
         */
        tileWidth?: number;
        /**
         * The height of the tile for level-of-detail selection purposes.
         */
        tileHeight?: number;
    }
    interface IUrlTemplateImageryProviderOptions {
        /**
         * The URL template to use to request tiles.  It has the following keywords:
<ul>
    <li><code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
    <li><code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
    <li><code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
    <li><code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
    <li><code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
    <li><code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
    <li><code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
    <li><code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
    <li><code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
    <li><code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
    <li><code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
    <li><code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
    <li><code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
    <li><code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
    <li><code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
    <li><code>{width}</code>: The width of each tile in pixels.</li>
    <li><code>{height}</code>: The height of each tile in pixels.</li>
</ul>
         */
        url: string;
        /**
         * The URL template to use to pick features.  If this property is not specified,
                {@link UrlTemplateImageryProvider#pickFeatures} will immediately returned undefined, indicating no
                features picked.  The URL template supports all of the keywords supported by the <code>url</code>
                parameter, plus the following:
<ul>
    <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>
    <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>
    <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>
    <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>
    <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>
    <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>
    <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>
    <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>
    <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>
</ul>
         */
        pickFeaturesUrl?: string;
        /**
         * Gets the URL scheme zero padding for each tile coordinate. The format is '000' where
each coordinate will be padded on the left with zeros to match the width of the passed string of zeros. e.g. Setting:
urlSchemeZeroPadding : { '{x}' : '0000'}
will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
It the passed object has the following keywords:
<ul>
 <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
 <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
 <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
 <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
 <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
 <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
</ul>
         */
        urlSchemeZeroPadding?: any;
        /**
         * The subdomains to use for the <code>{s}</code> placeholder in the URL template.
                         If this parameter is a single string, each character in the string is a subdomain.  If it is
                         an array, each element in the array is a subdomain.
         */
        subdomains?: string|string[];
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
         */
        proxy?: any;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
        /**
         * The minimum level-of-detail supported by the imagery provider.  Take care when specifying
                this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
                to result in rendering problems.
         */
        minimumLevel?: number;
        /**
         * The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
         */
        maximumLevel?: number;
        /**
         * The rectangle, in radians, covered by the image.
         */
        rectangle?: Rectangle;
        /**
         * The tiling scheme specifying how the ellipsoidal
surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}
is used.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
                   this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
                   parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * Pixel width of image tiles.
         */
        tileWidth?: number;
        /**
         * Pixel height of image tiles.
         */
        tileHeight?: number;
        /**
         * true if the images provided by this imagery provider
                 include an alpha channel; otherwise, false.  If this property is false, an alpha channel, if
                 present, will be ignored.  If this property is true, any images without an alpha channel will
                 be treated as if their alpha is 1.0 everywhere.  When this property is false, memory usage
                 and texture upload time are potentially reduced.
         */
        hasAlphaChannel?: Boolean;
        /**
         * The formats in which to get feature information at a
                                specific location when {@link UrlTemplateImageryProvider#pickFeatures} is invoked.  If this
                                parameter is not specified, feature picking is disabled.
         */
        getFeatureInfoFormats?: GetFeatureInfoFormat[];
        /**
         * If true, {@link UrlTemplateImageryProvider#pickFeatures} will
       request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
       {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
       features) without communicating with the server.  Set this property to false if you know your data
       source does not support picking features or if you don't want this provider's features to be pickable. Note
       that this can be dynamically overridden by modifying the {@link UriTemplateImageryProvider#enablePickFeatures}
       property.
         */
        enablePickFeatures?: Boolean;
    }
    interface IWebMapServiceImageryProviderOptions {
        /**
         * The URL of the WMS service. The URL supports the same keywords as the {@link UrlTemplateImageryProvider}.
         */
        url: string;
        /**
         * The layers to include, separated by commas.
         */
        layers: string;
        /**
         * Additional parameters
       to pass to the WMS server in the GetMap URL.
         */
        parameters?: any;
        /**
         * Additional
       parameters to pass to the WMS server in the GetFeatureInfo URL.
         */
        getFeatureInfoParameters?: any;
        /**
         * If true, {@link WebMapServiceImageryProvider#pickFeatures} will invoke
       the GetFeatureInfo operation on the WMS server and return the features included in the response.  If false,
       {@link WebMapServiceImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
       without communicating with the server.  Set this property to false if you know your WMS server does not support
       GetFeatureInfo or if you don't want this provider's features to be pickable. Note that this can be dynamically
       overridden by modifying the WebMapServiceImageryProvider#enablePickFeatures property.
         */
        enablePickFeatures?: Boolean;
        /**
         * The formats
       in which to try WMS GetFeatureInfo requests.
         */
        getFeatureInfoFormats?: GetFeatureInfoFormat[];
        /**
         * The rectangle of the layer.
         */
        rectangle?: Rectangle;
        /**
         * The tiling scheme to use to divide the world into tiles.
         */
        tilingScheme?: TilingScheme;
        /**
         * The ellipsoid.  If the tilingScheme is specified,
       this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
       parameter is specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * The width of each tile in pixels.
         */
        tileWidth?: number;
        /**
         * The height of each tile in pixels.
         */
        tileHeight?: number;
        /**
         * The minimum level-of-detail supported by the imagery provider.  Take care when
       specifying this that the number of tiles at the minimum level is small, such as four or less.  A larger number is
       likely to result in rendering problems.
         */
        minimumLevel?: number;
        /**
         * The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
       If not specified, there is no limit.
         */
        maximumLevel?: number;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
        /**
         * A proxy to use for requests. This object is
       expected to have a getURL function which returns the proxied URL, if needed.
         */
        proxy?: any;
        /**
         * The subdomains to use for the <code>{s}</code> placeholder in the URL template.
                         If this parameter is a single string, each character in the string is a subdomain.  If it is
                         an array, each element in the array is a subdomain.
         */
        subdomains?: string|string[];
    }
    interface IWebMapTileServiceImageryProviderOptions {
        /**
         * The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.
         */
        url: string;
        /**
         * The MIME type for images to retrieve from the server.
         */
        format?: string;
        /**
         * The layer name for WMTS requests.
         */
        layer: string;
        /**
         * The style name for WMTS requests.
         */
        style: string;
        /**
         * The identifier of the TileMatrixSet to use for WMTS requests.
         */
        tileMatrixSetID: string;
        /**
         * A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.
         */
        tileMatrixLabels?: any[];
        /**
         * The tile width in pixels.
         */
        tileWidth?: number;
        /**
         * The tile height in pixels.
         */
        tileHeight?: number;
        /**
         * The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.
         */
        tilingScheme?: TilingScheme;
        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
         */
        proxy?: any;
        /**
         * The rectangle covered by the layer.
         */
        rectangle?: Rectangle;
        /**
         * The minimum level-of-detail supported by the imagery provider.
         */
        minimumLevel?: number;
        /**
         * The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
         */
        maximumLevel?: number;
        /**
         * The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
         */
        ellipsoid?: Ellipsoid;
        /**
         * A credit for the data source, which is displayed on the canvas.
         */
        credit?: Credit|string;
        /**
         * The subdomains to use for the <code>{s}</code> placeholder in the URL template.
                         If this parameter is a single string, each character in the string is a subdomain.  If it is
                         an array, each element in the array is a subdomain.
         */
        subdomains?: string|string[];
    }
    interface IBaseLayerPickerOptions {
        /**
         * The Globe to use.
         */
        globe: Globe;
        /**
         * The array of ProviderViewModel instances to use for imagery.
         */
        imageryProviderViewModels?: ProviderViewModel[];
        /**
         * The view model for the current base imagery layer, if not supplied the first available imagery layer is used.
         */
        selectedImageryProviderViewModel?: ProviderViewModel;
        /**
         * The array of ProviderViewModel instances to use for terrain.
         */
        terrainProviderViewModels?: ProviderViewModel[];
        /**
         * The view model for the current base terrain layer, if not supplied the first available terrain layer is used.
         */
        selectedTerrainProviderViewModel?: ProviderViewModel;
    }
    interface IBaseLayerPickerViewModelOptions {
        /**
         * The Globe to use.
         */
        globe: Globe;
        /**
         * The array of ProviderViewModel instances to use for imagery.
         */
        imageryProviderViewModels?: ProviderViewModel[];
        /**
         * The view model for the current base imagery layer, if not supplied the first available imagery layer is used.
         */
        selectedImageryProviderViewModel?: ProviderViewModel;
        /**
         * The array of ProviderViewModel instances to use for terrain.
         */
        terrainProviderViewModels?: ProviderViewModel[];
        /**
         * The view model for the current base terrain layer, if not supplied the first available terrain layer is used.
         */
        selectedTerrainProviderViewModel?: ProviderViewModel;
    }
    interface IProviderViewModelOptions {
        /**
         * The name of the layer.
         */
        name: string;
        /**
         * The tooltip to show when the item is moused over.
         */
        tooltip: string;
        /**
         * An icon representing the layer.
         */
        iconUrl: string;
        /**
         * A function or Command
       that creates one or more providers which will be added to the globe when this item is selected.
         */
        creationFunction: ProviderViewModel.CreationFunction|Command;
    }
    interface ICesiumWidgetOptions {
        /**
         * The clock to use to control current time.
         */
        clock?: Clock;
        /**
         * The imagery provider to serve as the base layer. If set to <code>false</code>, no imagery provider will be added.
         */
        imageryProvider?: ImageryProvider;
        /**
         * The terrain provider.
         */
        terrainProvider?: TerrainProvider;
        /**
         * The skybox used to render the stars.  When <code>undefined</code>, the default stars are used. If set to <code>false</code>, no skyBox, Sun, or Moon will be added.
         */
        skyBox?: SkyBox;
        /**
         * Blue sky, and the glow around the Earth's limb.  Set to <code>false</code> to turn it off.
         */
        skyAtmosphere?: SkyAtmosphere;
        /**
         * The initial scene mode.
         */
        sceneMode?: number;
        /**
         * When <code>true</code>, each geometry instance will only be rendered in 3D to save GPU memory.
         */
        scene3DOnly?: Boolean;
        /**
         * If true and the configuration supports it, use order independent translucency.
         */
        orderIndependentTranslucency?: Boolean;
        /**
         * The map projection to use in 2D and Columbus View modes.
         */
        mapProjection?: MapProjection;
        /**
         * The globe to use in the scene.  If set to <code>false</code>, no globe will be added.
         */
        globe?: Globe;
        /**
         * True if this widget should control the render loop, false otherwise.
         */
        useDefaultRenderLoop?: Boolean;
        /**
         * The target frame rate when using the default render loop.
         */
        targetFrameRate?: number;
        /**
         * If true, this widget will automatically display an HTML panel to the user containing the error, if a render loop error occurs.
         */
        showRenderLoopErrors?: Boolean;
        /**
         * Context and WebGL creation properties corresponding to <code>options</code> passed to {@link Scene}.
         */
        contextOptions?: any;
        /**
         * The DOM element or ID that will contain the {@link CreditDisplay}.  If not specified, the credits are added
       to the bottom of the widget itself.
         */
        creditContainer?: Element|string;
        /**
         * A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
         */
        terrainExaggeration?: number;
        /**
         * Determines if shadows are cast by the sun.
         */
        shadows?: Boolean;
        /**
         * Determines if the terrain casts or receives shadows from the sun.
         */
        terrainShadows?: number;
        /**
         * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
         */
        mapMode2D?: number;
    }
    interface IGeocoderOptions {
        /**
         * The DOM element or ID that will contain the widget.
         */
        container: Element|string;
        /**
         * The Scene instance to use.
         */
        scene: Scene;
        /**
         * The base URL of the Bing Maps API.
         */
        url?: string;
        /**
         * The Bing Maps key for your application, which can be
       created at {@link https://www.bingmapsportal.com}.
       If this parameter is not provided, {@link BingMapsApi.defaultKey} is used.
       If {@link BingMapsApi.defaultKey} is undefined as well, a message is
       written to the console reminding you that you must create and supply a Bing Maps
       key as soon as possible.  Please do not deploy an application that uses
       this widget without creating a separate key for your application.
         */
        key?: string;
        /**
         * The duration of the camera flight to an entered location, in seconds.
         */
        flightDuration?: number;
    }
    interface IGeocoderViewModelOptions {
        /**
         * The Scene instance to use.
         */
        scene: Scene;
        /**
         * The base URL of the Bing Maps API.
         */
        url?: string;
        /**
         * The Bing Maps key for your application, which can be
       created at {@link https://www.bingmapsportal.com}.
       If this parameter is not provided, {@link BingMapsApi.defaultKey} is used.
       If {@link BingMapsApi.defaultKey} is undefined as well, a message is
       written to the console reminding you that you must create and supply a Bing Maps
       key as soon as possible.  Please do not deploy an application that uses
       this widget without creating a separate key for your application.
         */
        key?: string;
        /**
         * The duration of the camera flight to an entered location, in seconds.
         */
        flightDuration?: number;
    }
    interface INavigationHelpButtonOptions {
        /**
         * The DOM element or ID that will contain the widget.
         */
        container: Element|string;
        /**
         * True if the navigation instructions should initially be visible; otherwise, false.
         */
        instructionsInitiallyVisible?: Boolean;
    }
    interface IPerformanceWatchdogOptions {
        /**
         * The DOM element or ID that will contain the widget.
         */
        container: Element|string;
        /**
         * The {@link Scene} for which to monitor performance.
         */
        scene: Scene;
        /**
         * The
       message to display when a low frame rate is detected.  The message is interpeted as HTML, so make sure
       it comes from a trusted source so that your application is not vulnerable to cross-site scripting attacks.
         */
        lowFrameRateMessage?: string;
    }
    interface IPerformanceWatchdogViewModelOptions {
        /**
         * The Scene instance for which to monitor performance.
         */
        scene: Scene;
        /**
         * The
       message to display when a low frame rate is detected.  The message is interpeted as HTML, so make sure
       it comes from a trusted source so that your application is not vulnerable to cross-site scripting attacks.
         */
        lowFrameRateMessage?: string;
    }
    interface IToggleButtonViewModelOptions {
        /**
         * A boolean indicating whether the button should be initially toggled.
         */
        toggled?: Boolean;
        /**
         * A string containing the button's tooltip.
         */
        tooltip?: string;
    }
    interface IViewerOptions {
        /**
         * If set to false, the Animation widget will not be created.
         */
        animation?: Boolean;
        /**
         * If set to false, the BaseLayerPicker widget will not be created.
         */
        baseLayerPicker?: Boolean;
        /**
         * If set to false, the FullscreenButton widget will not be created.
         */
        fullscreenButton?: Boolean;
        /**
         * If set to true, the VRButton widget will be created.
         */
        vrButton?: Boolean;
        /**
         * If set to false, the Geocoder widget will not be created.
         */
        geocoder?: Boolean;
        /**
         * If set to false, the HomeButton widget will not be created.
         */
        homeButton?: Boolean;
        /**
         * If set to false, the InfoBox widget will not be created.
         */
        infoBox?: Boolean;
        /**
         * If set to false, the SceneModePicker widget will not be created.
         */
        sceneModePicker?: Boolean;
        /**
         * If set to false, the SelectionIndicator widget will not be created.
         */
        selectionIndicator?: Boolean;
        /**
         * If set to false, the Timeline widget will not be created.
         */
        timeline?: Boolean;
        /**
         * If set to false, the navigation help button will not be created.
         */
        navigationHelpButton?: Boolean;
        /**
         * True if the navigation instructions should initially be visible, or false if the should not be shown until the user explicitly clicks the button.
         */
        navigationInstructionsInitiallyVisible?: Boolean;
        /**
         * When <code>true</code>, each geometry instance will only be rendered in 3D to save GPU memory.
         */
        scene3DOnly?: Boolean;
        /**
         * The clock to use to control current time.
         */
        clock?: Clock;
        /**
         * The view model for the current base imagery layer, if not supplied the first available base layer is used.  This value is only valid if options.baseLayerPicker is set to true.
         */
        selectedImageryProviderViewModel?: ProviderViewModel;
        /**
         * The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if options.baseLayerPicker is set to true.
         */
        imageryProviderViewModels?: ProviderViewModel[];
        /**
         * The view model for the current base terrain layer, if not supplied the first available base layer is used.  This value is only valid if options.baseLayerPicker is set to true.
         */
        selectedTerrainProviderViewModel?: ProviderViewModel;
        /**
         * The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if options.baseLayerPicker is set to true.
         */
        terrainProviderViewModels?: ProviderViewModel[];
        /**
         * The imagery provider to use.  This value is only valid if options.baseLayerPicker is set to false.
         */
        imageryProvider?: ImageryProvider;
        /**
         * The terrain provider to use
         */
        terrainProvider?: TerrainProvider;
        /**
         * The skybox used to render the stars.  When <code>undefined</code>, the default stars are used.
         */
        skyBox?: SkyBox;
        /**
         * Blue sky, and the glow around the Earth's limb.  Set to <code>false</code> to turn it off.
         */
        skyAtmosphere?: SkyAtmosphere;
        /**
         * The element or id to be placed into fullscreen mode when the full screen button is pressed.
         */
        fullscreenElement?: Element|string;
        /**
         * True if this widget should control the render loop, false otherwise.
         */
        useDefaultRenderLoop?: Boolean;
        /**
         * The target frame rate when using the default render loop.
         */
        targetFrameRate?: number;
        /**
         * If true, this widget will automatically display an HTML panel to the user containing the error, if a render loop error occurs.
         */
        showRenderLoopErrors?: Boolean;
        /**
         * If true, this widget will automatically track the clock settings of newly added DataSources, updating if the DataSource's clock changes.  Set this to false if you want to configure the clock independently.
         */
        automaticallyTrackDataSourceClocks?: Boolean;
        /**
         * Context and WebGL creation properties corresponding to <code>options</code> passed to {@link Scene}.
         */
        contextOptions?: any;
        /**
         * The initial scene mode.
         */
        sceneMode?: number;
        /**
         * The map projection to use in 2D and Columbus View modes.
         */
        mapProjection?: MapProjection;
        /**
         * The globe to use in the scene.  If set to <code>false</code>, no globe will be added.
         */
        globe?: Globe;
        /**
         * If true and the configuration supports it, use order independent translucency.
         */
        orderIndependentTranslucency?: Boolean;
        /**
         * The DOM element or ID that will contain the {@link CreditDisplay}.  If not specified, the credits are added to the bottom of the widget itself.
         */
        creditContainer?: Element|string;
        /**
         * The collection of data sources visualized by the widget.  If this parameter is provided,
                              the instance is assumed to be owned by the caller and will not be destroyed when the viewer is destroyed.
         */
        dataSources?: DataSourceCollection;
        /**
         * A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
         */
        terrainExaggeration?: number;
        /**
         * Determines if shadows are cast by the sun.
         */
        shadows?: Boolean;
        /**
         * Determines if the terrain casts or receives shadows from the sun.
         */
        terrainShadows?: number;
        /**
         * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
         */
        mapMode2D?: number;
    }
    module HeightmapTessellator {
        interface IHeightmapTessellatorComputeVerticesOptions {
            /**
             * The heightmap to tessellate.
             */
            heightmap: TypedArray;
            /**
             * The width of the heightmap, in height samples.
             */
            width: number;
            /**
             * The height of the heightmap, in height samples.
             */
            height: number;
            /**
             * The height of skirts to drape at the edges of the heightmap.
             */
            skirtHeight: number;
            /**
             * An rectangle in the native coordinates of the heightmap's projection.  For
                a heightmap with a geographic projection, this is degrees.  For the web mercator
                projection, this is meters.
             */
            nativeRectangle: Rectangle;
            /**
             * The scale used to exaggerate the terrain.
             */
            exaggeration?: number;
            /**
             * The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and
                west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both
                are provided, they're assumed to be consistent.
             */
            rectangle?: Rectangle;
            /**
             * True if the heightmap uses a {@link GeographicProjection}, or false if it uses
                 a {@link WebMercatorProjection}.
             */
            isGeographic?: Boolean;
            /**
             * The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.
             */
            relativetoCenter?: Cartesian3;
            /**
             * The ellipsoid to which the heightmap applies.
             */
            ellipsoid?: Ellipsoid;
            /**
             * An object describing the structure of the height data.
             */
            structure?: any;
            /**
             * The factor by which to multiply height samples in order to obtain
                the height above the heightOffset, in meters.  The heightOffset is added to the resulting
                height after multiplying by the scale.
             */
            heightScale?: number;
            /**
             * The offset to add to the scaled height to obtain the final
                height in meters.  The offset is added after the height sample is multiplied by the
                heightScale.
             */
            heightOffset?: number;
            /**
             * The number of elements in the buffer that make up a single height
                sample.  This is usually 1, indicating that each element is a separate height sample.  If
                it is greater than 1, that number of elements together form the height sample, which is
                computed according to the structure.elementMultiplier and structure.isBigEndian properties.
             */
            elementsPerHeight?: number;
            /**
             * The number of elements to skip to get from the first element of
                one height to the first element of the next height.
             */
            stride?: number;
            /**
             * The multiplier used to compute the height value when the
                stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier
                is 256, the height is computed as follows:
                `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`
                This is assuming that the isBigEndian property is false.  If it is true, the order of the
                elements is reversed.
             */
            elementMultiplier?: number;
            /**
             * The lowest value that can be stored in the height buffer.  Any heights that are lower
                than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
                buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is
                not specified, no minimum value is enforced.
             */
            lowestEncodedHeight?: number;
            /**
             * The highest value that can be stored in the height buffer.  Any heights that are higher
                than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
                buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger
                than 65535.  If this parameter is not specified, no maximum value is enforced.
             */
            highestEncodedHeight?: number;
            /**
             * Indicates endianness of the elements in the buffer when the
                 stride property is greater than 1.  If this property is false, the first element is the
                 low-order element.  If it is true, the first element is the high-order element.
             */
            isBigEndian?: Boolean;
        }
    }
    module Tipsify {
        interface ITipsifyCalculateACMROptions {
            /**
             * Lists triads of numbers corresponding to the indices of the vertices
                       in the vertex buffer that define the geometry's triangles.
             */
            indices: number[];
            /**
             * The maximum value of the elements in <code>args.indices</code>.
                                    If not supplied, this value will be computed.
             */
            maximumIndex?: number;
            /**
             * The number of vertices that can be stored in the cache at any one time.
             */
            cacheSize?: number;
        }
        interface ITipsifyTipsifyOptions {
            /**
             * Lists triads of numbers corresponding to the indices of the vertices
                       in the vertex buffer that define the geometry's triangles.
             */
            indices: number[];
            /**
             * The maximum value of the elements in <code>args.indices</code>.
                                    If not supplied, this value will be computed.
             */
            maximumIndex?: number;
            /**
             * The number of vertices that can be stored in the cache at any one time.
             */
            cacheSize?: number;
        }
    }
    module Buffer {
        interface IBufferCreateVertexBufferOptions {
            /**
             * The context in which to create the buffer
             */
            context: Context;
            /**
             * A typed array containing the data to copy to the buffer.
             */
            typedArray?: ArrayBufferView;
            /**
             * A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.
             */
            sizeInBytes?: number;
            /**
             * Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.
             */
            usage: BufferUsage;
        }
        interface IBufferCreateIndexBufferOptions {
            /**
             * The context in which to create the buffer
             */
            context: Context;
            /**
             * A typed array containing the data to copy to the buffer.
             */
            typedArray?: ArrayBufferView;
            /**
             * A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.
             */
            sizeInBytes?: number;
            /**
             * Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.
             */
            usage: BufferUsage;
        }
        /**
         * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.
<br /><br />
A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,
etc., by interpreting the raw data in one or more vertex buffers.
         * @param options  (Required) An object containing the following properties:
         */
        function createVertexBuffer(options: Buffer.IBufferCreateVertexBufferOptions): VertexBuffer;
        /**
         * Creates an index buffer, which contains typed indices in GPU-controlled memory.
<br /><br />
An index buffer can be attached to a vertex array to select vertices for rendering.
<code>Context.draw</code> can render using the entire index buffer or a subset
of the index buffer defined by an offset and count.
         * @param options  (Required) An object containing the following properties:
         * @param indexDatatype  (Required) The datatype of indices in the buffer.
         */
        function createIndexBuffer(options: Buffer.IBufferCreateIndexBufferOptions, indexDatatype: number): IndexBuffer;
    }
    module ShaderCache {
        interface IShaderCacheReplaceShaderProgramOptions {
            /**
             * The shader program that is being reassigned.
             */
            shaderProgram?: ShaderProgram;
            /**
             * The GLSL source for the vertex shader.
             */
            vertexShaderSource: string|ShaderSource;
            /**
             * The GLSL source for the fragment shader.
             */
            fragmentShaderSource: string|ShaderSource;
            /**
             * Indices for the attribute inputs to the vertex shader.
             */
            attributeLocations: any;
        }
        interface IShaderCacheGetShaderProgramOptions {
            /**
             * The GLSL source for the vertex shader.
             */
            vertexShaderSource: string|ShaderSource;
            /**
             * The GLSL source for the fragment shader.
             */
            fragmentShaderSource: string|ShaderSource;
            /**
             * Indices for the attribute inputs to the vertex shader.
             */
            attributeLocations: any;
        }
        /**
         * Returns a shader program from the cache, or creates and caches a new shader program,
given the GLSL vertex and fragment shader source and attribute locations.
<p>
The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to
replace an existing reference to a shader program, which is passed as the first argument.
</p>
         * @param options  (Required) Object with the following properties:
         */
        function replaceShaderProgram(options: ShaderCache.IShaderCacheReplaceShaderProgramOptions): ShaderProgram;
        /**
         * Returns a shader program from the cache, or creates and caches a new shader program,
given the GLSL vertex and fragment shader source and attribute locations.
         * @param options  (Required) Object with the following properties:
         */
        function getShaderProgram(options: ShaderCache.IShaderCacheGetShaderProgramOptions): ShaderProgram;
    }
    module BoxGeometry {
        interface IBoxGeometryFromDimensionsOptions {
            /**
             * The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
             */
            dimensions: Cartesian3;
            /**
             * The vertex attributes to be computed.
             */
            vertexFormat?: VertexFormat;
        }
    }
    module BoxOutlineGeometry {
        interface IBoxOutlineGeometryFromDimensionsOptions {
            /**
             * The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
             */
            dimensions: Cartesian3;
        }
    }
    module Color {
        interface IColorFromRandomOptions {
            /**
             * If specified, the red component to use instead of a randomized value.
             */
            red?: number;
            /**
             * The maximum red value to generate if none was specified.
             */
            minimumRed?: number;
            /**
             * The minimum red value to generate if none was specified.
             */
            maximumRed?: number;
            /**
             * If specified, the green component to use instead of a randomized value.
             */
            green?: number;
            /**
             * The maximum green value to generate if none was specified.
             */
            minimumGreen?: number;
            /**
             * The minimum green value to generate if none was specified.
             */
            maximumGreen?: number;
            /**
             * If specified, the blue component to use instead of a randomized value.
             */
            blue?: number;
            /**
             * The maximum blue value to generate if none was specified.
             */
            minimumBlue?: number;
            /**
             * The minimum blue value to generate if none was specified.
             */
            maximumBlue?: number;
            /**
             * If specified, the alpha component to use instead of a randomized value.
             */
            alpha?: number;
            /**
             * The maximum alpha value to generate if none was specified.
             */
            minimumAlpha?: number;
            /**
             * The minimum alpha value to generate if none was specified.
             */
            maximumAlpha?: number;
        }
    }
    module HermiteSpline {
        interface IHermiteSplineCreateC1Options {
            /**
             * The array of control point times.
             */
            times: number[];
            /**
             * The array of control points.
             */
            points: Cartesian3[];
            /**
             * The array of tangents at the control points.
             */
            tangents: Cartesian3[];
        }
        interface IHermiteSplineCreateNaturalCubicOptions {
            /**
             * The array of control point times.
             */
            times: number[];
            /**
             * The array of control points.
             */
            points: Cartesian3[];
        }
        interface IHermiteSplineCreateClampedCubicOptions {
            /**
             * The array of control point times.
             */
            times: number[];
            /**
             * The array of control points.
             */
            points: Cartesian3[];
            /**
             * The outgoing tangent of the first control point.
             */
            firstTangent: Cartesian3;
            /**
             * The incoming tangent of the last control point.
             */
            lastTangent: Cartesian3;
        }
    }
    module PolygonGeometry {
        interface IPolygonGeometryFromPositionsOptions {
            /**
             * An array of positions that defined the corner points of the polygon.
             */
            positions: Cartesian3[];
            /**
             * The height of the polygon.
             */
            height?: number;
            /**
             * The height of the polygon extrusion.
             */
            extrudedHeight?: number;
            /**
             * The vertex attributes to be computed.
             */
            vertexFormat?: VertexFormat;
            /**
             * The rotation of the texture coordiantes, in radians. A positive rotation is counter-clockwise.
             */
            stRotation?: number;
            /**
             * The ellipsoid to be used as a reference.
             */
            ellipsoid?: Ellipsoid;
            /**
             * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
             */
            granularity?: number;
            /**
             * Use the height of options.positions for each position instead of using options.height to determine the height.
             */
            perPositionHeight?: Boolean;
            /**
             * When false, leaves off the top of an extruded polygon open.
             */
            closeTop?: Boolean;
            /**
             * When false, leaves off the bottom of an extruded polygon open.
             */
            closeBottom?: Boolean;
        }
    }
    module PolygonOutlineGeometry {
        interface IPolygonOutlineGeometryFromPositionsOptions {
            /**
             * An array of positions that defined the corner points of the polygon.
             */
            positions: Cartesian3[];
            /**
             * The height of the polygon.
             */
            height?: number;
            /**
             * The height of the polygon extrusion.
             */
            extrudedHeight?: number;
            /**
             * The ellipsoid to be used as a reference.
             */
            ellipsoid?: Ellipsoid;
            /**
             * The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
             */
            granularity?: number;
            /**
             * Use the height of options.positions for each position instead of using options.height to determine the height.
             */
            perPositionHeight?: Boolean;
        }
    }
    module TimeInterval {
        interface ITimeIntervalFromIso8601Options {
            /**
             * An ISO 8601 interval.
             */
            iso8601: string;
            /**
             * <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
             */
            isStartIncluded?: Boolean;
            /**
             * <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
             */
            isStopIncluded?: Boolean;
            /**
             * Arbitrary data associated with this interval.
             */
            data?: any;
        }
        /**
         * Function interface for merging interval data.
         */
        type MergeCallback = (leftData: any, rightData: any) => any;
        /**
         * Function interface for comparing interval data.
         */
        type DataComparer = (leftData: any, rightData: any) => Boolean;
    }
    module TimeIntervalCollection {
        interface ITimeIntervalCollectionFindIntervalOptions {
            /**
             * The start time of the interval.
             */
            start?: JulianDate;
            /**
             * The stop time of the interval.
             */
            stop?: JulianDate;
            /**
             * <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
             */
            isStartIncluded?: Boolean;
            /**
             * <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
             */
            isStopIncluded?: Boolean;
        }
    }
    module WallGeometry {
        interface IWallGeometryFromConstantHeightsOptions {
            /**
             * An array of Cartesian objects, which are the points of the wall.
             */
            positions: Cartesian3[];
            /**
             * A constant that defines the maximum height of the
       wall at <code>positions</code>. If undefined, the height of each position in used.
             */
            maximumHeight?: number;
            /**
             * A constant that defines the minimum height of the
       wall at <code>positions</code>. If undefined, the height at each position is 0.0.
             */
            minimumHeight?: number;
            /**
             * The ellipsoid for coordinate manipulation
             */
            ellipsoid?: Ellipsoid;
            /**
             * The vertex attributes to be computed.
             */
            vertexFormat?: VertexFormat;
        }
    }
    module WallOutlineGeometry {
        interface IWallOutlineGeometryFromConstantHeightsOptions {
            /**
             * An array of Cartesian objects, which are the points of the wall.
             */
            positions: Cartesian3[];
            /**
             * A constant that defines the maximum height of the
       wall at <code>positions</code>. If undefined, the height of each position in used.
             */
            maximumHeight?: number;
            /**
             * A constant that defines the minimum height of the
       wall at <code>positions</code>. If undefined, the height at each position is 0.0.
             */
            minimumHeight?: number;
            /**
             * The ellipsoid for coordinate manipulation
             */
            ellipsoid?: Ellipsoid;
        }
    }
    module CzmlDataSource {
        interface ICzmlDataSourceLoadOptions {
            /**
             * Overrides the url to use for resolving relative links.
             */
            sourceUri?: string;
        }
        interface ICzmlDataSourceProcessOptions {
            /**
             * Overrides the url to use for resolving relative links.
             */
            sourceUri?: string;
        }
    }
    module GeoJsonDataSource {
        interface IGeoJsonDataSourceLoadOptions {
            /**
             * Overrides the url to use for resolving relative links.
             */
            sourceUri?: string;
            /**
             * The default size of the map pin created for each point, in pixels.
             */
            markerSize?: number;
            /**
             * The default symbol of the map pin created for each point.
             */
            markerSymbol?: string;
            /**
             * The default color of the map pin created for each point.
             */
            markerColor?: number;
            /**
             * The default color of polylines and polygon outlines.
             */
            stroke?: number;
            /**
             * The default width of polylines and polygon outlines.
             */
            strokeWidth?: number;
            /**
             * The default color for polygon interiors.
             */
            fill?: number;
            /**
             * true if we want the geometry features (polygons or linestrings) clamped to the ground. If true, lines will use corridors so use Entity.corridor instead of Entity.polyline.
             */
            clampToGround?: Boolean;
        }
        /**
         * This callback is displayed as part of the GeoJsonDataSource class.
         */
        type describe = (properties: any, nameProperty: string) => void;
    }
    module KmlDataSource {
        interface IKmlDataSourceLoadOptions {
            /**
             * The camera that is used for viewRefreshModes and sending camera properties to network links.
             */
            camera: Camera;
            /**
             * The canvas that is used for sending viewer properties to network links.
             */
            canvas: HTMLCanvasElement;
            /**
             * A proxy to be used for loading external data.
             */
            proxy?: DefaultProxy;
            /**
             * Overrides the url to use for resolving relative links and other KML network features.
             */
            sourceUri?: string;
            /**
             * true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground. If true, lines will use corridors so use Entity.corridor instead of Entity.polyline.
             */
            clampToGround?: Boolean;
        }
    }
    module SampledPositionProperty {
        interface ISampledPositionPropertySetInterpolationOptionsOptions {
            /**
             * The new interpolation algorithm.  If undefined, the existing property will be unchanged.
             */
            interpolationAlgorithm?: number;
            /**
             * The new interpolation degree.  If undefined, the existing property will be unchanged.
             */
            interpolationDegree?: number;
        }
    }
    module SampledProperty {
        interface ISampledPropertySetInterpolationOptionsOptions {
            /**
             * The new interpolation algorithm.  If undefined, the existing property will be unchanged.
             */
            interpolationAlgorithm?: number;
            /**
             * The new interpolation degree.  If undefined, the existing property will be unchanged.
             */
            interpolationDegree?: number;
        }
    }
    module Camera {
        interface ICameraSetViewOptions {
            /**
             * The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
             */
            destination?: Cartesian3|Rectangle;
            /**
             * An object that contains either direction and up properties or heading, pith and roll properties. By default, the direction will point
towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.
             */
            orientation?: any;
            /**
             * Transform matrix representing the reference frame of the camera.
             */
            endTransform?: Matrix4;
        }
        interface ICameraFlyToOptions {
            /**
             * The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
             */
            destination: Cartesian3|Rectangle;
            /**
             * An object that contains either direction and up properties or heading, pith and roll properties. By default, the direction will point
towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.
             */
            orientation?: any;
            /**
             * The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
             */
            duration?: number;
            /**
             * The function to execute when the flight is complete.
             */
            complete?: Camera.FlightCompleteCallback;
            /**
             * The function to execute if the flight is cancelled.
             */
            cancel?: Camera.FlightCancelledCallback;
            /**
             * Transform matrix representing the reference frame the camera will be in when the flight is completed.
             */
            endTransform?: Matrix4;
            /**
             * The maximum height at the peak of the flight.
             */
            maximumHeight?: number;
            /**
             * Controls how the time is interpolated over the duration of the flight.
             */
            easingFunction?: number|EasingFunction.Callback;
        }
        interface ICameraFlyToBoundingSphereOptions {
            /**
             * The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
             */
            duration?: number;
            /**
             * The offset from the target in the local east-north-up reference frame centered at the target.
             */
            offset?: HeadingPitchRange;
            /**
             * The function to execute when the flight is complete.
             */
            complete?: Camera.FlightCompleteCallback;
            /**
             * The function to execute if the flight is cancelled.
             */
            cancel?: Camera.FlightCancelledCallback;
            /**
             * Transform matrix representing the reference frame the camera will be in when the flight is completed.
             */
            endTransform?: Matrix4;
            /**
             * The maximum height at the peak of the flight.
             */
            maximumHeight?: number;
            /**
             * Controls how the time is interpolated over the duration of the flight.
             */
            easingFunction?: number|EasingFunction.Callback;
        }
        /**
         * A function that will execute when a flight completes.
         */
        type FlightCompleteCallback = () => void;
        /**
         * A function that will execute when a flight is cancelled.
         */
        type FlightCancelledCallback = () => void;
    }
    module Model {
        interface IModelFromGltfOptions {
            /**
             * The url to the .gltf file.
             */
            url: string;
            /**
             * HTTP headers to send with the request.
             */
            headers?: any;
            /**
             * Determines if the model primitive will be shown.
             */
            show?: Boolean;
            /**
             * The 4x4 transformation matrix that transforms the model from model to world coordinates.
             */
            modelMatrix?: Matrix4;
            /**
             * A uniform scale applied to this model.
             */
            scale?: number;
            /**
             * The approximate minimum pixel size of the model regardless of zoom.
             */
            minimumPixelSize?: number;
            /**
             * The maximum scale for the model.
             */
            maximumScale?: number;
            /**
             * A user-defined object to return when the model is picked with {@link Scene#pick}.
             */
            id?: any;
            /**
             * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.
             */
            allowPicking?: Boolean;
            /**
             * Determine if textures may continue to stream in after the model is loaded.
             */
            incrementallyLoadTextures?: Boolean;
            /**
             * Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.
             */
            asynchronous?: Boolean;
            /**
             * Determines whether the model casts or receives shadows from each light source.
             */
            shadows?: number;
            /**
             * For debugging only. Draws the bounding sphere for each {@link DrawCommand} in the model.
             */
            debugShowBoundingVolume?: Boolean;
            /**
             * For debugging only. Draws the model in wireframe.
             */
            debugWireframe?: Boolean;
        }
    }
    module ModelAnimationCollection {
        interface IModelAnimationCollectionAddOptions {
            /**
             * The glTF animation name that identifies the animation.
             */
            name: string;
            /**
             * The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.
             */
            startTime?: JulianDate;
            /**
             * The delay, in seconds, from <code>startTime</code> to start playing.
             */
            delay?: number;
            /**
             * The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.
             */
            stopTime?: JulianDate;
            /**
             * When <code>true</code>, the animation is removed after it stops playing.
             */
            removeOnStop?: Boolean;
            /**
             * Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
             */
            speedup?: number;
            /**
             * When <code>true</code>, the animation is played in reverse.
             */
            reverse?: Boolean;
            /**
             * Determines if and how the animation is looped.
             */
            loop?: number;
        }
        interface IModelAnimationCollectionAddAllOptions {
            /**
             * The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.
             */
            startTime?: JulianDate;
            /**
             * The delay, in seconds, from <code>startTime</code> to start playing.
             */
            delay?: number;
            /**
             * The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.
             */
            stopTime?: JulianDate;
            /**
             * When <code>true</code>, the animations are removed after they stop playing.
             */
            removeOnStop?: Boolean;
            /**
             * Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
             */
            speedup?: number;
            /**
             * When <code>true</code>, the animations are played in reverse.
             */
            reverse?: Boolean;
            /**
             * Determines if and how the animations are looped.
             */
            loop?: number;
        }
    }
    module Viewer {
        interface IViewerFlyToOptions {
            /**
             * The duration of the flight in seconds.
             */
            duration?: number;
            /**
             * The maximum height at the peak of the flight.
             */
            maximumHeight?: number;
            /**
             * The offset from the target in the local east-north-up reference frame centered at the target.
             */
            offset?: HeadingPitchRange;
        }
        /**
         * A function that augments a Viewer instance with additional functionality.
         */
        type ViewerMixin = (viewer: Viewer, options: any) => void;
    }
    module binarySearch {
        /**
         * A function used to compare two items while performing a binary search.
         */
        type Comparator = (a: any, b: any) => number;
    }
    module EasingFunction {
        /**
         * Function interface for implementing a custom easing function.
         */
        type Callback = (time: number) => number;
        /**
         * Linear easing.
         */
        var LINEAR_NONE: EasingFunction.Callback;
        /**
         * Quadratic in.
         */
        var QUADRACTIC_IN: EasingFunction.Callback;
        /**
         * Quadratic out.
         */
        var QUADRACTIC_OUT: EasingFunction.Callback;
        /**
         * Quadratic in then out.
         */
        var QUADRACTIC_IN_OUT: EasingFunction.Callback;
        /**
         * Cubic in.
         */
        var CUBIC_IN: EasingFunction.Callback;
        /**
         * Cubic out.
         */
        var CUBIC_OUT: EasingFunction.Callback;
        /**
         * Cubic in then out.
         */
        var CUBIC_IN_OUT: EasingFunction.Callback;
        /**
         * Quartic in.
         */
        var QUARTIC_IN: EasingFunction.Callback;
        /**
         * Quartic out.
         */
        var QUARTIC_OUT: EasingFunction.Callback;
        /**
         * Quartic in then out.
         */
        var QUARTIC_IN_OUT: EasingFunction.Callback;
        /**
         * Quintic in.
         */
        var QUINTIC_IN: EasingFunction.Callback;
        /**
         * Quintic out.
         */
        var QUINTIC_OUT: EasingFunction.Callback;
        /**
         * Quintic in then out.
         */
        var QUINTIC_IN_OUT: EasingFunction.Callback;
        /**
         * Sinusoidal in.
         */
        var SINUSOIDAL_IN: EasingFunction.Callback;
        /**
         * Sinusoidal out.
         */
        var SINUSOIDAL_OUT: EasingFunction.Callback;
        /**
         * Sinusoidal in then out.
         */
        var SINUSOIDAL_IN_OUT: EasingFunction.Callback;
        /**
         * Exponential in.
         */
        var EXPONENTIAL_IN: EasingFunction.Callback;
        /**
         * Exponential out.
         */
        var EXPONENTIAL_OUT: EasingFunction.Callback;
        /**
         * Exponential in then out.
         */
        var EXPONENTIAL_IN_OUT: EasingFunction.Callback;
        /**
         * Circular in.
         */
        var CIRCULAR_IN: EasingFunction.Callback;
        /**
         * Circular out.
         */
        var CIRCULAR_OUT: EasingFunction.Callback;
        /**
         * Circular in then out.
         */
        var CIRCULAR_IN_OUT: EasingFunction.Callback;
        /**
         * Elastic in.
         */
        var ELASTIC_IN: EasingFunction.Callback;
        /**
         * Elastic out.
         */
        var ELASTIC_OUT: EasingFunction.Callback;
        /**
         * Elastic in then out.
         */
        var ELASTIC_IN_OUT: EasingFunction.Callback;
        /**
         * Back in.
         */
        var BACK_IN: EasingFunction.Callback;
        /**
         * Back out.
         */
        var BACK_OUT: EasingFunction.Callback;
        /**
         * Back in then out.
         */
        var BACK_IN_OUT: EasingFunction.Callback;
        /**
         * Bounce in.
         */
        var BOUNCE_IN: EasingFunction.Callback;
        /**
         * Bounce out.
         */
        var BOUNCE_OUT: EasingFunction.Callback;
        /**
         * Bounce in then out.
         */
        var BOUNCE_IN_OUT: EasingFunction.Callback;
    }
    module Event {
        /**
         * A function that removes a listener.
         */
        type RemoveCallback = () => void;
    }
    module EventHelper {
        /**
         * A function that removes a listener.
         */
        type RemoveCallback = () => void;
    }
    module IauOrientationAxes {
        /**
         * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.
         */
        type ComputeFunction = (date: JulianDate) => IauOrientationParameters;
    }
    module mergeSort {
        /**
         * A function used to compare two items while performing a merge sort.
         */
        type Comparator = (a: any, b: any, userDefinedObject?: any) => number;
    }
    module Queue {
        /**
         * A function used to compare two items while sorting a queue.
         */
        type Comparator = (a: any, b: any) => number;
    }
    module requestAnimationFrame {
        /**
         * A function that will be called when the next frame should be drawn.
         */
        type Callback = (timestamp: number) => void;
    }
    module throttleRequestByServer {
        /**
         * A function that will make a request if there are available slots to the server.
         */
        type RequestFunction = (url: string) => Promise<any>;
        /**
         * Specifies the maximum number of requests that can be simultaneously open to a single server.  If this value is higher than
the number of requests per server actually allowed by the web browser, Cesium's ability to prioritize requests will be adversely
affected.
         */
        var maximumRequestsPerServer: number;
    }
    module TileProviderError {
        /**
         * A function that will be called to retry the operation.
         */
        type RetryFunction = () => void;
    }
    module CallbackProperty {
        /**
         * A function that returns the value of the property.
         */
        type Callback = (time?: JulianDate, result?: any) => any;
    }
    module DataSourceDisplay {
        /**
         * A function which creates an array of visualizers used for visualization.
         */
        type VisualizersCallback = (scene: Scene, dataSource: DataSource) => Visualizer[];
    }
    module EntityCluster {
        /**
         * A event listener function used to style clusters.
         */
        type newClusterCallback = (clusteredEntities: Entity[], cluster: any) => void;
    }
    module BatchTable {
        /**
         * A callback for updating uniform maps.
         */
        type updateUniformMapCallback = (uniformMap: any) => any;
        /**
         * A callback for updating a vertex shader source.
         */
        type updateVertexShaderSourceCallback = (vertexShaderSource: string) => string;
    }
    module Billboard {
        /**
         * A function that creates an image.
         */
        type CreateImageCallback = (id: string) => HTMLImageElement|HTMLCanvasElement|Promise<HTMLImageElement|HTMLCanvasElement>;
    }
    module FrameState {
        /**
         * A function that will be called at the end of the frame.
         */
        type AfterRenderCallback = () => void;
    }
    module TweenCollection {
        /**
         * A function that will execute when a tween completes.
         */
        type TweenCompleteCallback = () => void;
        /**
         * A function that will execute when a tween updates.
         */
        type TweenUpdateCallback = () => void;
        /**
         * A function that will execute when a tween is cancelled.
         */
        type TweenCancelledCallback = () => void;
    }
    module AnimationViewModel {
        /**
         * A function that formats a date for display.
         */
        type DateFormatter = (date: JulianDate, viewModel: AnimationViewModel) => string;
        /**
         * A function that formats a time for display.
         */
        type TimeFormatter = (date: JulianDate, viewModel: AnimationViewModel) => string;
    }
    module ProviderViewModel {
        /**
         * A function which creates one or more providers.
         */
        type CreationFunction = () => ImageryProvider|TerrainProvider|ImageryProvider[]|TerrainProvider[];
    }
    module SelectionIndicatorViewModel {
        /**
         * A function that converts the world position of an object to a screen space position.
         */
        type ComputeScreenSpacePosition = (position: Cartesian3, result: Cartesian2) => Cartesian2;
    }
    module createTaskProcessorWorker {
        /**
         * A function that performs a calculation in a Web Worker.
         */
        type WorkerFunction = (parameters: any, transferableObjects: any[]) => any;
        /**
         * A Web Worker message event handler function that handles the interaction with TaskProcessor,
specifically, task ID management and posting a response message containing the result.
         */
        type TaskProcessorWorkerFunction = (event: any) => void;
    }
    module BingMapsApi {
        /**
         * The default Bing Maps API key to use if one is not provided to the
constructor of an object that uses the Bing Maps API.  If this property is undefined,
Cesium's default key is used, which is only suitable for use early in development.
Please generate your own key by visiting
{@link https://www.bingmapsportal.com/}
as soon as possible and prior to deployment.  When Cesium's default key is used,
a message is printed to the console the first time the Bing Maps API is used.
         */
        var defaultKey: string;
    }
    module buildModuleUrl {
        /**
         * Sets the base URL for resolving modules.
         * @param value  (Required) The new base URL.
         */
        function setBaseUrl(value: string): void;
    }
    module ClockRange {
        /**
         * {@link Clock#tick} will always advances the clock in its current direction.
         */
        var UNBOUNDED: number;
        /**
         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
{@link Clock#tick} will not advance {@link Clock#currentTime} any further.
         */
        var CLAMPED: number;
        /**
         * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
{@link Clock#currentTime} to the opposite end of the interval.  When
time is moving backwards, {@link Clock#tick} will not advance past
{@link Clock#startTime}
         */
        var LOOP_STOP: number;
    }
    module ClockStep {
        /**
         * {@link Clock#tick} advances the current time by a fixed step,
which is the number of seconds specified by {@link Clock#multiplier}.
         */
        var TICK_DEPENDENT: number;
        /**
         * {@link Clock#tick} advances the current time by the amount of system
time elapsed since the previous call multiplied by {@link Clock#multiplier}.
         */
        var SYSTEM_CLOCK_MULTIPLIER: number;
        /**
         * {@link Clock#tick} sets the clock to the current system time;
ignoring all other settings.
         */
        var SYSTEM_CLOCK: number;
    }
    module ComponentDatatype {
        /**
         * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type
of an element in <code>Int8Array</code>.
         */
        var BYTE: number;
        /**
         * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
of an element in <code>Uint8Array</code>.
         */
        var UNSIGNED_BYTE: number;
        /**
         * 16-bit signed short corresponding to <code>SHORT</code> and the type
of an element in <code>Int16Array</code>.
         */
        var SHORT: number;
        /**
         * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
of an element in <code>Uint16Array</code>.
         */
        var UNSIGNED_SHORT: number;
        /**
         * 32-bit signed int corresponding to <code>INT</code> and the type
of an element in <code>Int32Array</code>.
         */
        var INT: number;
        /**
         * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
of an element in <code>Uint32Array</code>.
         */
        var UNSIGNED_INT: number;
        /**
         * 32-bit floating-point corresponding to <code>FLOAT</code> and the type
of an element in <code>Float32Array</code>.
         */
        var FLOAT: number;
        /**
         * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;
this is not supported in WebGL, and is emulated in Cesium via {@link GeometryPipeline.encodeAttribute})
and the type of an element in <code>Float64Array</code>.
         */
        var DOUBLE: number;
        /**
         * Returns the size, in bytes, of the corresponding datatype.
         * @param componentDatatype  (Required) The component datatype to get the size of.
         */
        function getSizeInBytes(componentDatatype: number): number;
        /**
         * Gets the {@link ComponentDatatype} for the provided TypedArray instance.
         * @param array  (Required) The typed array.
         */
        function fromTypedArray(array: TypedArray): number;
        /**
         * Validates that the provided component datatype is a valid {@link ComponentDatatype}
         * @param componentDatatype  (Required) The component datatype to validate.
         */
        function validate(componentDatatype: number): Boolean;
        /**
         * Creates a typed array corresponding to component data type.
         * @param componentDatatype  (Required) The component data type.
         * @param valuesOrLength  (Required) The length of the array to create or an array.
         */
        function createTypedArray(componentDatatype: number, valuesOrLength: number|any[]): Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array;
        /**
         * Creates a typed view of an array of bytes.
         * @param componentDatatype  (Required) The type of the view to create.
         * @param buffer  (Required) The buffer storage to use for the view.
         * @param byteOffset  (Optional) The offset, in bytes, to the first element in the view.
         * @param length  (Optional) The number of elements in the view.
         */
        function createArrayBufferView(componentDatatype: number, buffer: ArrayBuffer, byteOffset?: number, length?: number): Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array;
        /**
         * Get the ComponentDatatype from its name.
         * @param name  (Required) The name of the ComponentDatatype.
         */
        function fromName(name: string): number;
    }
    module CornerType {
        /**
         * <img src="images/CornerTypeRounded.png" style="vertical-align: middle;" width="186" height="189" />

Corner has a smooth edge.
         */
        var ROUNDED: number;
        /**
         * <img src="images/CornerTypeMitered.png" style="vertical-align: middle;" width="186" height="189" />

Corner point is the intersection of adjacent edges.
         */
        var MITERED: number;
        /**
         * <img src="images/CornerTypeBeveled.png" style="vertical-align: middle;" width="186" height="189" />

Corner is clipped.
         */
        var BEVELED: number;
    }
    module CubicRealPolynomial {
        /**
         * Provides the discriminant of the cubic equation from the supplied coefficients.
         * @param a  (Required) The coefficient of the 3rd order monomial.
         * @param b  (Required) The coefficient of the 2nd order monomial.
         * @param c  (Required) The coefficient of the 1st order monomial.
         * @param d  (Required) The coefficient of the 0th order monomial.
         */
        function computeDiscriminant(a: number, b: number, c: number, d: number): number;
        /**
         * Provides the real valued roots of the cubic polynomial with the provided coefficients.
         * @param a  (Required) The coefficient of the 3rd order monomial.
         * @param b  (Required) The coefficient of the 2nd order monomial.
         * @param c  (Required) The coefficient of the 1st order monomial.
         * @param d  (Required) The coefficient of the 0th order monomial.
         */
        function computeRealRoots(a: number, b: number, c: number, d: number): number[];
    }
    module defaultValue {
        /**
         * A frozen empty object that can be used as the default value for options passed as
an object literal.
         */
        var EMPTY_OBJECT: any;
    }
    module ExtrapolationType {
        /**
         * No extrapolation occurs.
         */
        var NONE: number;
        /**
         * The first or last value is used when outside the range of sample data.
         */
        var HOLD: number;
        /**
         * The value is extrapolated.
         */
        var EXTRAPOLATE: number;
    }
    module FeatureDetection {
        /**
         * Detects whether the current browser supports the full screen standard.
         */
        function supportsFullscreen(): Boolean;
        /**
         * Detects whether the current browser supports typed arrays.
         */
        function supportsTypedArrays(): Boolean;
        /**
         * Detects whether the current browser supports Web Workers.
         */
        function supportsWebWorkers(): Boolean;
    }
    module Fullscreen {
        /**
         * The element that is currently fullscreen, if any.  To simply check if the
browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
         */
        var element: any;
        /**
         * The name of the event on the document that is fired when fullscreen is
entered or exited.  This event name is intended for use with addEventListener.
In your event handler, to determine if the browser is in fullscreen mode or not,
use {@link Fullscreen#fullscreen}.
         */
        var changeEventName: string;
        /**
         * The name of the event that is fired when a fullscreen error
occurs.  This event name is intended for use with addEventListener.
         */
        var errorEventName: string;
        /**
         * Determine whether the browser will allow an element to be made fullscreen, or not.
For example, by default, iframes cannot go fullscreen unless the containing page
adds an "allowfullscreen" attribute (or prefixed equivalent).
         */
        var enabled: Boolean;
        /**
         * Determines if the browser is currently in fullscreen mode.
         */
        var fullscreen: Boolean;
        /**
         * Detects whether the browser supports the standard fullscreen API.
         */
        function supportsFullscreen(): Boolean;
        /**
         * Asynchronously requests the browser to enter fullscreen mode on the given element.
If fullscreen mode is not supported by the browser, does nothing.
         * @param element  (Required) The HTML element which will be placed into fullscreen mode.
         * @param vrDevice  (Optional) The VR device.
         */
        function requestFullscreen(element: any, vrDevice?: HMDVRDevice): void;
        /**
         * Asynchronously exits fullscreen mode.  If the browser is not currently
in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
         */
        function exitFullscreen(): void;
    }
    module GeometryPipeline {
        /**
         * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>
and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,
<code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.
<p>
This is commonly used to create a wireframe geometry for visual debugging.
</p>
         * @param geometry  (Required) The geometry to modify.
         */
        function toWireframe(geometry: Geometry): Geometry;
        /**
         * Creates a new {@link Geometry} with <code>LINES</code> representing the provided
attribute (<code>attributeName</code>) for the provided geometry.  This is used to
visualize vector attributes like normals, binormals, and tangents.
         * @param geometry  (Required) The <code>Geometry</code> instance with the attribute.
         * @param attributeName  (Optional) The name of the attribute.
         * @param length  (Optional) The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
         */
        function createLineSegmentsForVectors(geometry: Geometry, attributeName?: string, length?: number): Geometry;
        /**
         * Creates an object that maps attribute names to unique locations (indices)
for matching vertex attributes and shader programs.
         * @param geometry  (Required) The geometry, which is not modified, to create the object for.
         */
        function createAttributeLocations(geometry: Geometry): any;
        /**
         * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.
         * @param geometry  (Required) The geometry to modify.
         */
        function reorderForPreVertexCache(geometry: Geometry): Geometry;
        /**
         * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's
post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>
is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.
         * @param geometry  (Required) The geometry to modify.
         * @param cacheCapacity  (Optional) The number of vertices that can be held in the GPU's vertex cache.
         */
        function reorderForPostVertexCache(geometry: Geometry, cacheCapacity?: number): Geometry;
        /**
         * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the
<code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements
when unsigned int indices are not supported.
<p>
If the geometry does not have any <code>indices</code>, this function has no effect.
</p>
         * @param geometry  (Required) The geometry to be split into multiple geometries.
         */
        function fitToUnsignedShortIndices(geometry: Geometry): Geometry[];
        /**
         * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>
attribute with separate <code>position3D</code> and <code>position2D</code> attributes.
<p>
If the geometry does not have a <code>position</code>, this function has no effect.
</p>
         * @param geometry  (Required) The geometry to modify.
         * @param attributeName  (Required) The name of the attribute.
         * @param attributeName3D  (Required) The name of the attribute in 3D.
         * @param attributeName2D  (Required) The name of the attribute in 2D.
         * @param projection  (Optional) The projection to use.
         */
        function projectTo2D(geometry: Geometry, attributeName: string, attributeName3D: string, attributeName2D: string, projection?: any): Geometry;
        /**
         * Encodes floating-point geometry attribute values as two separate attributes to improve
rendering precision.
<p>
This is commonly used to create high-precision position vertex attributes.
</p>
         * @param geometry  (Required) The geometry to modify.
         * @param attributeName  (Required) The name of the attribute.
         * @param attributeHighName  (Required) The name of the attribute for the encoded high bits.
         * @param attributeLowName  (Required) The name of the attribute for the encoded low bits.
         */
        function encodeAttribute(geometry: Geometry, attributeName: string, attributeHighName: string, attributeLowName: string): Geometry;
        /**
         * Transforms a geometry instance to world coordinates.  This changes
the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the
following attributes if they are present: <code>position</code>, <code>normal</code>,
<code>binormal</code>, and <code>tangent</code>.
         * @param instance  (Required) The geometry instance to modify.
         */
        function transformToWorldCoordinates(instance: GeometryInstance): GeometryInstance;
        /**
         * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of
all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.
This assumes a counter-clockwise winding order.
         * @param geometry  (Required) The geometry to modify.
         */
        function computeNormal(geometry: Geometry): Geometry;
        /**
         * Computes per-vertex binormals and tangents for a geometry containing <code>TRIANGLES</code>.
The result is new <code>binormal</code> and <code>tangent</code> attributes added to the geometry.
This assumes a counter-clockwise winding order.
<p>
Based on <a href="http://www.terathon.com/code/tangent.html">Computing Tangent Space Basis Vectors
for an Arbitrary Mesh</a> by Eric Lengyel.
</p>
         * @param geometry  (Required) The geometry to modify.
         */
        function computeBinormalAndTangent(geometry: Geometry): Geometry;
        /**
         * Compresses and packs geometry normal attribute values to save memory.
         * @param geometry  (Required) The geometry to modify.
         */
        function compressVertices(geometry: Geometry): Geometry;
    }
    module HermitePolynomialApproximation {
        /**
         * Given the desired degree, returns the number of data points required for interpolation.
         * @param degree  (Required) The desired degree of interpolation.
         * @param inputOrder  (Optional) The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
         */
        function getRequiredDataPoints(degree: number, inputOrder?: number): number;
        /**
         * Interpolates values using Hermite Polynomial Approximation.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
        /**
         * Interpolates values using Hermite Polynomial Approximation.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param inputOrder  (Required) The number of derivatives supplied for input.
         * @param outputOrder  (Required) The number of derivatives desired for output.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
    }
    module IndexDatatype {
        /**
         * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
of an element in <code>Uint8Array</code>.
         */
        var UNSIGNED_BYTE: number;
        /**
         * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
of an element in <code>Uint16Array</code>.
         */
        var UNSIGNED_SHORT: number;
        /**
         * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
of an element in <code>Uint32Array</code>.
         */
        var UNSIGNED_INT: number;
        /**
         * Returns the size, in bytes, of the corresponding datatype.
         * @param indexDatatype  (Required) The index datatype to get the size of.
         */
        function getSizeInBytes(indexDatatype: number): number;
        /**
         * Validates that the provided index datatype is a valid {@link IndexDatatype}.
         * @param indexDatatype  (Required) The index datatype to validate.
         */
        function validate(indexDatatype: number): Boolean;
        /**
         * Creates a typed array that will store indices, using either <code><Uint16Array</code>
or <code>Uint32Array</code> depending on the number of vertices.
         * @param numberOfVertices  (Required) number of vertices that the indices will reference.
         * @param indicesLengthOrArray  (Required) Passed through to the typed array constructor.
         */
        function createTypedArray(numberOfVertices: number, indicesLengthOrArray: any): Uint16Array|Uint32Array;
        /**
         * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>
or <code>Uint32Array</code> depending on the number of vertices.
         * @param numberOfVertices  (Required) number of vertices that the indices will reference.
         * @param sourceArray  (Required) Passed through to the typed array constructor.
         * @param byteOffset  (Required) Passed through to the typed array constructor.
         * @param length  (Required) Passed through to the typed array constructor.
         */
        function createTypedArrayFromArrayBuffer(numberOfVertices: number, sourceArray: ArrayBuffer, byteOffset: number, length: number): Uint16Array|Uint32Array;
    }
    module InterpolationAlgorithm {
        /**
         * Gets the name of this interpolation algorithm.
         */
        var type: string;
        /**
         * Given the desired degree, returns the number of data points required for interpolation.
         * @param degree  (Required) The desired degree of interpolation.
         */
        function getRequiredDataPoints(degree: number): number;
        /**
         * Performs zero order interpolation.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
        /**
         * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,
if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param inputOrder  (Required) The number of derivatives supplied for input.
         * @param outputOrder  (Required) The number of derivatives desired for output.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
    }
    module Intersect {
        /**
         * Represents that an object is not contained within the frustum.
         */
        var OUTSIDE: number;
        /**
         * Represents that an object intersects one of the frustum's planes.
         */
        var INTERSECTING: number;
        /**
         * Represents that an object is fully within the frustum.
         */
        var INSIDE: number;
    }
    module Intersections2D {
        /**
         * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting
polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,
3, or 4 vertices.
         * @param threshold  (Required) The threshold coordinate value at which to clip the triangle.
         * @param keepAbove  (Required) true to keep the portion of the triangle above the threshold, or false
                           to keep the portion below.
         * @param u0  (Required) The coordinate of the first vertex in the triangle, in counter-clockwise order.
         * @param u1  (Required) The coordinate of the second vertex in the triangle, in counter-clockwise order.
         * @param u2  (Required) The coordinate of the third vertex in the triangle, in counter-clockwise order.
         * @param result  (Optional) The array into which to copy the result.  If this parameter is not supplied,
                           a new array is constructed and returned.
         */
        function clipTriangleAtAxisAlignedThreshold(threshold: number, keepAbove: Boolean, u0: number, u1: number, u2: number, result?: number[]): number[];
        /**
         * Compute the barycentric coordinates of a 2D position within a 2D triangle.
         * @param x  (Required) The x coordinate of the position for which to find the barycentric coordinates.
         * @param y  (Required) The y coordinate of the position for which to find the barycentric coordinates.
         * @param x1  (Required) The x coordinate of the triangle's first vertex.
         * @param y1  (Required) The y coordinate of the triangle's first vertex.
         * @param x2  (Required) The x coordinate of the triangle's second vertex.
         * @param y2  (Required) The y coordinate of the triangle's second vertex.
         * @param x3  (Required) The x coordinate of the triangle's third vertex.
         * @param y3  (Required) The y coordinate of the triangle's third vertex.
         * @param result  (Optional) The instance into to which to copy the result.  If this parameter
                    is undefined, a new instance is created and returned.
         */
        function computeBarycentricCoordinates(x: number, y: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, result?: Cartesian3): Cartesian3;
    }
    module IntersectionTests {
        /**
         * Computes the intersection of a ray and a plane.
         * @param ray  (Required) The ray.
         * @param plane  (Required) The plane.
         * @param result  (Optional) The object onto which to store the result.
         */
        function rayPlane(ray: Ray, plane: Plane, result?: Cartesian3): Cartesian3;
        /**
         * Computes the intersection of a ray and a triangle as a parametric distance along the input ray.
         * @param ray  (Required) The ray.
         * @param p0  (Required) The first vertex of the triangle.
         * @param p1  (Required) The second vertex of the triangle.
         * @param p2  (Required) The third vertex of the triangle.
         * @param cullBackFaces  (Optional) If <code>true</code>, will only compute an intersection with the front face of the triangle
                 and return undefined for intersections with the back face.
         */
        function rayTriangleParametric(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: Boolean): number;
        /**
         * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.
         * @param ray  (Required) The ray.
         * @param p0  (Required) The first vertex of the triangle.
         * @param p1  (Required) The second vertex of the triangle.
         * @param p2  (Required) The third vertex of the triangle.
         * @param cullBackFaces  (Optional) If <code>true</code>, will only compute an intersection with the front face of the triangle
                 and return undefined for intersections with the back face.
         * @param result  (Optional) The <code>Cartesian3</code> onto which to store the result.
         */
        function rayTriangle(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: Boolean, result?: Cartesian3): Cartesian3;
        /**
         * Computes the intersection of a line segment and a triangle.
         * @param v0  (Required) The an end point of the line segment.
         * @param v1  (Required) The other end point of the line segment.
         * @param p0  (Required) The first vertex of the triangle.
         * @param p1  (Required) The second vertex of the triangle.
         * @param p2  (Required) The third vertex of the triangle.
         * @param cullBackFaces  (Optional) If <code>true</code>, will only compute an intersection with the front face of the triangle
                 and return undefined for intersections with the back face.
         * @param result  (Optional) The <code>Cartesian3</code> onto which to store the result.
         */
        function lineSegmentTriangle(v0: Cartesian3, v1: Cartesian3, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: Boolean, result?: Cartesian3): Cartesian3;
        /**
         * Computes the intersection points of a ray with a sphere.
         * @param ray  (Required) The ray.
         * @param sphere  (Required) The sphere.
         * @param result  (Optional) The result onto which to store the result.
         */
        function raySphere(ray: Ray, sphere: BoundingSphere, result?: any): any;
        /**
         * Computes the intersection points of a line segment with a sphere.
         * @param p0  (Required) An end point of the line segment.
         * @param p1  (Required) The other end point of the line segment.
         * @param sphere  (Required) The sphere.
         * @param result  (Optional) The result onto which to store the result.
         */
        function lineSegmentSphere(p0: Cartesian3, p1: Cartesian3, sphere: BoundingSphere, result?: any): any;
        /**
         * Computes the intersection points of a ray with an ellipsoid.
         * @param ray  (Required) The ray.
         * @param ellipsoid  (Required) The ellipsoid.
         */
        function rayEllipsoid(ray: Ray, ellipsoid: Ellipsoid): any;
        /**
         * Provides the point along the ray which is nearest to the ellipsoid.
         * @param ray  (Required) The ray.
         * @param ellipsoid  (Required) The ellipsoid.
         */
        function grazingAltitudeLocation(ray: Ray, ellipsoid: Ellipsoid): Cartesian3;
        /**
         * Computes the intersection of a line segment and a plane.
         * @param endPoint0  (Required) An end point of the line segment.
         * @param endPoint1  (Required) The other end point of the line segment.
         * @param plane  (Required) The plane.
         * @param result  (Optional) The object onto which to store the result.
         */
        function lineSegmentPlane(endPoint0: Cartesian3, endPoint1: Cartesian3, plane: Plane, result?: Cartesian3): Cartesian3;
        /**
         * Computes the intersection of a triangle and a plane
         * @param p0  (Required) First point of the triangle
         * @param p1  (Required) Second point of the triangle
         * @param p2  (Required) Third point of the triangle
         * @param plane  (Required) Intersection plane
         */
        function trianglePlaneIntersection(p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, plane: Plane): any;
    }
    module Iso8601 {
        /**
         * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
This is equivalent to the date string '0000-01-01T00:00:00Z'
         */
        var MINIMUM_VALUE: any;
        /**
         * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
This is equivalent to the date string '9999-12-31T24:00:00Z'
         */
        var MAXIMUM_VALUE: any;
        /**
         * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
         */
        var MAXIMUM_INTERVAL: any;
    }
    module KeyboardEventModifier {
        /**
         * Represents the shift key being held down.
         */
        var SHIFT: number;
        /**
         * Represents the control key being held down.
         */
        var CTRL: number;
        /**
         * Represents the alt key being held down.
         */
        var ALT: number;
    }
    module LagrangePolynomialApproximation {
        /**
         * Given the desired degree, returns the number of data points required for interpolation.
         * @param degree  (Required) The desired degree of interpolation.
         */
        function getRequiredDataPoints(degree: number): number;
        /**
         * Interpolates values using Lagrange Polynomial Approximation.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
    }
    module LinearApproximation {
        /**
         * Given the desired degree, returns the number of data points required for interpolation.
Since linear interpolation can only generate a first degree polynomial, this function
always returns 2.
         * @param degree  (Required) The desired degree of interpolation.
         */
        function getRequiredDataPoints(degree: number): number;
        /**
         * Interpolates values using linear approximation.
         * @param x  (Required) The independent variable for which the dependent variables will be interpolated.
         * @param xTable  (Required) The array of independent variables to use to interpolate.  The values
in this array must be in increasing order and the same value must not occur twice in the array.
         * @param yTable  (Required) The array of dependent variables to use to interpolate.  For a set of three
dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param yStride  (Required) The number of dependent variable values in yTable corresponding to
each independent variable value in xTable.
         * @param result  (Optional) An existing array into which to store the result.
         */
        function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
    }
    module MapboxApi {
        /**
         * The default Mapbox API access token to use if one is not provided to the
constructor of an object that uses the Mapbox API.  If this property is undefined,
Cesium's default access token is used, which is only suitable for use early in development.
Please supply your own access token as soon as possible and prior to deployment.
Visit {@link https://www.mapbox.com/help/create-api-access-token/} for details.
When Cesium's default access token is used, a message is printed to the console the first
time the Mapbox API is used.
         */
        var defaultAccessToken: string;
    }
    module CesiumMath {
        /**
         * 0.1
         */
        var EPSILON1: number;
        /**
         * 0.01
         */
        var EPSILON2: number;
        /**
         * 0.001
         */
        var EPSILON3: number;
        /**
         * 0.0001
         */
        var EPSILON4: number;
        /**
         * 0.00001
         */
        var EPSILON5: number;
        /**
         * 0.000001
         */
        var EPSILON6: number;
        /**
         * 0.0000001
         */
        var EPSILON7: number;
        /**
         * 0.00000001
         */
        var EPSILON8: number;
        /**
         * 0.000000001
         */
        var EPSILON9: number;
        /**
         * 0.0000000001
         */
        var EPSILON10: number;
        /**
         * 0.00000000001
         */
        var EPSILON11: number;
        /**
         * 0.000000000001
         */
        var EPSILON12: number;
        /**
         * 0.0000000000001
         */
        var EPSILON13: number;
        /**
         * 0.00000000000001
         */
        var EPSILON14: number;
        /**
         * 0.000000000000001
         */
        var EPSILON15: number;
        /**
         * 0.0000000000000001
         */
        var EPSILON16: number;
        /**
         * 0.00000000000000001
         */
        var EPSILON17: number;
        /**
         * 0.000000000000000001
         */
        var EPSILON18: number;
        /**
         * 0.0000000000000000001
         */
        var EPSILON19: number;
        /**
         * 0.00000000000000000001
         */
        var EPSILON20: number;
        /**
         * 3.986004418e14
         */
        var GRAVITATIONALPARAMETER: number;
        /**
         * Radius of the sun in meters: 6.955e8
         */
        var SOLAR_RADIUS: number;
        /**
         * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
Celestial Mechanics 82: 83-110, 2002.
         */
        var LUNAR_RADIUS: number;
        /**
         * 64 * 1024
         */
        var SIXTY_FOUR_KILOBYTES: number;
        /**
         * Returns the sign of the value; 1 if the value is positive, -1 if the value is
negative, or 0 if the value is 0.
         * @param value  (Required) The value to return the sign of.
         */
        function sign(value: number): number;
        /**
         * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of
0.0 when the input value is 0.0.
         * @param value  (Required) The value to return the sign of.
         */
        function signNotZero(value: number): number;
        /**
         * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMax]
         * @param value  (Required) The scalar value in the range [-1.0, 1.0]
         * @param rangeMax  (Optional) The maximum value in the mapped range, 255 by default.
         */
        function toSNorm(value: number, rangeMax?: number): number;
        /**
         * Converts a SNORM value in the range [0, rangeMax] to a scalar in the range [-1.0, 1.0].
         * @param value  (Required) SNORM value in the range [0, 255]
         * @param rangeMax  (Optional) The maximum value in the SNORM range, 255 by default.
         */
        function fromSNorm(value: number, rangeMax?: number): number;
        /**
         * Returns the hyperbolic sine of a number.
The hyperbolic sine of <em>value</em> is defined to be
(<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
where <i>e</i> is Euler's number, approximately 2.71828183.

<p>Special cases:
  <ul>
    <li>If the argument is NaN, then the result is NaN.</li>

    <li>If the argument is infinite, then the result is an infinity
    with the same sign as the argument.</li>

    <li>If the argument is zero, then the result is a zero with the
    same sign as the argument.</li>
  </ul>
</p>
         * @param value  (Required) The number whose hyperbolic sine is to be returned.
         */
        function sinh(value: number): number;
        /**
         * Returns the hyperbolic cosine of a number.
The hyperbolic cosine of <strong>value</strong> is defined to be
(<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
where <i>e</i> is Euler's number, approximately 2.71828183.

<p>Special cases:
  <ul>
    <li>If the argument is NaN, then the result is NaN.</li>

    <li>If the argument is infinite, then the result is positive infinity.</li>

    <li>If the argument is zero, then the result is 1.0.</li>
  </ul>
</p>
         * @param value  (Required) The number whose hyperbolic cosine is to be returned.
         */
        function cosh(value: number): number;
        /**
         * Computes the linear interpolation of two values.
         * @param p  (Required) The start value to interpolate.
         * @param q  (Required) The end value to interpolate.
         * @param time  (Required) The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
         */
        function lerp(p: number, q: number, time: number): number;
        /**
         * pi
         */
        var PI: number;
        /**
         * 1/pi
         */
        var ONE_OVER_PI: number;
        /**
         * pi/2
         */
        var PI_OVER_TWO: number;
        /**
         * pi/3
         */
        var PI_OVER_THREE: number;
        /**
         * pi/4
         */
        var PI_OVER_FOUR: number;
        /**
         * pi/6
         */
        var PI_OVER_SIX: number;
        /**
         * 3pi/2
         */
        var THREE_PI_OVER_TWO: number;
        /**
         * 2pi
         */
        var TWO_PI: number;
        /**
         * 1/2pi
         */
        var ONE_OVER_TWO_PI: number;
        /**
         * The number of radians in a degree.
         */
        var RADIANS_PER_DEGREE: number;
        /**
         * The number of degrees in a radian.
         */
        var DEGREES_PER_RADIAN: number;
        /**
         * The number of radians in an arc second.
         */
        var RADIANS_PER_ARCSECOND: number;
        /**
         * Converts degrees to radians.
         * @param degrees  (Required) The angle to convert in degrees.
         */
        function toRadians(degrees: number): number;
        /**
         * Converts radians to degrees.
         * @param radians  (Required) The angle to convert in radians.
         */
        function toDegrees(radians: number): number;
        /**
         * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
         * @param angle  (Required) The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
         */
        function convertLongitudeRange(angle: number): number;
        /**
         * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
Useful for sanitizing data before use in objects requiring correct range.
         * @param angle  (Required) The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
         */
        function clampToLatitudeRange(angle: number): number;
        /**
         * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
         * @param angle  (Required) in radians
         */
        function negativePiToPi(angle: number): number;
        /**
         * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
         * @param angle  (Required) in radians
         */
        function zeroToTwoPi(angle: number): number;
        /**
         * The modulo operation that also works for negative dividends.
         * @param m  (Required) The dividend.
         * @param n  (Required) The divisor.
         */
        function mod(m: number, n: number): number;
        /**
         * Determines if two values are equal using an absolute or relative tolerance test. This is useful
to avoid problems due to roundoff error when comparing floating-point values directly. The values are
first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
Use this test if you are unsure of the magnitudes of left and right.
         * @param left  (Required) The first value to compare.
         * @param right  (Required) The other value to compare.
         * @param relativeEpsilon  (Required) The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
         * @param absoluteEpsilon  (Optional) The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
         */
        function equalsEpsilon(left: number, right: number, relativeEpsilon: number, absoluteEpsilon?: number): Boolean;
        /**
         * Computes the factorial of the provided number.
         * @param n  (Required) The number whose factorial is to be computed.
         */
        function factorial(n: number): number;
        /**
         * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
         * @param n  (Optional) The number to be incremented.
         * @param maximumValue  (Optional) The maximum incremented value before rolling over to the minimum value.
         * @param minimumValue  (Optional) The number reset to after the maximum value has been exceeded.
         */
        function incrementWrap(n?: number, maximumValue?: number, minimumValue?: number): number;
        /**
         * Determines if a positive integer is a power of two.
         * @param n  (Required) The positive integer to test.
         */
        function isPowerOfTwo(n: number): Boolean;
        /**
         * Computes the next power-of-two integer greater than or equal to the provided positive integer.
         * @param n  (Required) The positive integer to test.
         */
        function nextPowerOfTwo(n: number): number;
        /**
         * Constraint a value to lie between two values.
         * @param value  (Required) The value to constrain.
         * @param min  (Required) The minimum value.
         * @param max  (Required) The maximum value.
         */
        function clamp(value: number, min: number, max: number): number;
        /**
         * Sets the seed used by the random number generator
in {@link CesiumMath#nextRandomNumber}.
         * @param seed  (Required) An integer used as the seed.
         */
        function setRandomNumberSeed(seed: number): void;
        /**
         * Generates a random number in the range of [0.0, 1.0)
using a Mersenne twister.
         */
        function nextRandomNumber(): number;
        /**
         * Computes <code>Math.acos(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
so that the function will never return NaN.
         * @param value  (Required) The value for which to compute acos.
         */
        function acosClamped(value: number): number;
        /**
         * Computes <code>Math.asin(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
so that the function will never return NaN.
         * @param value  (Required) The value for which to compute asin.
         */
        function asinClamped(value: number): number;
        /**
         * Finds the chord length between two points given the circle's radius and the angle between the points.
         * @param angle  (Required) The angle between the two points.
         * @param radius  (Required) The radius of the circle.
         */
        function chordLength(angle: number, radius: number): number;
        /**
         * Finds the logarithm of a number to a base.
         * @param number  (Required) The number.
         * @param base  (Required) The base.
         */
        function logBase(number: number, base: number): number;
    }
    module Packable {
        /**
         * The number of elements used to pack the object into an array.
         */
        var packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        function pack(value: any, array: number[], startingIndex?: number): void;
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        function unpack(array: number[], startingIndex?: number, result?: any): any;
    }
    module PackableForInterpolation {
        /**
         * The number of elements used to store the object into an array in its interpolatable form.
         */
        var packedInterpolationLength: number;
        /**
         * Converts a packed array into a form suitable for interpolation.
         * @param packedArray  (Required) The packed array.
         * @param startingIndex  (Optional) The index of the first element to be converted.
         * @param lastIndex  (Optional) The index of the last element to be converted.
         * @param result  (Optional) The object into which to store the result.
         */
        function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
        /**
         * Retrieves an instance from a packed array converted with {@link PackableForInterpolation.convertPackedArrayForInterpolation}.
         * @param array  (Required) The array previously packed for interpolation.
         * @param sourceArray  (Required) The original packed array.
         * @param startingIndex  (Optional) The startingIndex used to convert the array.
         * @param lastIndex  (Optional) The lastIndex used to convert the array.
         * @param result  (Optional) The object into which to store the result.
         */
        function unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: any): any;
    }
    module PixelFormat {
        /**
         * A pixel format containing a depth value.
         */
        var DEPTH_COMPONENT: number;
        /**
         * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8}.
         */
        var DEPTH_STENCIL: number;
        /**
         * A pixel format containing an alpha channel.
         */
        var ALPHA: number;
        /**
         * A pixel format containing red, green, and blue channels.
         */
        var RGB: number;
        /**
         * A pixel format containing red, green, blue, and alpha channels.
         */
        var RGBA: number;
        /**
         * A pixel format containing a luminance (intensity) channel.
         */
        var LUMINANCE: number;
        /**
         * A pixel format containing luminance (intensity) and alpha channels.
         */
        var LUMINANCE_ALPHA: number;
    }
    module PolygonPipeline {
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        function computeArea2D(): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         */
        function computeWindingOrder2D(): number;
        /**
         * Triangulate a polygon.
         * @param positions  (Required) Cartesian2 array containing the vertices of the polygon
         * @param holes  (Optional) An array of the staring indices of the holes.
         */
        function triangulate(positions: Cartesian2[], holes?: number[]): number[];
        /**
         * Subdivides positions and raises points to the surface of the ellipsoid.
         * @param ellipsoid  (Required) The ellipsoid the polygon in on.
         * @param positions  (Required) An array of {@link Cartesian3} positions of the polygon.
         * @param indices  (Required) An array of indices that determines the triangles in the polygon.
         * @param granularity  (Optional) The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         */
        function computeSubdivision(ellipsoid: Ellipsoid, positions: Cartesian3[], indices: number[], granularity?: number): void;
        /**
         * Scales each position of a geometry's position attribute to a height, in place.
         * @param positions  (Required) The array of numbers representing the positions to be scaled
         * @param height  (Optional) The desired height to add to the positions
         * @param ellipsoid  (Optional) The ellipsoid on which the positions lie.
         * @param scaleToSurface  (Optional) <code>true</code> if the positions need to be scaled to the surface before the height is added.
         */
        function scaleToGeodeticHeight(positions: number[], height?: number, ellipsoid?: Ellipsoid, scaleToSurface?: Boolean): number[];
    }
    module PolylinePipeline {
        /**
         * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.
         * @param positions  (Required) The polyline's Cartesian positions.
         * @param modelMatrix  (Optional) The polyline's model matrix. Assumed to be an affine
transformation matrix, where the upper left 3x3 elements are a rotation matrix, and
the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
The matrix is not verified to be in the proper form.
         */
        function wrapLongitude(positions: Cartesian3[], modelMatrix?: Matrix4): any;
        /**
         * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.
         * @param positions  (Required) The array of type {Cartesian3} representing positions.
         * @param height  (Optional) A number or array of numbers representing the heights of each position.
         * @param granularity  (Optional) The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         * @param ellipsoid  (Optional) The ellipsoid on which the positions lie.
         */
        function generateArc(positions: Cartesian3[], height?: number|Number[], granularity?: number, ellipsoid?: Ellipsoid): number[];
        /**
         * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.
         * @param positions  (Required) The array of type {Cartesian3} representing positions.
         * @param height  (Optional) A number or array of numbers representing the heights of each position.
         * @param granularity  (Optional) The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         * @param ellipsoid  (Optional) The ellipsoid on which the positions lie.
         */
        function generateCartesianArc(positions: Cartesian3[], height?: number|Number[], granularity?: number, ellipsoid?: Ellipsoid): Cartesian3[];
    }
    module PrimitiveType {
        /**
         * Points primitive where each vertex (or index) is a separate point.
         */
        var POINTS: number;
        /**
         * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.
         */
        var LINES: number;
        /**
         * Line loop primitive where each vertex (or index) after the first connects a line to
the previous vertex, and the last vertex implicitly connects to the first.
         */
        var LINE_LOOP: number;
        /**
         * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.
         */
        var LINE_STRIP: number;
        /**
         * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.
         */
        var TRIANGLES: number;
        /**
         * Triangle strip primitive where each vertex (or index) after the first two connect to
the previous two vertices forming a triangle.  For example, this can be used to model a wall.
         */
        var TRIANGLE_STRIP: number;
        /**
         * Triangle fan primitive where each vertex (or index) after the first two connect to
the previous vertex and the first vertex forming a triangle.  For example, this can be used
to model a cone or circle.
         */
        var TRIANGLE_FAN: number;
    }
    module QuadraticRealPolynomial {
        /**
         * Provides the discriminant of the quadratic equation from the supplied coefficients.
         * @param a  (Required) The coefficient of the 2nd order monomial.
         * @param b  (Required) The coefficient of the 1st order monomial.
         * @param c  (Required) The coefficient of the 0th order monomial.
         */
        function computeDiscriminant(a: number, b: number, c: number): number;
        /**
         * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
         * @param a  (Required) The coefficient of the 2nd order monomial.
         * @param b  (Required) The coefficient of the 1st order monomial.
         * @param c  (Required) The coefficient of the 0th order monomial.
         */
        function computeRealRoots(a: number, b: number, c: number): number[];
    }
    module QuarticRealPolynomial {
        /**
         * Provides the discriminant of the quartic equation from the supplied coefficients.
         * @param a  (Required) The coefficient of the 4th order monomial.
         * @param b  (Required) The coefficient of the 3rd order monomial.
         * @param c  (Required) The coefficient of the 2nd order monomial.
         * @param d  (Required) The coefficient of the 1st order monomial.
         * @param e  (Required) The coefficient of the 0th order monomial.
         */
        function computeDiscriminant(a: number, b: number, c: number, d: number, e: number): number;
        /**
         * Provides the real valued roots of the quartic polynomial with the provided coefficients.
         * @param a  (Required) The coefficient of the 4th order monomial.
         * @param b  (Required) The coefficient of the 3rd order monomial.
         * @param c  (Required) The coefficient of the 2nd order monomial.
         * @param d  (Required) The coefficient of the 1st order monomial.
         * @param e  (Required) The coefficient of the 0th order monomial.
         */
        function computeRealRoots(a: number, b: number, c: number, d: number, e: number): number[];
    }
    module ReferenceFrame {
        /**
         * The fixed frame.
         */
        var FIXED: number;
        /**
         * The inertial frame.
         */
        var INERTIAL: number;
    }
    module ScreenSpaceEventType {
        /**
         * Represents a mouse left button down event.
         */
        var LEFT_DOWN: number;
        /**
         * Represents a mouse left button up event.
         */
        var LEFT_UP: number;
        /**
         * Represents a mouse left click event.
         */
        var LEFT_CLICK: number;
        /**
         * Represents a mouse left double click event.
         */
        var LEFT_DOUBLE_CLICK: number;
        /**
         * Represents a mouse left button down event.
         */
        var RIGHT_DOWN: number;
        /**
         * Represents a mouse right button up event.
         */
        var RIGHT_UP: number;
        /**
         * Represents a mouse right click event.
         */
        var RIGHT_CLICK: number;
        /**
         * Represents a mouse right double click event.
         */
        var RIGHT_DOUBLE_CLICK: number;
        /**
         * Represents a mouse middle button down event.
         */
        var MIDDLE_DOWN: number;
        /**
         * Represents a mouse middle button up event.
         */
        var MIDDLE_UP: number;
        /**
         * Represents a mouse middle click event.
         */
        var MIDDLE_CLICK: number;
        /**
         * Represents a mouse middle double click event.
         */
        var MIDDLE_DOUBLE_CLICK: number;
        /**
         * Represents a mouse move event.
         */
        var MOUSE_MOVE: number;
        /**
         * Represents a mouse wheel event.
         */
        var WHEEL: number;
        /**
         * Represents the start of a two-finger event on a touch surface.
         */
        var PINCH_START: number;
        /**
         * Represents the end of a two-finger event on a touch surface.
         */
        var PINCH_END: number;
        /**
         * Represents a change of a two-finger event on a touch surface.
         */
        var PINCH_MOVE: number;
    }
    module Simon1994PlanetaryPositions {
        /**
         * Computes the position of the Sun in the Earth-centered inertial frame
         * @param julianDate  (Optional) The time at which to compute the Sun's position, if not provided the current system time is used.
         * @param result  (Optional) The object onto which to store the result.
         */
        function computeSunPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
        /**
         * Computes the position of the Moon in the Earth-centered inertial frame
         * @param julianDate  (Optional) The time at which to compute the Sun's position, if not provided the current system time is used.
         * @param result  (Optional) The object onto which to store the result.
         */
        function computeMoonPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
    }
    module TimeStandard {
        /**
         * Represents the coordinated Universal Time (UTC) time standard.

UTC is related to TAI according to the relationship
<code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
seconds which have been introduced as of the time in TAI.
         */
        var UTC: any;
        /**
         * Represents the International Atomic Time (TAI) time standard.
TAI is the principal time standard to which the other time standards are related.
         */
        var TAI: any;
    }
    module Transforms {
        /**
         * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
centered at the provided origin to the provided ellipsoid's fixed reference frame.
The local axes are defined as:
<ul>
<li>The <code>x</code> axis points in the local east direction.</li>
<li>The <code>y</code> axis points in the local north direction.</li>
<li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
</ul>
         * @param origin  (Required) The center point of the local reference frame.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function eastNorthUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
centered at the provided origin to the provided ellipsoid's fixed reference frame.
The local axes are defined as:
<ul>
<li>The <code>x</code> axis points in the local north direction.</li>
<li>The <code>y</code> axis points in the local east direction.</li>
<li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
</ul>
         * @param origin  (Required) The center point of the local reference frame.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function northEastDownToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
centered at the provided origin to the provided ellipsoid's fixed reference frame.
The local axes are defined as:
<ul>
<li>The <code>x</code> axis points in the local north direction.</li>
<li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
<li>The <code>z</code> axis points in the local east direction.</li>
</ul>
         * @param origin  (Required) The center point of the local reference frame.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function northUpEastToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes
centered at the provided origin to the provided ellipsoid's fixed reference frame.
The local axes are defined as:
<ul>
<li>The <code>x</code> axis points in the local north direction.</li>
<li>The <code>y</code> axis points in the local west direction.</li>
<li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
</ul>
         * @param origin  (Required) The center point of the local reference frame.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function northWestUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
        /**
         * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
         * @param origin  (Required) The center point of the local reference frame.
         * @param headingPitchRoll  (Required) The heading, pitch, and roll.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function headingPitchRollToFixedFrame(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
        /**
         * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
centered at the provided origin. Heading is the rotation from the local north
direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
         * @param origin  (Required) The center point of the local reference frame.
         * @param headingPitchRoll  (Required) The heading, pitch, and roll.
         * @param ellipsoid  (Optional) The ellipsoid whose fixed frame is used in the transformation.
         * @param result  (Optional) The object onto which to store the result.
         */
        function headingPitchRollQuaternion(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, result?: Quaternion): Quaternion;
        /**
         * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
         * @param date  (Required) The time at which to compute the rotation matrix.
         * @param result  (Optional) The object onto which to store the result.
         */
        function computeTemeToPseudoFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
        /**
         * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
direction, over a given interval.  This function returns a promise that, when resolved,
indicates that the preload has completed.
         * @param timeInterval  (Required) The interval to preload.
         */
        function preloadIcrfFixed(timeInterval: TimeInterval): Promise<undefined>;
        /**
         * Computes a rotation matrix to transform a point or vector from the International Celestial
Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
at a given time.  This function may return undefined if the data necessary to
do the transformation is not yet loaded.
         * @param date  (Required) The time at which to compute the rotation matrix.
         * @param result  (Optional) The object onto which to store the result.  If this parameter is
                 not specified, a new instance is created and returned.
         */
        function computeIcrfToFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
        /**
         * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
at a given time.  This function may return undefined if the data necessary to
do the transformation is not yet loaded.
         * @param date  (Required) The time at which to compute the rotation matrix.
         * @param result  (Optional) The object onto which to store the result.  If this parameter is
                 not specified, a new instance is created and returned.
         */
        function computeFixedToIcrfMatrix(date: JulianDate, result?: Matrix3): Matrix3;
        /**
         * Transform a point from model coordinates to window coordinates.
         * @param modelViewProjectionMatrix  (Required) The 4x4 model-view-projection matrix.
         * @param viewportTransformation  (Required) The 4x4 viewport transformation.
         * @param point  (Required) The point to transform.
         * @param result  (Optional) The object onto which to store the result.
         */
        function pointToWindowCoordinates(modelViewProjectionMatrix: Matrix4, viewportTransformation: Matrix4, point: Cartesian3, result?: Cartesian2): Cartesian2;
    }
    module TridiagonalSystemSolver {
        /**
         * Solves a tridiagonal system of linear equations.
         * @param diagonal  (Required) An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
         * @param lower  (Required) An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
         * @param upper  (Required) An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
         * @param right  (Required) An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
         */
        function solve(diagonal: number[], lower: number[], upper: number[], right: Cartesian3[]): Cartesian3[];
    }
    module TrustedServers {
        /**
         * Adds a trusted server to the registry
         * @param host  (Required) The host to be added.
         * @param port  (Required) The port used to access the host.
         */
        function add(host: string, port: number): void;
        /**
         * Removes a trusted server from the registry
         * @param host  (Required) The host to be removed.
         * @param port  (Required) The port used to access the host.
         */
        function remove(host: string, port: number): void;
        /**
         * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.
         * @param url  (Required) The url to be tested against the trusted list
         */
        function contains(url: string): boolean;
        /**
         * Clears the registry
         */
        function clear(): void;
    }
    module Visibility {
        /**
         * Represents that no part of an object is visible.
         */
        var NONE: number;
        /**
         * Represents that part, but not all, of an object is visible
         */
        var PARTIAL: number;
        /**
         * Represents that an object is visible in its entirety.
         */
        var FULL: number;
    }
    module WindingOrder {
        /**
         * Vertices are in clockwise order.
         */
        var CLOCKWISE: number;
        /**
         * Vertices are in counter-clockwise order.
         */
        var COUNTER_CLOCKWISE: number;
    }
    module Rotation {
        /**
         * The number of elements used to pack the object into an array.
         */
        var packedLength: number;
        /**
         * Stores the provided instance into the provided array.
         * @param value  (Required) The value to pack.
         * @param array  (Required) The array to pack into.
         * @param startingIndex  (Optional) The index into the array at which to start packing the elements.
         */
        function pack(value: Rotation, array: number[], startingIndex?: number): number[];
        /**
         * Retrieves an instance from a packed array.
         * @param array  (Required) The packed array.
         * @param startingIndex  (Optional) The starting index of the element to be unpacked.
         * @param result  (Optional) The object into which to store the result.
         */
        function unpack(array: number[], startingIndex?: number, result?: Rotation): Rotation;
        /**
         * Converts a packed array into a form suitable for interpolation.
         * @param packedArray  (Required) The packed array.
         * @param startingIndex  (Optional) The index of the first element to be converted.
         * @param lastIndex  (Optional) The index of the last element to be converted.
         * @param result  (Optional) The object into which to store the result.
         */
        function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
        /**
         * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.
         * @param array  (Required) The array previously packed for interpolation.
         * @param sourceArray  (Required) The original packed array.
         * @param startingIndex  (Optional) The startingIndex used to convert the array.
         * @param lastIndex  (Optional) The lastIndex used to convert the array.
         * @param result  (Optional) The object into which to store the result.
         */
        function unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: Rotation): Rotation;
    }
    module StripeOrientation {
        /**
         * Horizontal orientation.
         */
        var HORIZONTAL: number;
        /**
         * Vertical orientation.
         */
        var VERTICAL: number;
    }
    module ClearCommand {
        /**
         * The value to clear the color buffer to.  When <code>undefined</code>, the color buffer is not cleared.
         */
        var color: number;
        /**
         * The value to clear the depth buffer to.  When <code>undefined</code>, the depth buffer is not cleared.
         */
        var depth: number;
        /**
         * The value to clear the stencil buffer to.  When <code>undefined</code>, the stencil buffer is not cleared.
         */
        var stencil: number;
        /**
         * The render state to apply when executing the clear command.  The following states affect clearing:
scissor test, color mask, depth mask, and stencil mask.  When the render state is
<code>undefined</code>, the default render state is used.
         */
        var renderState: number;
        /**
         * The framebuffer to clear.
         */
        var framebuffer: Framebuffer;
        /**
         * The object who created this command.  This is useful for debugging command
execution; it allows you to see who created a command when you only have a
reference to the command, and can be used to selectively execute commands
with {@link Scene#debugCommandFilter}.
         */
        var owner: any;
        /**
         * Clears color to (0.0, 0.0, 0.0, 0.0); depth to 1.0; and stencil to 0.
         */
        var ALL: ClearCommand;
    }
    module ComputeCommand {
        /**
         * The vertex array. If none is provided, a viewport quad will be used.
         */
        var vertexArray: VertexArray;
        /**
         * The fragment shader source. The default vertex shader is ViewportQuadVS.
         */
        var fragmentShaderSource: ShaderSource;
        /**
         * The shader program to apply.
         */
        var shaderProgram: ShaderProgram;
        /**
         * An object with functions whose names match the uniforms in the shader program
and return values to set those uniforms.
         */
        var uniformMap: any;
        /**
         * Texture to use for offscreen rendering.
         */
        var outputTexture: Texture;
        /**
         * Function that is called immediately before the ComputeCommand is executed. Used to
update any renderer resources. Takes the ComputeCommand as its single argument.
         */
        var preExecute: Function;
        /**
         * Function that is called after the ComputeCommand is executed. Takes the output
texture as its single argument.
         */
        var postExecute: Function;
        /**
         * Whether the renderer resources will persist beyond this call. If not, they
will be destroyed after completion.
         */
        var persists: Boolean;
        /**
         * The pass when to render. Always compute pass.
         */
        var pass: Pass;
        /**
         * The object who created this command.  This is useful for debugging command
execution; it allows us to see who created a command when we only have a
reference to the command, and can be used to selectively execute commands
with {@link Scene#debugCommandFilter}.
         */
        var owner: any;
        /**
         * Executes the compute command.
         * @param context  (Required) The context that processes the compute command.
         */
        function execute(context: Context): void;
    }
    module Context {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var options: any;
        /**
         * A cache of objects tied to this context.  Just before the Context is destroyed,
<code>destroy</code> will be invoked on each object in this object literal that has
such a method.  This is useful for caching any objects that might otherwise
be stored globally, except they're tied to a particular context, and to manage
their lifetime.
         */
        var cache: any;
        /**
         * The number of red bits per component in the default framebuffer's color buffer.  The minimum is eight.
         */
        var redBits: number;
        /**
         * The number of green bits per component in the default framebuffer's color buffer.  The minimum is eight.
         */
        var greenBits: number;
        /**
         * The number of blue bits per component in the default framebuffer's color buffer.  The minimum is eight.
         */
        var blueBits: number;
        /**
         * The number of alpha bits per component in the default framebuffer's color buffer.  The minimum is eight.
<br /><br />
The alpha channel is used for GL destination alpha operations and by the HTML compositor to combine the color buffer
with the rest of the page.
         */
        var alphaBits: number;
        /**
         * The number of depth bits per pixel in the default bound framebuffer.  The minimum is 16 bits; most
implementations will have 24 bits.
         */
        var depthBits: number;
        /**
         * The number of stencil bits per pixel in the default bound framebuffer.  The minimum is eight bits.
         */
        var stencilBits: number;
        /**
         * <code>true</code> if the WebGL context supports antialiasing.  By default
antialiasing is requested, but it is not supported by all systems.
         */
        var antialias: Boolean;
        /**
         * <code>true</code> if the OES_standard_derivatives extension is supported.  This
extension provides access to <code>dFdx</code>, <code>dFdy</code>, and <code>fwidth</code>
functions from GLSL.  A shader using these functions still needs to explicitly enable the
extension with <code>#extension GL_OES_standard_derivatives : enable</code>.
         */
        var standardDerivatives: Boolean;
        /**
         * <code>true</code> if the OES_element_index_uint extension is supported.  This
extension allows the use of unsigned int indices, which can improve performance by
eliminating batch breaking caused by unsigned short indices.
         */
        var elementIndexUint: Boolean;
        /**
         * <code>true</code> if WEBGL_depth_texture is supported.  This extension provides
access to depth textures that, for example, can be attached to framebuffers for shadow mapping.
         */
        var depthTexture: Boolean;
        /**
         * <code>true</code> if OES_texture_float is supported.  This extension provides
access to floating point textures that, for example, can be attached to framebuffers for high dynamic range.
         */
        var floatingPointTexture: Boolean;
        /**
         * <code>true</code> if the OES_vertex_array_object extension is supported.  This
extension can improve performance by reducing the overhead of switching vertex arrays.
When enabled, this extension is automatically used by {@link VertexArray}.
         */
        var vertexArrayObject: Boolean;
        /**
         * <code>true</code> if the EXT_frag_depth extension is supported.  This
extension provides access to the <code>gl_FragDepthEXT</code> built-in output variable
from GLSL fragment shaders.  A shader using these functions still needs to explicitly enable the
extension with <code>#extension GL_EXT_frag_depth : enable</code>.
         */
        var fragmentDepth: Boolean;
        /**
         * <code>true</code> if the ANGLE_instanced_arrays extension is supported.  This
extension provides access to instanced rendering.
         */
        var instancedArrays: Boolean;
        /**
         * <code>true</code> if the WEBGL_draw_buffers extension is supported. This
extensions provides support for multiple render targets. The framebuffer object can have mutiple
color attachments and the GLSL fragment shader can write to the built-in output array <code>gl_FragData</code>.
A shader using this feature needs to explicitly enable the extension with
<code>#extension GL_EXT_draw_buffers : enable</code>.
         */
        var drawBuffers: Boolean;
        /**
         * A 1x1 RGBA texture initialized to [255, 255, 255, 255].  This can
be used as a placeholder texture while other textures are downloaded.
         */
        var defaultTexture: Texture;
        /**
         * A cube map, where each face is a 1x1 RGBA texture initialized to
[255, 255, 255, 255].  This can be used as a placeholder cube map while
other cube maps are downloaded.
         */
        var defaultCubeMap: CubeMap;
        /**
         * The drawingBufferHeight of the underlying GL context.
         */
        var drawingBufferHeight: number;
        /**
         * The drawingBufferWidth of the underlying GL context.
         */
        var drawingBufferWidth: number;
        /**
         * Gets an object representing the currently bound framebuffer.  While this instance is not an actual
{@link Framebuffer}, it is used to represent the default framebuffer in calls to
{@link Texture.FromFramebuffer}.
         */
        var defaultFramebuffer: any;
        /**
         * Gets the object associated with a pick color.
         * @param pickColor  (Required) The pick color.
         */
        function getObjectByPickColor(pickColor: number): any;
        /**
         * Creates a unique ID associated with the input object for use with color-buffer picking.
The ID has an RGBA color value unique to this context.  You must call destroy()
on the pick ID when destroying the input object.
         * @param object  (Required) The object to associate with the pick ID.
         */
        function createPickId(object: any): any;
    }
    module ContextLimits {
        /**
         * The maximum number of texture units that can be used from the vertex and fragment
shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
same texture unit, this counts as two texture units.
         */
        var maximumCombinedTextureImageUnits: number;
        /**
         * The approximate maximum cube mape width and height supported by this WebGL implementation.
The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
         */
        var maximumCubeMapSize: number;
        /**
         * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
         */
        var maximumFragmentUniformVectors: number;
        /**
         * The maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
         */
        var maximumTextureImageUnits: number;
        /**
         * The maximum renderbuffer width and height supported by this WebGL implementation.
The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
         */
        var maximumRenderbufferSize: number;
        /**
         * The approximate maximum texture width and height supported by this WebGL implementation.
The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
         */
        var maximumTextureSize: number;
        /**
         * The maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
         */
        var maximumVaryingVectors: number;
        /**
         * The maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
         */
        var maximumVertexAttributes: number;
        /**
         * The maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
The minimum is zero, which means the GL does not support vertex texture fetch.
         */
        var maximumVertexTextureImageUnits: number;
        /**
         * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
         */
        var maximumVertexUniformVectors: number;
        /**
         * The minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
         */
        var minimumAliasedLineWidth: number;
        /**
         * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
         */
        var maximumAliasedLineWidth: number;
        /**
         * The minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
         */
        var minimumAliasedPointSize: number;
        /**
         * The maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
         */
        var maximumAliasedPointSize: number;
        /**
         * The maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
         */
        var maximumViewportWidth: number;
        /**
         * The maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
         */
        var maximumViewportHeight: number;
        /**
         * The maximum degree of anisotropy for texture filtering
         */
        var maximumTextureFilterAnisotropy: number;
        /**
         * The maximum number of simultaneous outputs that may be written in a fragment shader.
         */
        var maximumDrawBuffers: number;
        /**
         * The maximum number of color attachments supported.
         */
        var maximumColorAttachments: number;
        /**
         * High precision float supported (<code>highp</code>) in fragment shaders.
         */
        var highpFloatSupported: Boolean;
        /**
         * High precision int supported (<code>highp</code>) in fragment shaders.
         */
        var highpIntSupported: Boolean;
    }
    module UniformFloat {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformFloatVec2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformFloatVec3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformFloatVec4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformSampler {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformInt {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformIntVec2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformIntVec3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformIntVec4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformMat2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformMat3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformMat4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayFloat {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayFloatVec2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayFloatVec3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayFloatVec4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArraySampler {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayInt {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayIntVec2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayIntVec3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayIntVec4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayMat2 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayMat3 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module UniformArrayMat4 {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var name: any;
    }
    module CubeMap {
        /**
         * Generates a complete mipmap chain for each cubemap face.
         * @param hint  (Optional) A performance vs. quality hint.
         */
        function generateMipmap(hint?: MipmapHint): void;
    }
    module CubeMapFace {
        /**
         * Copies texels from the source to the cubemap's face.
         * @param source  (Required) The source ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, or an object with a width, height, and typed array as shown in the example.
         * @param xOffset  (Optional) An offset in the x direction in the cubemap where copying begins.
         * @param yOffset  (Optional) An offset in the y direction in the cubemap where copying begins.
         */
        function copyFrom(source: any, xOffset?: number, yOffset?: number): void;
        /**
         * Copies texels from the framebuffer to the cubemap's face.
         * @param xOffset  (Optional) An offset in the x direction in the cubemap where copying begins.
         * @param yOffset  (Optional) An offset in the y direction in the cubemap where copying begins.
         * @param framebufferXOffset  (Optional) An offset in the x direction in the framebuffer where copying begins from.
         * @param framebufferYOffset  (Optional) An offset in the y direction in the framebuffer where copying begins from.
         * @param width  (Optional) The width of the subimage to copy.
         * @param height  (Optional) The height of the subimage to copy.
         */
        function copyFromFramebuffer(xOffset?: number, yOffset?: number, framebufferXOffset?: number, framebufferYOffset?: number, width?: number, height?: number): void;
    }
    module DrawCommand {
        /**
         * Executes the draw command.
         * @param context  (Required) The renderer context in which to draw.
         * @param passState  (Optional) The state for the current render pass.
         */
        function execute(context: Context, passState?: PassState): void;
    }
    module Framebuffer {
        /**
         * When true, the framebuffer owns its attachments so they will be destroyed when
{@link Framebuffer#destroy} is called or when a new attachment is assigned
to an attachment point.
         */
        var destroyAttachments: Boolean;
        /**
         * The status of the framebuffer. If the status is not WebGLConstants.FRAMEBUFFER_COMPLETE,
a {@link DeveloperError} will be thrown when attempting to render to the framebuffer.
         */
        var status: number;
        /**
         * True if the framebuffer has a depth attachment.  Depth attachments include
depth and depth-stencil textures, and depth and depth-stencil renderbuffers.  When
rendering to a framebuffer, a depth attachment is required for the depth test to have effect.
         */
        var hasDepthAttachment: Boolean;
    }
    module PassState {
        /**
         * The context used to execute commands for this pass.
         */
        var context: Context;
        /**
         * The framebuffer to render to.  This framebuffer is used unless a {@link DrawCommand}
or {@link ClearCommand} explicitly define a framebuffer, which is used for off-screen
rendering.
         */
        var framebuffer: Framebuffer;
        /**
         * When defined, this overrides the blending property of a {@link DrawCommand}'s render state.
This is used to, for example, to allow the renderer to turn off blending during the picking pass.
<p>
When this is <code>undefined</code>, the {@link DrawCommand}'s property is used.
</p>
         */
        var blendingEnabled: Boolean;
        /**
         * When defined, this overrides the scissor test property of a {@link DrawCommand}'s render state.
This is used to, for example, to allow the renderer to scissor out the pick region during the picking pass.
<p>
When this is <code>undefined</code>, the {@link DrawCommand}'s property is used.
</p>
         */
        var scissorTest: any;
        /**
         * The viewport used when one is not defined by a {@link DrawCommand}'s render state.
         */
        var viewport: BoundingRectangle;
    }
    module ShaderProgram {
        /**
         * GLSL source for the shader program's vertex shader.
         */
        var vertexShaderSource: ShaderSource;
        /**
         * GLSL source for the shader program's fragment shader.
         */
        var fragmentShaderSource: ShaderSource;
    }
    module ShaderSource {
        /**
         * Create a single string containing the full, combined vertex shader with all dependencies and defines.
         */
        function createCombinedVertexShader(): string;
        /**
         * Create a single string containing the full, combined fragment shader with all dependencies and defines.
         */
        function createCombinedFragmentShader(): string;
    }
    module Texture {
        /**
         * The sampler to use when sampling this texture.
Create a sampler by calling {@link Sampler}.  If this
parameter is not specified, a default sampler is used.  The default sampler clamps texture
coordinates in both directions, uses linear filtering for both magnification and minifcation,
and uses a maximum anisotropy of 1.0.
         */
        var sampler: any;
        /**
         * Copy new image data into this texture, from a source {@link ImageData}, {@link Image}, {@link Canvas}, or {@link Video}.
or an object with width, height, and arrayBufferView properties.
         * @param source  (Required) The source {@link ImageData}, {@link Image}, {@link Canvas}, or {@link Video},
                       or an object with width, height, and arrayBufferView properties.
         * @param xOffset  (Optional) The offset in the x direction within the texture to copy into.
         * @param yOffset  (Optional) The offset in the y direction within the texture to copy into.
         */
        function copyFrom(source: any, xOffset?: number, yOffset?: number): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         * @param xOffset  (Optional) The offset in the x direction within the texture to copy into.
         * @param yOffset  (Optional) The offset in the y direction within the texture to copy into.
         * @param framebufferXOffset  (Optional) optional
         * @param framebufferYOffset  (Optional) optional
         * @param width  (Optional) optional
         * @param height  (Optional) optional
         */
        function copyFromFramebuffer(xOffset?: number, yOffset?: number, framebufferXOffset?: number, framebufferYOffset?: number, width?: number, height?: number): void;
        /**
         * TODO: This method has no documentation. Contact the library author if this method should be documented
         * @param hint  (Optional) optional.
         */
        function generateMipmap(hint?: MipmapHint): void;
    }
    module UniformState {
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var globeDepthTexture: Texture;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var frameState: FrameState;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var viewport: BoundingRectangle;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var model: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseModel: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var view: Matrix4;
        /**
         * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},
but in 2D and Columbus View it is a synthetic matrix based on the equivalent position
of the camera in the 3D world.
         */
        var view3D: Matrix4;
        /**
         * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).
         */
        var viewRotation: Matrix3;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var viewRotation3D: Matrix3;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseView: Matrix4;
        /**
         * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is
identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix
based on the equivalent position of the camera in the 3D world.
         */
        var inverseView3D: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseViewRotation: Matrix3;
        /**
         * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).
         */
        var inverseViewRotation3D: Matrix3;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var projection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseProjection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var infiniteProjection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var modelView: Matrix4;
        /**
         * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and
Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.
         */
        var modelView3D: Matrix4;
        /**
         * Model-view relative to eye matrix.
         */
        var modelViewRelativeToEye: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseModelView: Matrix4;
        /**
         * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.
In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.
         */
        var inverseModelView3D: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var viewProjection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseViewProjection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var modelViewProjection: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var inverseModelViewProjection: Matrix4;
        /**
         * Model-view-projection relative to eye matrix.
         */
        var modelViewProjectionRelativeToEye: Matrix4;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var modelViewInfiniteProjection: Matrix4;
        /**
         * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to
eye coordinates.
         */
        var normal: Matrix3;
        /**
         * A 3x3 normal transformation matrix that transforms normal vectors in 3D model
coordinates to eye coordinates.  In 3D mode, this is identical to
{@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation
matrix as if the camera were at an equivalent location in 3D mode.
         */
        var normal3D: Matrix3;
        /**
         * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates
to eye coordinates.
         */
        var inverseNormal: Matrix3;
        /**
         * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates
to 3D model coordinates.  In 3D mode, this is identical to
{@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation
matrix as if the camera were at an equivalent location in 3D mode.
         */
        var inverseNormal3D: Matrix3;
        /**
         * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.
This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.
         */
        var entireFrustum: Cartesian2;
        /**
         * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.
This is the individual frustum used for multi-frustum rendering.
         */
        var currentFrustum: Cartesian2;
        /**
         * The distances to the frustum planes. The top, bottom, left and right distances are
the x, y, z, and w components, respectively.
         */
        var frustumPlanes: Cartesian4;
        /**
         * The the height (<code>x</code>) and the height squared (<code>y</code>)
in meters of the camera above the 2D world plane. This uniform is only valid
when the {@link SceneMode} equal to <code>SCENE2D</code>.
         */
        var eyeHeight2D: Cartesian2;
        /**
         * The sun position in 3D world coordinates at the current scene time.
         */
        var sunPositionWC: Cartesian3;
        /**
         * The sun position in 2D world coordinates at the current scene time.
         */
        var sunPositionColumbusView: Cartesian3;
        /**
         * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or
Columbus View mode, this returns the position of the sun in the 3D scene.
         */
        var sunDirectionWC: Cartesian3;
        /**
         * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this
returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns
the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.
         */
        var sunDirectionEC: Cartesian3;
        /**
         * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this
returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns
the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.
         */
        var moonDirectionEC: Cartesian3;
        /**
         * The high bits of the camera position.
         */
        var encodedCameraPositionMCHigh: Cartesian3;
        /**
         * The low bits of the camera position.
         */
        var encodedCameraPositionMCLow: Cartesian3;
        /**
         * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the
pseudo-fixed axes at the Scene's current time.
         */
        var temeToPseudoFixedMatrix: Matrix3;
        /**
         * Gets the scaling factor for transforming from the canvas
pixel space to canvas coordinate space.
         */
        var resolutionScale: number;
        /**
         * A scalar used to mix a color with the fog color based on the distance to the camera.
         */
        var fogDensity: number;
        /**
         * TODO: This property has no documentation. Contact the library author if this property should be documented
         */
        var pass: Pass;
        /**
         * Synchronizes the frustum's state with the camera state.  This is called
by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
are set to the right value.
         * @param camera  (Required) The camera to synchronize with.
         */
        function updateCamera(camera: any): void;
        /**
         * Synchronizes the frustum's state with the uniform state.  This is called
by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
are set to the right value.
         * @param frustum  (Required) The frustum to synchronize with.
         */
        function updateFrustum(frustum: any): void;
        /**
         * Synchronizes frame state with the uniform state.  This is called
by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
are set to the right value.
         * @param frameState  (Required) The frameState to synchronize with.
         */
        function update(frameState: FrameState): void;
    }
    module VertexArray {
        /**
         * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data
in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL
memory for use with rendering.
<br /><br />
The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.
<br /><br />
<code>options</code> can have four properties:
<ul>
  <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>
  <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>
  <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>
  <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>
</ul>
<br />
If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.
         * @param options  (Required) An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.
         */
        function fromGeometry(options: any): void;
        /**
         * index is the location in the array of attributes, not the index property of an attribute.
         */
        function getAttribute(): void;
    }
    module VertexArrayFacade {
        /**
         * Invalidates writers.  Can't render again until commit is called.
         */
        function resize(): void;
    }
    module BingMapsStyle {
        /**
         * Aerial imagery.
         */
        var AERIAL: string;
        /**
         * Aerial imagery with a road overlay.
         */
        var AERIAL_WITH_LABELS: string;
        /**
         * Roads without additional imagery.
         */
        var ROAD: string;
        /**
         * Ordnance Survey imagery
         */
        var ORDNANCE_SURVEY: string;
        /**
         * Collins Bart imagery.
         */
        var COLLINS_BART: string;
    }
    module BlendEquation {
        /**
         * Pixel values are added componentwise.  This is used in additive blending for translucency.
         */
        var ADD: number;
        /**
         * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.
         */
        var SUBTRACT: number;
        /**
         * Pixel values are subtracted componentwise (destination - source).
         */
        var REVERSE_SUBTRACT: number;
    }
    module BlendFunction {
        /**
         * The blend factor is zero.
         */
        var ZERO: number;
        /**
         * The blend factor is one.
         */
        var ONE: number;
        /**
         * The blend factor is the source color.
         */
        var SOURCE_COLOR: number;
        /**
         * The blend factor is one minus the source color.
         */
        var ONE_MINUS_SOURCE_COLOR: number;
        /**
         * The blend factor is the destination color.
         */
        var DESTINATION_COLOR: number;
        /**
         * The blend factor is one minus the destination color.
         */
        var ONE_MINUS_DESTINATION_COLOR: number;
        /**
         * The blend factor is the source alpha.
         */
        var SOURCE_ALPHA: number;
        /**
         * The blend factor is one minus the source alpha.
         */
        var ONE_MINUS_SOURCE_ALPHA: number;
        /**
         * The blend factor is the destination alpha.
         */
        var DESTINATION_ALPHA: number;
        /**
         * The blend factor is one minus the destination alpha.
         */
        var ONE_MINUS_DESTINATION_ALPHA: number;
        /**
         * The blend factor is the constant color.
         */
        var CONSTANT_COLOR: number;
        /**
         * The blend factor is one minus the constant color.
         */
        var ONE_MINUS_CONSTANT_COLOR: number;
        /**
         * The blend factor is the constant alpha.
         */
        var CONSTANT_ALPHA: number;
        /**
         * The blend factor is one minus the constant alpha.
         */
        var ONE_MINUS_CONSTANT_ALPHA: number;
        /**
         * The blend factor is the saturated source alpha.
         */
        var SOURCE_ALPHA_SATURATE: number;
    }
    module BlendingState {
        /**
         * Blending is disabled.
         */
        var DISABLED: any;
        /**
         * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.
         */
        var ALPHA_BLEND: any;
        /**
         * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.
         */
        var PRE_MULTIPLIED_ALPHA_BLEND: any;
        /**
         * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.
         */
        var ADDITIVE_BLEND: any;
    }
    module CameraEventType {
        /**
         * A left mouse button press followed by moving the mouse and releasing the button.
         */
        var LEFT_DRAG: number;
        /**
         * A right mouse button press followed by moving the mouse and releasing the button.
         */
        var RIGHT_DRAG: number;
        /**
         * A middle mouse button press followed by moving the mouse and releasing the button.
         */
        var MIDDLE_DRAG: number;
        /**
         * Scrolling the middle mouse button.
         */
        var WHEEL: number;
        /**
         * A two-finger touch on a touch surface.
         */
        var PINCH: number;
    }
    module CullFace {
        /**
         * Front-facing triangles are culled.
         */
        var FRONT: number;
        /**
         * Back-facing triangles are culled.
         */
        var BACK: number;
        /**
         * Both front-facing and back-facing triangles are culled.
         */
        var FRONT_AND_BACK: number;
    }
    module DepthFunction {
        /**
         * The depth test never passes.
         */
        var NEVER: number;
        /**
         * The depth test passes if the incoming depth is less than the stored depth.
         */
        var LESS: number;
        /**
         * The depth test passes if the incoming depth is equal to the stored depth.
         */
        var EQUAL: number;
        /**
         * The depth test passes if the incoming depth is less than or equal to the stored depth.
         */
        var LESS_OR_EQUAL: number;
        /**
         * The depth test passes if the incoming depth is greater than the stored depth.
         */
        var GREATER: number;
        /**
         * The depth test passes if the incoming depth is not equal to the stored depth.
         */
        var NOT_EQUAL: number;
        /**
         * The depth test passes if the incoming depth is greater than or equal to the stored depth.
         */
        var GREATER_OR_EQUAL: number;
        /**
         * The depth test always passes.
         */
        var ALWAYS: number;
    }
    module DeviceOrientationCameraController {
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
         */
        function isDestroyed(): Boolean;
        /**
         * Destroys the resources held by this object.  Destroying an object allows for deterministic
release of resources, instead of relying on the garbage collector to destroy this object.
<br /><br />
Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        function destroy(): void;
    }
    module HeightReference {
        /**
         * The position is absolute.
         */
        var NONE: number;
        /**
         * The position is clamped to the terrain.
         */
        var CLAMP_TO_GROUND: number;
        /**
         * The position height is the height above the terrain.
         */
        var RELATIVE_TO_GROUND: number;
    }
    module HorizontalOrigin {
        /**
         * The origin is at the horizontal center of the object.
         */
        var CENTER: number;
        /**
         * The origin is on the left side of the object.
         */
        var LEFT: number;
        /**
         * The origin is on the right side of the object.
         */
        var RIGHT: number;
    }
    module LabelStyle {
        /**
         * Fill the text of the label, but do not outline.
         */
        var FILL: number;
        /**
         * Outline the text of the label, but do not fill.
         */
        var OUTLINE: number;
        /**
         * Fill and outline the text of the label.
         */
        var FILL_AND_OUTLINE: number;
    }
    module MapMode2D {
        /**
         * The 2D map can be rotated about the z axis.
         */
        var ROTATE: number;
        /**
         * The 2D map can be scrolled infinitely in the horizontal direction.
         */
        var INFINITE_SCROLL: number;
    }
    module MaterialAppearance {
        module MaterialSupport {
            /**
             * Only basic materials, which require just <code>position</code> and
<code>normal</code> vertex attributes, are supported.
             */
            var BASIC: any;
            /**
             * Materials with textures, which require <code>position</code>,
<code>normal</code>, and <code>st</code> vertex attributes,
are supported.  The vast majority of materials fall into this category.
             */
            var TEXTURED: any;
            /**
             * All materials, including those that work in tangent space, are supported.
This requires <code>position</code>, <code>normal</code>, <code>st</code>,
<code>binormal</code>, and <code>tangent</code> vertex attributes.
             */
            var ALL: any;
        }
    }
    module ModelAnimationLoop {
        /**
         * Play the animation once; do not loop it.
         */
        var NONE: number;
        /**
         * Loop the animation playing it from the start immediately after it stops.
         */
        var REPEAT: number;
        /**
         * Loop the animation.  First, playing it forward, then in reverse, then forward, and so on.
         */
        var MIRRORED_REPEAT: number;
    }
    module PerformanceDisplay {
        /**
         * Update the display.  This function should only be called once per frame, because
each call records a frame in the internal buffer and redraws the display.
         */
        function update(): void;
        /**
         * Destroys the WebGL resources held by this object.
         */
        function destroy(): void;
    }
    module SceneMode {
        /**
         * Morphing between mode, e.g., 3D to 2D.
         */
        var MORPHING: number;
        /**
         * Columbus View mode.  A 2.5D perspective view where the map is laid out
flat and objects with non-zero height are drawn above it.
         */
        var COLUMBUS_VIEW: number;
        /**
         * 2D mode.  The map is viewed top-down with an orthographic projection.
         */
        var SCENE2D: number;
        /**
         * 3D mode.  A traditional 3D perspective view of the globe.
         */
        var SCENE3D: number;
        /**
         * Returns the morph time for the given scene mode.
         * @param value  (Required) The scene mode
         */
        function getMorphTime(value: number): number;
    }
    module SceneTransforms {
        /**
         * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an
HTML element at the same screen position as an object in the scene.
         * @param scene  (Required) The scene.
         * @param position  (Required) The position in WGS84 (world) coordinates.
         * @param result  (Optional) An optional object to return the input position transformed to window coordinates.
         */
        function wgs84ToWindowCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
        /**
         * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different
results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.
         * @param scene  (Required) The scene.
         * @param position  (Required) The position in WGS84 (world) coordinates.
         * @param result  (Optional) An optional object to return the input position transformed to window coordinates.
         */
        function wgs84ToDrawingBufferCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
    }
    module SceneTransitioner {
        /**
         * Returns true if this object was destroyed; otherwise, false.
<br /><br />
If this object was destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         */
        function isDestroyed(): Boolean;
        /**
         * Once an object is destroyed, it should not be used; calling any function other than
<code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
assign the return value (<code>undefined</code>) to the object as done in the example.
         */
        function destroy(): void;
    }
    module ShadowMode {
        /**
         * The object does not cast or receive shadows.
         */
        var DISABLED: number;
        /**
         * The object casts and receives shadows.
         */
        var ENABLED: number;
        /**
         * The object casts shadows only.
         */
        var CAST_ONLY: number;
        /**
         * The object receives shadows only.
         */
        var RECEIVE_ONLY: number;
    }
    module StencilFunction {
        /**
         * The stencil test never passes.
         */
        var NEVER: number;
        /**
         * The stencil test passes when the masked reference value is less than the masked stencil value.
         */
        var LESS: number;
        /**
         * The stencil test passes when the masked reference value is equal to the masked stencil value.
         */
        var EQUAL: number;
        /**
         * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
         */
        var LESS_OR_EQUAL: number;
        /**
         * The stencil test passes when the masked reference value is greater than the masked stencil value.
         */
        var GREATER: number;
        /**
         * The stencil test passes when the masked reference value is not equal to the masked stencil value.
         */
        var NOT_EQUAL: number;
        /**
         * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
         */
        var GREATER_OR_EQUAL: number;
        /**
         * The stencil test always passes.
         */
        var ALWAYS: number;
    }
    module StencilOperation {
        /**
         * Sets the stencil buffer value to zero.
         */
        var ZERO: number;
        /**
         * Does not change the stencil buffer.
         */
        var KEEP: number;
        /**
         * Replaces the stencil buffer value with the reference value.
         */
        var REPLACE: number;
        /**
         * Increments the stencil buffer value, clamping to unsigned byte.
         */
        var INCREMENT: number;
        /**
         * Decrements the stencil buffer value, clamping to zero.
         */
        var DECREMENT: number;
        /**
         * Bitwise inverts the existing stencil buffer value.
         */
        var INVERT: number;
        /**
         * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.
         */
        var INCREMENT_WRAP: number;
        /**
         * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.
         */
        var DECREMENT_WRAP: number;
    }
    module TileBoundingBox {
        /**
         * The world coordinates of the southwest corner of the tile's rectangle.
         */
        var southwestCornerCartesian: Cartesian3;
        /**
         * The world coordinates of the northeast corner of the tile's rectangle.
         */
        var northeastCornerCartesian: Cartesian3;
        /**
         * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of
the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         */
        var westNormal: Cartesian3;
        /**
         * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of
the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
Because points of constant latitude do not necessary lie in a plane, positions below this
plane are not necessarily inside the tile, but they are close.
         */
        var southNormal: Cartesian3;
        /**
         * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
         */
        var eastNormal: Cartesian3;
        /**
         * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
Because points of constant latitude do not necessary lie in a plane, positions below this
plane are not necessarily inside the tile, but they are close.
         */
        var northNormal: Cartesian3;
        /**
         * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.
         * @param frameState  (Required) The state information of the current rendering frame.
         */
        function distanceToCamera(frameState: FrameState): number;
    }
    module TileImagery {
        /**
         * Frees the resources held by this instance.
         */
        function freeResources(): void;
        /**
         * Processes the load state machine for this instance.
         * @param tile  (Required) The tile to which this instance belongs.
         * @param frameState  (Required) The frameState.
         */
        function processStateMachine(tile: Tile, frameState: FrameState): Boolean;
    }
    module TileReplacementQueue {
        /**
         * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the
list were used last frame and must not be unloaded.
         */
        function markStartOfRenderFrame(): void;
        /**
         * Reduces the size of the queue to a specified size by unloading the least-recently used
tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number
of tiles above the specified maximum.
         * @param maximumTiles  (Required) The maximum number of tiles in the queue.
         */
        function trimTiles(maximumTiles: number): void;
        /**
         * Marks a tile as rendered this frame and moves it before the first tile that was not rendered
this frame.
         * @param item  (Required) The tile that was rendered.
         */
        function markTileRendered(item: TileReplacementQueue): void;
    }
    module VerticalOrigin {
        /**
         * The origin is at the vertical center of the object.
         */
        var CENTER: number;
        /**
         * The origin is at the bottom of the object.
         */
        var BOTTOM: number;
        /**
         * The origin is at the top of the object.
         */
        var TOP: number;
    }
    module viewerDragDropMixin {
        /**
         * Gets or sets the element to serve as the drop target.
         */
        var dropTarget: Element;
        /**
         * Gets or sets a value indicating if drag and drop support is enabled.
         */
        var dropEnabled: Element;
        /**
         * Gets the event that will be raised when an error is encountered during drop processing.
         */
        var dropError: Event;
        /**
         * Gets or sets a value indicating if existing data sources should be cleared before adding the newly dropped sources.
         */
        var clearOnDrop: Boolean;
        /**
         * Gets or sets a value indicating if the camera should fly to the data source after it is loaded.
         */
        var flyToOnDrop: Boolean;
        /**
         * Gets or sets the proxy to be used for KML.
         */
        var proxy: DefaultProxy;
        /**
         * Gets or sets a value indicating if the datasources should be clamped to the ground
         */
        var clampToGround: Boolean;
    }

}